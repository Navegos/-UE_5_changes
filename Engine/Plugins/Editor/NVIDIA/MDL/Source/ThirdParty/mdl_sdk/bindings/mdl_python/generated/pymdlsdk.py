# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _pymdlsdk
else:
    import _pymdlsdk

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


MDL_SOURCE_RELEASE = _pymdlsdk.MDL_SOURCE_RELEASE
ADD_STANDALONE_SUPPORT = _pymdlsdk.ADD_STANDALONE_SUPPORT

from enum import Enum

class Uuid(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    m_id1 = property(_pymdlsdk.Uuid_m_id1_get, _pymdlsdk.Uuid_m_id1_set, doc=r""" First  value.""")
    m_id2 = property(_pymdlsdk.Uuid_m_id2_get, _pymdlsdk.Uuid_m_id2_set, doc=r""" Second value.""")
    m_id3 = property(_pymdlsdk.Uuid_m_id3_get, _pymdlsdk.Uuid_m_id3_set, doc=r""" Third  value.""")
    m_id4 = property(_pymdlsdk.Uuid_m_id4_get, _pymdlsdk.Uuid_m_id4_set, doc=r""" Fourth value.""")

    def __init__(self):
        _pymdlsdk.Uuid_swiginit(self, _pymdlsdk.new_Uuid())
    __swig_destroy__ = _pymdlsdk.delete_Uuid

# Register Uuid in _pymdlsdk:
_pymdlsdk.Uuid_swigregister(Uuid)

class IInterface(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IInterface_swiginit(self, _pymdlsdk.new_IInterface(*args))
    __swig_destroy__ = _pymdlsdk.delete_IInterface

    def __deref__(self):
        return _pymdlsdk.IInterface___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IInterface___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IInterface_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IInterface___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IInterface___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IInterface_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IInterface_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IInterface__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface.

        :rtype: boolean
        :return: ``true`` if ``iid`` == #mi::base::IInterface::IID(), and ``false`` otherwise.
        """
        return _pymdlsdk.IInterface_compare_iid(self, iid)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IInterface__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IInterface__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IInterface_get_iid(self)

# Register IInterface in _pymdlsdk:
_pymdlsdk.IInterface_swigregister(IInterface)

def IInterface_IID():
    return _pymdlsdk.IInterface_IID()

def IInterface__get_interface(iface):
    return _pymdlsdk.IInterface__get_interface(iface)

class Interface_declare_IData(object):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IData_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IData

# Register Interface_declare_IData in _pymdlsdk:
_pymdlsdk.Interface_declare_IData_swigregister(Interface_declare_IData)

def Interface_declare_IData_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IData_compare_iid(iid)

class _IData(Interface_declare_IData):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_type_name(self):
        r""" Returns the type name."""
        return _pymdlsdk._IData_get_type_name(self)

# Register _IData in _pymdlsdk:
_pymdlsdk._IData_swigregister(_IData)

class Interface_declare_IData_simple(_IData):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IData_simple_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IData_simple

# Register Interface_declare_IData_simple in _pymdlsdk:
_pymdlsdk.Interface_declare_IData_simple_swigregister(Interface_declare_IData_simple)

def Interface_declare_IData_simple_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IData_simple_compare_iid(iid)

class _IData_simple(Interface_declare_IData_simple):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

# Register _IData_simple in _pymdlsdk:
_pymdlsdk._IData_simple_swigregister(_IData_simple)

class Interface_declare_IData_collection(_IData):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IData_collection_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IData_collection

# Register Interface_declare_IData_collection in _pymdlsdk:
_pymdlsdk.Interface_declare_IData_collection_swigregister(Interface_declare_IData_collection)

def Interface_declare_IData_collection_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IData_collection_compare_iid(iid)

class _IData_collection(Interface_declare_IData_collection):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_length(self):
        r""" Returns the number of values."""
        return _pymdlsdk._IData_collection_get_length(self)

    def get_key(self, index):
        r"""
        Returns the key corresponding to ``index``.

        :rtype: string
        :return: The key, or ``NULL`` in case of failure.
        """
        return _pymdlsdk._IData_collection_get_key(self, index)

    def has_key(self, key):
        r""" Indicates whether the key ``key`` exists or not."""
        return _pymdlsdk._IData_collection_has_key(self, key)

    def get_value(self, *args):
        r"""
        *Overload 1:*
        Returns the value for key ``key``.

        Notes: If a literal ``0`` is passed for ``key``, the call is ambiguous. You need to
                  explicitly cast the argument to ``const`` ``char*``.

        |

        *Overload 2:*
        Returns the value for key ``key``.

        Notes: If a literal ``0`` is passed for ``key``, the call is ambiguous. You need to
                  explicitly cast the argument to ``const`` ``char*``.

        |

        *Overload 3:*
        Returns the value for index ``index``.

        Notes: If a literal ``0`` is passed for ``index``, the call is ambiguous. You need to
                  explicitly cast the argument to #mi::Size.

        |

        *Overload 4:*
        Returns the value for index ``index``.

        Notes: If a literal ``0`` is passed for ``index``, the call is ambiguous. You need to
                  explicitly cast the argument to #mi::Size.
        """
        return _pymdlsdk._IData_collection_get_value(self, *args)

    def set_value(self, *args):
        r"""
        *Overload 1:*
        Stores the value for key ``key``.

        Note that it is not possible to create new keys.

        Notes: If a literal ``0`` is passed for ``key``, the call is ambiguous. You need to
                  explicitly cast the argument to ``const`` ``char*``.

        :rtype: int
        :return: 
                      -  0: Success.
                      - -1: Invalid parameters (``NULL`` pointer).
                      - -2: Invalid key.
                      - -3: ``value`` has the wrong type.

        |

        *Overload 2:*
        Stores the value for index ``index``.

        Note that it is not possible to create new indices.

        Notes: If a literal ``0`` is passed for ``index``, the call is ambiguous. You need to
                  explicitly cast the argument to #mi::Size.

        :rtype: int
        :return: 
                      -  0: Success.
                      - -1: Invalid parameters (``NULL`` pointer).
                      - -2: Invalid index.
                      - -3: ``value`` has the wrong type.
        """
        return _pymdlsdk._IData_collection_set_value(self, *args)

# Register _IData_collection in _pymdlsdk:
_pymdlsdk._IData_collection_swigregister(_IData_collection)

class Interface_declare_IVoid(_IData_simple):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IVoid_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IVoid

# Register Interface_declare_IVoid in _pymdlsdk:
_pymdlsdk.Interface_declare_IVoid_swigregister(Interface_declare_IVoid)

def Interface_declare_IVoid_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IVoid_compare_iid(iid)

class _IVoid(Interface_declare_IVoid):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

# Register _IVoid in _pymdlsdk:
_pymdlsdk._IVoid_swigregister(_IVoid)

class Interface_declare_IString(_IData_simple):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IString_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IString

# Register Interface_declare_IString in _pymdlsdk:
_pymdlsdk.Interface_declare_IString_swigregister(Interface_declare_IString)

def Interface_declare_IString_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IString_compare_iid(iid)

class _IString(Interface_declare_IString):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_c_str(self):
        r"""
        Returns the content as a C-style string.

        :rtype: string
        :return: The stored string as a C-style string. Never returns ``NULL``.
        """
        return _pymdlsdk._IString_get_c_str(self)

    def set_c_str(self, str):
        r"""
        Sets the content via a C-style string.

        :type str: string
        :param str:   The string to store as a C-style string. The value ``NULL`` is treated as the
                         empty string.
        """
        return _pymdlsdk._IString_set_c_str(self, str)

# Register _IString in _pymdlsdk:
_pymdlsdk._IString_swigregister(_IString)

class Interface_declare_IArray(_IData_collection):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IArray_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IArray

# Register Interface_declare_IArray in _pymdlsdk:
_pymdlsdk.Interface_declare_IArray_swigregister(Interface_declare_IArray)

def Interface_declare_IArray_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IArray_compare_iid(iid)

class _IArray(Interface_declare_IArray):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_length(self):
        r"""
        Returns the size of the array.

        The size of an array is the number of elements in the array.
        """
        return _pymdlsdk._IArray_get_length(self)

    def get_element(self, *args):
        r"""
        *Overload 1:*
        Returns the ``index`` -th element of the array.

        :type index: int
        :param index:   The index of the requested element.
        :rtype: mi::base::IInterface
        :return: The requested element, or ``NULL`` if ``index`` is equal to or larger than
                           the size of the array.

        |

        *Overload 2:*
        Returns the ``index`` -th element of the array.

        :type index: int
        :param index:   The index of the requested element.
        :rtype: mi::base::IInterface
        :return: The requested element, or ``NULL`` if ``index`` is equal to or larger than
                           the size of the array.
        """
        return _pymdlsdk._IArray_get_element(self, *args)

    def set_element(self, index, element):
        r"""
        Sets the ``index`` -th element of the array.

        The object ``element`` is stored as ``index`` -th element of the array.

        :type index: int
        :param index:        The index where the object should be stored. The method call gets
                                ignored if ``index`` is equal to or larger than the size of the array.
        :type element: mi::base::IInterface
        :param element:      The object to be stored.
        :rtype: int
        :return: 
                                -  0: Success.
                                - -1: ``index`` is out of bounds.
                                - -2: ``element`` is ``NULL`` or has the wrong type.
        """
        return _pymdlsdk._IArray_set_element(self, index, element)

    def empty(self):
        r"""
        Checks whether the array is empty.

        Equivalent to #get_length() == 0.
        """
        return _pymdlsdk._IArray_empty(self)

# Register _IArray in _pymdlsdk:
_pymdlsdk._IArray_swigregister(_IArray)

class IArray(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IArray_swiginit(self, _pymdlsdk.new_IArray(*args))
    __swig_destroy__ = _pymdlsdk.delete_IArray

    def __deref__(self):
        return _pymdlsdk.IArray___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IArray___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IArray_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IArray___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IArray___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IArray_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IArray_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IArray__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_length(self):
        r"""
        Returns the size of the array.

        The size of an array is the number of elements in the array.
        """
        return _pymdlsdk.IArray_get_length(self)

    def get_element(self, *args):
        r"""
        *Overload 1:*
        Returns the ``index`` -th element of the array.

        :type index: int
        :param index:   The index of the requested element.
        :rtype: mi::base::IInterface
        :return: The requested element, or ``NULL`` if ``index`` is equal to or larger than
                           the size of the array.

        |

        *Overload 2:*
        Returns the ``index`` -th element of the array.

        :type index: int
        :param index:   The index of the requested element.
        :rtype: mi::base::IInterface
        :return: The requested element, or ``NULL`` if ``index`` is equal to or larger than
                           the size of the array.
        """
        return _pymdlsdk.IArray_get_element(self, *args)

    def set_element(self, index, element):
        r"""
        Sets the ``index`` -th element of the array.

        The object ``element`` is stored as ``index`` -th element of the array.

        :type index: int
        :param index:        The index where the object should be stored. The method call gets
                                ignored if ``index`` is equal to or larger than the size of the array.
        :type element: mi::base::IInterface
        :param element:      The object to be stored.
        :rtype: int
        :return: 
                                -  0: Success.
                                - -1: ``index`` is out of bounds.
                                - -2: ``element`` is ``NULL`` or has the wrong type.
        """
        return _pymdlsdk.IArray_set_element(self, index, element)

    def empty(self):
        r"""
        Checks whether the array is empty.

        Equivalent to #get_length() == 0.
        """
        return _pymdlsdk.IArray_empty(self)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IArray_compare_iid(self, iid)

    def get_key(self, index):
        r"""
        Returns the key corresponding to ``index``.

        :rtype: string
        :return: The key, or ``NULL`` in case of failure.
        """
        return _pymdlsdk.IArray_get_key(self, index)

    def has_key(self, key):
        r""" Indicates whether the key ``key`` exists or not."""
        return _pymdlsdk.IArray_has_key(self, key)

    def get_value(self, *args):
        r"""
        *Overload 1:*
        Returns the value for key ``key``.

        Notes: If a literal ``0`` is passed for ``key``, the call is ambiguous. You need to
                  explicitly cast the argument to ``const`` ``char*``.

        |

        *Overload 2:*
        Returns the value for key ``key``.

        Notes: If a literal ``0`` is passed for ``key``, the call is ambiguous. You need to
                  explicitly cast the argument to ``const`` ``char*``.

        |

        *Overload 3:*
        Returns the value for index ``index``.

        Notes: If a literal ``0`` is passed for ``index``, the call is ambiguous. You need to
                  explicitly cast the argument to #mi::Size.

        |

        *Overload 4:*
        Returns the value for index ``index``.

        Notes: If a literal ``0`` is passed for ``index``, the call is ambiguous. You need to
                  explicitly cast the argument to #mi::Size.
        """
        return _pymdlsdk.IArray_get_value(self, *args)

    def set_value(self, *args):
        r"""
        *Overload 1:*
        Stores the value for key ``key``.

        Note that it is not possible to create new keys.

        Notes: If a literal ``0`` is passed for ``key``, the call is ambiguous. You need to
                  explicitly cast the argument to ``const`` ``char*``.

        :rtype: int
        :return: 
                      -  0: Success.
                      - -1: Invalid parameters (``NULL`` pointer).
                      - -2: Invalid key.
                      - -3: ``value`` has the wrong type.

        |

        *Overload 2:*
        Stores the value for index ``index``.

        Note that it is not possible to create new indices.

        Notes: If a literal ``0`` is passed for ``index``, the call is ambiguous. You need to
                  explicitly cast the argument to #mi::Size.

        :rtype: int
        :return: 
                      -  0: Success.
                      - -1: Invalid parameters (``NULL`` pointer).
                      - -2: Invalid index.
                      - -3: ``value`` has the wrong type.
        """
        return _pymdlsdk.IArray_set_value(self, *args)

    def get_type_name(self):
        r""" Returns the type name."""
        return _pymdlsdk.IArray_get_type_name(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IArray__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IArray__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IArray_get_iid(self)

# Register IArray in _pymdlsdk:
_pymdlsdk.IArray_swigregister(IArray)

def IArray_IID():
    return _pymdlsdk.IArray_IID()

def IArray__get_interface(iface):
    return _pymdlsdk.IArray__get_interface(iface)

class IString(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IString_swiginit(self, _pymdlsdk.new_IString(*args))
    __swig_destroy__ = _pymdlsdk.delete_IString

    def __deref__(self):
        return _pymdlsdk.IString___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IString___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IString_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IString___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IString___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IString_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IString_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IString__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_c_str(self):
        r"""
        Returns the content as a C-style string.

        :rtype: string
        :return: The stored string as a C-style string. Never returns ``NULL``.
        """
        return _pymdlsdk.IString_get_c_str(self)

    def set_c_str(self, str):
        r"""
        Sets the content via a C-style string.

        :type str: string
        :param str:   The string to store as a C-style string. The value ``NULL`` is treated as the
                         empty string.
        """
        return _pymdlsdk.IString_set_c_str(self, str)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IString_compare_iid(self, iid)

    def get_type_name(self):
        r""" Returns the type name."""
        return _pymdlsdk.IString_get_type_name(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IString__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IString__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IString_get_iid(self)

# Register IString in _pymdlsdk:
_pymdlsdk.IString_swigregister(IString)

def IString_IID():
    return _pymdlsdk.IString_IID()

def IString__get_interface(iface):
    return _pymdlsdk.IString__get_interface(iface)

class IData(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IData_swiginit(self, _pymdlsdk.new_IData(*args))
    __swig_destroy__ = _pymdlsdk.delete_IData

    def __deref__(self):
        return _pymdlsdk.IData___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IData___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IData_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IData___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IData___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IData_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IData_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IData__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_type_name(self):
        r""" Returns the type name."""
        return _pymdlsdk.IData_get_type_name(self)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IData_compare_iid(self, iid)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IData__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IData__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IData_get_iid(self)

# Register IData in _pymdlsdk:
_pymdlsdk.IData_swigregister(IData)

def IData_IID():
    return _pymdlsdk.IData_IID()

def IData__get_interface(iface):
    return _pymdlsdk.IData__get_interface(iface)

class IData_simple(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IData_simple_swiginit(self, _pymdlsdk.new_IData_simple(*args))
    __swig_destroy__ = _pymdlsdk.delete_IData_simple

    def __deref__(self):
        return _pymdlsdk.IData_simple___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IData_simple___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IData_simple_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IData_simple___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IData_simple___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IData_simple_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IData_simple_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IData_simple__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IData_simple_compare_iid(self, iid)

    def get_type_name(self):
        r""" Returns the type name."""
        return _pymdlsdk.IData_simple_get_type_name(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IData_simple__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IData_simple__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IData_simple_get_iid(self)

# Register IData_simple in _pymdlsdk:
_pymdlsdk.IData_simple_swigregister(IData_simple)

def IData_simple_IID():
    return _pymdlsdk.IData_simple_IID()

def IData_simple__get_interface(iface):
    return _pymdlsdk.IData_simple__get_interface(iface)

class IData_collection(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IData_collection_swiginit(self, _pymdlsdk.new_IData_collection(*args))
    __swig_destroy__ = _pymdlsdk.delete_IData_collection

    def __deref__(self):
        return _pymdlsdk.IData_collection___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IData_collection___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IData_collection_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IData_collection___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IData_collection___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IData_collection_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IData_collection_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IData_collection__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_length(self):
        r""" Returns the number of values."""
        return _pymdlsdk.IData_collection_get_length(self)

    def get_key(self, index):
        r"""
        Returns the key corresponding to ``index``.

        :rtype: string
        :return: The key, or ``NULL`` in case of failure.
        """
        return _pymdlsdk.IData_collection_get_key(self, index)

    def has_key(self, key):
        r""" Indicates whether the key ``key`` exists or not."""
        return _pymdlsdk.IData_collection_has_key(self, key)

    def get_value(self, *args):
        r"""
        *Overload 1:*
        Returns the value for key ``key``.

        Notes: If a literal ``0`` is passed for ``key``, the call is ambiguous. You need to
                  explicitly cast the argument to ``const`` ``char*``.

        |

        *Overload 2:*
        Returns the value for key ``key``.

        Notes: If a literal ``0`` is passed for ``key``, the call is ambiguous. You need to
                  explicitly cast the argument to ``const`` ``char*``.

        |

        *Overload 3:*
        Returns the value for index ``index``.

        Notes: If a literal ``0`` is passed for ``index``, the call is ambiguous. You need to
                  explicitly cast the argument to #mi::Size.

        |

        *Overload 4:*
        Returns the value for index ``index``.

        Notes: If a literal ``0`` is passed for ``index``, the call is ambiguous. You need to
                  explicitly cast the argument to #mi::Size.
        """
        return _pymdlsdk.IData_collection_get_value(self, *args)

    def set_value(self, *args):
        r"""
        *Overload 1:*
        Stores the value for key ``key``.

        Note that it is not possible to create new keys.

        Notes: If a literal ``0`` is passed for ``key``, the call is ambiguous. You need to
                  explicitly cast the argument to ``const`` ``char*``.

        :rtype: int
        :return: 
                      -  0: Success.
                      - -1: Invalid parameters (``NULL`` pointer).
                      - -2: Invalid key.
                      - -3: ``value`` has the wrong type.

        |

        *Overload 2:*
        Stores the value for index ``index``.

        Note that it is not possible to create new indices.

        Notes: If a literal ``0`` is passed for ``index``, the call is ambiguous. You need to
                  explicitly cast the argument to #mi::Size.

        :rtype: int
        :return: 
                      -  0: Success.
                      - -1: Invalid parameters (``NULL`` pointer).
                      - -2: Invalid index.
                      - -3: ``value`` has the wrong type.
        """
        return _pymdlsdk.IData_collection_set_value(self, *args)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IData_collection_compare_iid(self, iid)

    def get_type_name(self):
        r""" Returns the type name."""
        return _pymdlsdk.IData_collection_get_type_name(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IData_collection__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IData_collection__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IData_collection_get_iid(self)

# Register IData_collection in _pymdlsdk:
_pymdlsdk.IData_collection_swigregister(IData_collection)

def IData_collection_IID():
    return _pymdlsdk.IData_collection_IID()

def IData_collection__get_interface(iface):
    return _pymdlsdk.IData_collection__get_interface(iface)

class IVoid(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IVoid_swiginit(self, _pymdlsdk.new_IVoid(*args))
    __swig_destroy__ = _pymdlsdk.delete_IVoid

    def __deref__(self):
        return _pymdlsdk.IVoid___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IVoid___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IVoid_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IVoid___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IVoid___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IVoid_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IVoid_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IVoid__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IVoid_compare_iid(self, iid)

    def get_type_name(self):
        r""" Returns the type name."""
        return _pymdlsdk.IVoid_get_type_name(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IVoid__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IVoid__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IVoid_get_iid(self)

# Register IVoid in _pymdlsdk:
_pymdlsdk.IVoid_swigregister(IVoid)

def IVoid_IID():
    return _pymdlsdk.IVoid_IID()

def IVoid__get_interface(iface):
    return _pymdlsdk.IVoid__get_interface(iface)

MI_NEURAYLIB_API_VERSION = _pymdlsdk.MI_NEURAYLIB_API_VERSION
r"""
    Major and minor version number and an optional qualifier.

    See 'mi_neuray_version'
    API version number.

    A change in this version number indicates that the binary compatibility
    of the interfaces offered through the shared library have changed.
    """
MI_NEURAYLIB_VERSION_MAJOR = _pymdlsdk.MI_NEURAYLIB_VERSION_MAJOR
r"""
    MDL SDK APImajor version number

    See also: 'mi_base_intro_versioning'
    """
MI_NEURAYLIB_VERSION_MINOR = _pymdlsdk.MI_NEURAYLIB_VERSION_MINOR
r"""
    MDL SDK APIminor version number

    See also: 'mi_base_intro_versioning'
    """
MI_NEURAYLIB_VERSION_QUALIFIER = _pymdlsdk.MI_NEURAYLIB_VERSION_QUALIFIER
r"""
    MDL SDK APIversion qualifier

    The version qualifier is a string such as ``"alpha"``,
    ``"beta"``, or ``"beta2"``, or the empty string ``""`` if this is a final
    release, in which case the macro ``MI_NEURAYLIB_VERSION_QUALIFIER_EMPTY``
    is defined as well.

    See also: 'mi_base_intro_versioning'
    """
MI_NEURAYLIB_PRODUCT_VERSION_STRING = _pymdlsdk.MI_NEURAYLIB_PRODUCT_VERSION_STRING
r"""
    MDL SDK APImajor and minor version number without qualifier in a
    string representation, such as ``"2.0"``.
    MDL SDK APImajor and minor version number and qualifier in a
    string representation, such as ``"2.0"`` or ``"2.0-beta2"``.
    The MDL SDKproduct version number in a string representation, such as ``"2.0"``.
    """
MI_NEURAYLIB_PLUGIN_TYPE = _pymdlsdk.MI_NEURAYLIB_PLUGIN_TYPE
r"""
    Type of plugins for the MDL SDK API.
    See also: #mi::base::Plugin::get_type().
    """
PROPAGATION_STANDARD = _pymdlsdk.PROPAGATION_STANDARD
r""" Standard inheritance of attributes without any special flags."""
PROPAGATION_OVERRIDE = _pymdlsdk.PROPAGATION_OVERRIDE
r""" The ``override`` flag for attribute inheritance."""
PROPAGATION_FORCE_32_BIT = _pymdlsdk.PROPAGATION_FORCE_32_BIT
class Interface_declare_IAttribute_set(object):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IAttribute_set_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IAttribute_set

# Register Interface_declare_IAttribute_set in _pymdlsdk:
_pymdlsdk.Interface_declare_IAttribute_set_swigregister(Interface_declare_IAttribute_set)

def Interface_declare_IAttribute_set_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IAttribute_set_compare_iid(iid)

class _IAttribute_set(Interface_declare_IAttribute_set):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def create_attribute(self, name, type):
        r"""
        Creates a new attribute ``name`` of the type ``type``.

        :type name: string
        :param name:         The name of the attribute. The name must not contain ``"["``, ``"]"``, or
                                ``"``."
        :type type: string
        :param type:         The type of the attribute. See 'mi_neuray_types' for a list of
                                supported attribute types.
        :rtype: :py:class:`IData`
        :return: A pointer to the created attribute, or ``NULL`` in case of failure.
                                Reasons for failure are:
                                - ``name`` or ``type`` is invalid,
                                - there is already an attribute with the name ``name``, or
                                - ``name`` is the name of a reserved attribute and ``type`` does not match
                                  the required type(s) of such an attribute.
        """
        return _pymdlsdk._IAttribute_set_create_attribute(self, name, type)

    def destroy_attribute(self, name):
        r"""
        Destroys the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute to destroy.
        :rtype: boolean
        :return: Returns ``true`` if the attribute has been successfully destroyed, and
                                ``false`` otherwise (there is no attribute with the name ``name)``.
        """
        return _pymdlsdk._IAttribute_set_destroy_attribute(self, name)

    def access_attribute(self, name):
        r"""
        Returns a const pointer to the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also access parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: :py:class:`IData`
        :return: A pointer to the attribute, or ``NULL`` if there is no attribute with
                                the name ``name``.
        """
        return _pymdlsdk._IAttribute_set_access_attribute(self, name)

    def edit_attribute(self, name):
        r"""
        Returns a mutable pointer to the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also access parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: :py:class:`IData`
        :return: A pointer to the attribute, or ``NULL`` if there is no attribute with
                                the name ``name``.
        """
        return _pymdlsdk._IAttribute_set_edit_attribute(self, name)

    def is_attribute(self, name):
        r"""
        Indicates existence of an attribute.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also checks for parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: boolean
        :return: ``true`` if the attribute set contains this attribute (and the attribute
                                contains the requested array element or struct member),
                                ``false`` otherwise
        """
        return _pymdlsdk._IAttribute_set_is_attribute(self, name)

    def get_attribute_type_name(self, name):
        r"""
        Returns the type of an attribute.

        See 'mi_neuray_types' for a list of supported attribute types.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also query parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: string
        :return: The type name of the attribute (or part thereof), or ``NULL`` if there
                                is no attribute with the name ``name``.

        Notes: The return value of this method is only valid until the next call of this method
              or any non-const methods on this instance.
        """
        return _pymdlsdk._IAttribute_set_get_attribute_type_name(self, name)

    def set_attribute_propagation(self, name, value):
        r"""
        Sets the propagation type of the attribute ``name``.

        :rtype: int
        :return: 
                                -  0: Success.
                                - -1: Invalid parameters (``NULL`` pointer or invalid enum value).
                                - -2: There is no attribute with name ``name``.
        """
        return _pymdlsdk._IAttribute_set_set_attribute_propagation(self, name, value)

    def get_attribute_propagation(self, name):
        r"""
        Returns the propagation type of the attribute ``name``.

        Notes: This method always returns #PROPAGATION_STANDARD in case of errors.
        """
        return _pymdlsdk._IAttribute_set_get_attribute_propagation(self, name)

    def enumerate_attributes(self, index):
        r"""
        Returns the name of the attribute indicated by ``index``.

        :type index: int
        :param index:        The index of the attribute.
        :rtype: string
        :return: The name of the attribute indicated by ``index``, or ``NULL`` if ``index``
                                is out of bounds.
        """
        return _pymdlsdk._IAttribute_set_enumerate_attributes(self, index)

# Register _IAttribute_set in _pymdlsdk:
_pymdlsdk._IAttribute_set_swigregister(_IAttribute_set)

ELEMENT_TYPE_INSTANCE = _pymdlsdk.ELEMENT_TYPE_INSTANCE
r""" #mi::neuraylib::IInstance"""
ELEMENT_TYPE_GROUP = _pymdlsdk.ELEMENT_TYPE_GROUP
r""" #mi::neuraylib::IGroup"""
ELEMENT_TYPE_OPTIONS = _pymdlsdk.ELEMENT_TYPE_OPTIONS
r""" #mi::neuraylib::IOptions"""
ELEMENT_TYPE_CAMERA = _pymdlsdk.ELEMENT_TYPE_CAMERA
r""" #mi::neuraylib::ICamera"""
ELEMENT_TYPE_LIGHT = _pymdlsdk.ELEMENT_TYPE_LIGHT
r""" #mi::neuraylib::ILight"""
ELEMENT_TYPE_LIGHTPROFILE = _pymdlsdk.ELEMENT_TYPE_LIGHTPROFILE
r""" #mi::neuraylib::ILightprofile"""
ELEMENT_TYPE_TEXTURE = _pymdlsdk.ELEMENT_TYPE_TEXTURE
r""" #mi::neuraylib::ITexture"""
ELEMENT_TYPE_IMAGE = _pymdlsdk.ELEMENT_TYPE_IMAGE
r""" #mi::neuraylib::IImage"""
ELEMENT_TYPE_TRIANGLE_MESH = _pymdlsdk.ELEMENT_TYPE_TRIANGLE_MESH
r""" #mi::neuraylib::ITriangle_mesh"""
ELEMENT_TYPE_ATTRIBUTE_CONTAINER = _pymdlsdk.ELEMENT_TYPE_ATTRIBUTE_CONTAINER
r""" #mi::neuraylib::IAttribute_container"""
ELEMENT_TYPE_POLYGON_MESH = _pymdlsdk.ELEMENT_TYPE_POLYGON_MESH
r""" #mi::neuraylib::IPolygon_mesh"""
ELEMENT_TYPE_SUBDIVISION_SURFACE = _pymdlsdk.ELEMENT_TYPE_SUBDIVISION_SURFACE
r""" #mi::neuraylib::ISubdivision_surface"""
ELEMENT_TYPE_FREEFORM_SURFACE = _pymdlsdk.ELEMENT_TYPE_FREEFORM_SURFACE
r""" #mi::neuraylib::IFreeform_surface"""
ELEMENT_TYPE_FIBERS = _pymdlsdk.ELEMENT_TYPE_FIBERS
r""" #mi::neuraylib::IFibers"""
ELEMENT_TYPE_VOLUME = _pymdlsdk.ELEMENT_TYPE_VOLUME
r""" #mi::neuraylib::IVolume"""
ELEMENT_TYPE_VOLUME_DATA = _pymdlsdk.ELEMENT_TYPE_VOLUME_DATA
r""" #mi::neuraylib::IVolume_data"""
ELEMENT_TYPE_MODULE = _pymdlsdk.ELEMENT_TYPE_MODULE
r""" #mi::neuraylib::IModule"""
ELEMENT_TYPE_FUNCTION_DEFINITION = _pymdlsdk.ELEMENT_TYPE_FUNCTION_DEFINITION
r"""
    #mi::neuraylib::IFunction_definition
    See also: #mi::neuraylib::IMdl_configuration::set_materials_are_functions()
    """
ELEMENT_TYPE_FUNCTION_CALL = _pymdlsdk.ELEMENT_TYPE_FUNCTION_CALL
r"""
    #mi::neuraylib::IFunction_call
    See also: #mi::neuraylib::IMdl_configuration::set_materials_are_functions()
    """
ELEMENT_TYPE_MATERIAL_DEFINITION = _pymdlsdk.ELEMENT_TYPE_MATERIAL_DEFINITION
r"""
    #mi::neuraylib::IMaterial_definition
    See also: #mi::neuraylib::IMdl_configuration::set_materials_are_functions()
    """
ELEMENT_TYPE_MATERIAL_INSTANCE = _pymdlsdk.ELEMENT_TYPE_MATERIAL_INSTANCE
r"""
    #mi::neuraylib::IMaterial_instance
    See also: #mi::neuraylib::IMdl_configuration::set_materials_are_functions()
    """
ELEMENT_TYPE_COMPILED_MATERIAL = _pymdlsdk.ELEMENT_TYPE_COMPILED_MATERIAL
r""" #mi::neuraylib::ICompiled_material"""
ELEMENT_TYPE_BSDF_MEASUREMENT = _pymdlsdk.ELEMENT_TYPE_BSDF_MEASUREMENT
r""" #mi::neuraylib::IBsdf_measurement"""
ELEMENT_TYPE_IRRADIANCE_PROBES = _pymdlsdk.ELEMENT_TYPE_IRRADIANCE_PROBES
r""" #mi::neuraylib::IIrradiance_probes"""
ELEMENT_TYPE_DECAL = _pymdlsdk.ELEMENT_TYPE_DECAL
r""" #mi::neuraylib::IDecal"""
ELEMENT_TYPE_ON_DEMAND_MESH = _pymdlsdk.ELEMENT_TYPE_ON_DEMAND_MESH
r""" #mi::neuraylib::IOn_demand_mesh"""
ELEMENT_TYPE_PROJECTOR = _pymdlsdk.ELEMENT_TYPE_PROJECTOR
r""" #mi::neuraylib::IProjector"""
ELEMENT_TYPE_SECTION_OBJECT = _pymdlsdk.ELEMENT_TYPE_SECTION_OBJECT
r""" #mi::neuraylib::ISection_object"""
ELEMENT_TYPE_PROXY = _pymdlsdk.ELEMENT_TYPE_PROXY
r""" #mi::neuraylib::IProxy"""
ELEMENT_TYPE_FORCE_32_BIT = _pymdlsdk.ELEMENT_TYPE_FORCE_32_BIT
class Interface_declare_IScene_element(_IAttribute_set):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IScene_element_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IScene_element

# Register Interface_declare_IScene_element in _pymdlsdk:
_pymdlsdk.Interface_declare_IScene_element_swigregister(Interface_declare_IScene_element)

def Interface_declare_IScene_element_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IScene_element_compare_iid(iid)

class _IScene_element(Interface_declare_IScene_element):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_element_type(self):
        r""" Indicates the actual scene element represented by interfaces derived from this interface."""
        return _pymdlsdk._IScene_element_get_element_type(self)

# Register _IScene_element in _pymdlsdk:
_pymdlsdk._IScene_element_swigregister(_IScene_element)

class Interface_declare_IDatabase(object):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IDatabase_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IDatabase

# Register Interface_declare_IDatabase in _pymdlsdk:
_pymdlsdk.Interface_declare_IDatabase_swigregister(Interface_declare_IDatabase)

def Interface_declare_IDatabase_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IDatabase_compare_iid(iid)

class _IDatabase(Interface_declare_IDatabase):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_global_scope(self):
        r"""
        Returns the global scope which is the root of a tree of scopes

        :rtype: :py:class:`IScope`
        :return: The global scope which is guaranteed to exist after startup of the
                     system.
        """
        return _pymdlsdk._IDatabase_get_global_scope(self)

    def create_scope(self, parent, privacy_level=0, temp=False):
        r"""
        If not: MDL_SDK_API {
        Creates a new optionally temporary scope at the given privacy level with the
        given parent scope ID.

        Notes: A scope continues to exist if the pointer returned by this method is released. Use
              #remove_scope() to remove a scope.

        :type parent: :py:class:`IScope`
        :param parent:         The parent scope for this scope. If the value is ``NULL`` the created
                                  scope will be a child of the global scope.
        :type privacy_level: mi::Uint8, optional
        :param privacy_level:  The privacy level of the scope. This must be higher than the
                                  privacy level of the parent scope. The privacy level of the global
                                  scope is 0 (and the global scope is the only scope with privacy level
                                  0). The default value of 0 indicates the privacy level of the parent
                                  scope plus 1.
        :type temp: boolean, optional
        :param temp:           A bool indicating if the scope is temporary. If the scope is
                                  temporary, then when the host that created the scope is removed
                                  from the cluster the scope and all data contained in the scope
                                  will be removed. If the scope is not temporary, the default,
                                  then when the creating host is removed from the cluster the
                                  scope and all contained data will remain in the database.
        :rtype: :py:class:`IScope`
        :return: The created scope or ``NULL`` if something went wrong.
        }Else:  { This operation is not supported.
        }
        """
        return _pymdlsdk._IDatabase_create_scope(self, parent, privacy_level, temp)

    def get_scope(self, id):
        r"""
        Looks up and returns a scope with a given ID.

        :type id: string
        :param id:             The ID of the scope as returned by #mi::neuraylib::IScope::get_id().
        :rtype: :py:class:`IScope`
        :return: The found scope or ``NULL`` if no such scope exists.
        """
        return _pymdlsdk._IDatabase_get_scope(self, id)

    def remove_scope(self, id):
        r"""
        If not: MDL_SDK_API {
        Removes a scope with the specified ID.

        Note that scopes are reference counted. The actual removal will not happen before all
        elements referencing the scope have been released, e.g., child scopes, transactions,
        database elements, including handles to the scope itself.

        It is not possible to remove the global scope.

        :type id: string
        :param id:             The ID of the scope as returned by #mi::neuraylib::IScope::get_id().
        :rtype: int
        :return: 0, in case of success, -1 in case of failure.
        }Else:  { This operation is not supported.
        }
        """
        return _pymdlsdk._IDatabase_remove_scope(self, id)

    def lock(self, lock_id):
        r"""
        If not: MDL_SDK_API {
        Acquires a DB lock.

        The method blocks until the requested lock has been obtained. Recursively locking the
        same lock from within the same thread on the same host is supported.

        If the host holding a lock leaves the cluster, the lock is automatically released.

        :type lock_id: int
        :param lock_id:   The lock to acquire.

        Notes: The locking mechanism is kind of a co-operative locking mechanism: The lock does not
              prevent other threads from accessing or editing the DB. It only prevents other threads
              from obtaining the same lock.

        DB locks are not restricted to threads on a single host, they apply to all threads on
              all hosts in the cluster.

        DB locks are an expensive operation and should only be used when absolutely necessary.
        }Else:  { This operation is not supported.
        }
        """
        return _pymdlsdk._IDatabase_lock(self, lock_id)

    def unlock(self, lock_id):
        r"""
        If not: MDL_SDK_API {
        Releases a previously obtained DB lock.

        If the lock has been locked several times from within the same thread on the same host,
        it simply decrements the lock count. If the lock count reaches zero, the lock is released.

        :type lock_id: int
        :param lock_id:   The lock to release.
        :rtype: int
        :return: 0, in case of success, -1 in case of failure, i.e, the lock is not held
                             by this thread on this host
        }Else:  { This operation is not supported.
        }
        """
        return _pymdlsdk._IDatabase_unlock(self, lock_id)

    def create_or_get_named_scope(self, name, parent=None, privacy_level=0):
        r"""
        If not: MDL_SDK_API {
        Creates or retrieves a new named scope at the given privacy level with the given parent
        scope ID.

        :type name: string
        :param name:           A name which can be used to lookup the scope.
                                  If a scope with the same name exists already then it will be returned
                                  if the parent and privacy level are identical. Otherwise
                                  creating the scope will fail.
        :type parent: :py:class:`IScope`, optional
        :param parent:         The parent scope for this scope. If the value is ``NULL`` the created
                                  scope will be a child of the global scope.
        :type privacy_level: mi::Uint8, optional
        :param privacy_level:  The privacy level of the scope. This must be higher than the
                                  privacy level of the parent scope. The privacy level of the global
                                  scope is 0 (and the global scope is the only scope with privacy level
                                  0). The default value of 0 indicates the privacy level of the parent
                                  scope plus 1.
        :rtype: :py:class:`IScope`
        :return: The created scope or ``NULL`` if something went wrong.
        }Else:  { This operation is not supported.
        }
        """
        return _pymdlsdk._IDatabase_create_or_get_named_scope(self, name, parent, privacy_level)

    def get_named_scope(self, name):
        r"""
        If not: MDL_SDK_API {
        Looks up and returns a scope with a given name.

        :type name: string
        :param name:           The name of the scope
        :rtype: :py:class:`IScope`
        :return: The found scope or ``NULL`` if no such scope exists.
        }Else:  { This operation is not supported.
        }
        """
        return _pymdlsdk._IDatabase_get_named_scope(self, name)
    PRIORITY_LOW = _pymdlsdk._IDatabase_PRIORITY_LOW
    r"""
    Low priority for synchronous garbage collection runs. Use this priority if the
    performance of other concurrent DB operations is more important than a fast synchronous
    garbage collection.
    """
    PRIORITY_MEDIUM = _pymdlsdk._IDatabase_PRIORITY_MEDIUM
    r"""
    Medium priority for synchronous garbage collection runs. This priority attempts to
    maintain a balance between the synchronous garbage collection and other concurrent DB
    operations.
    """
    PRIORITY_HIGH = _pymdlsdk._IDatabase_PRIORITY_HIGH
    r"""
    High priority for synchronous garbage collection runs. Other concurrent DB operations
    will experience a large performance drop. Therefore, this priority should not be used
    in multi-user settings.
    """
    PRIORITY_FORCE_32_BIT = _pymdlsdk._IDatabase_PRIORITY_FORCE_32_BIT

    def garbage_collection(self, *args):
        r"""
        Triggers a synchronous garbage collection run.

        The method sweeps through the entire database and removes all database elements which have
        been marked for removal and are no longer referenced. Note that it is not possible to remove
        database elements if there are open transactions in which such an element is still
        referenced.

        To mark an element for removal use If not: DICE_API { #mi::neuraylib::ITransaction::remove().
        }Else: #mi::neuraylib::IDice_transaction::remove() or {
        #mi::neuraylib::IDice_transaction::store_for_reference_counting(). }

        :type priority: int, optional
        :param priority:   The intended priority of the synchronous garbage collection run.
                          If: MDL_SDK_API { The MDL SDK does not support different priorities, and
                          the synchronous garbage collection always runs at highest priority.
                          }
        """
        return _pymdlsdk._IDatabase_garbage_collection(self, *args)

# Register _IDatabase in _pymdlsdk:
_pymdlsdk._IDatabase_swigregister(_IDatabase)

class Interface_declare_IType(object):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IType_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IType

# Register Interface_declare_IType in _pymdlsdk:
_pymdlsdk.Interface_declare_IType_swigregister(Interface_declare_IType)

def Interface_declare_IType_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IType_compare_iid(iid)

class _IType(Interface_declare_IType):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    TK_ALIAS = _pymdlsdk._IType_TK_ALIAS
    r""" An alias for another type, aka typedef. See #mi::neuraylib::IType_alias."""
    TK_BOOL = _pymdlsdk._IType_TK_BOOL
    r""" The ``boolean`` type. See #mi::neuraylib::IType_bool."""
    TK_INT = _pymdlsdk._IType_TK_INT
    r""" The ``integer`` type. See #mi::neuraylib::IType_int."""
    TK_ENUM = _pymdlsdk._IType_TK_ENUM
    r""" An ``enum`` type. See #mi::neuraylib::IType_enum."""
    TK_FLOAT = _pymdlsdk._IType_TK_FLOAT
    r""" The ``float`` type. See #mi::neuraylib::IType_float."""
    TK_DOUBLE = _pymdlsdk._IType_TK_DOUBLE
    r""" The ``double`` type. See #mi::neuraylib::IType_double."""
    TK_STRING = _pymdlsdk._IType_TK_STRING
    r"""  The ``string`` type. See #mi::neuraylib::IType_string."""
    TK_VECTOR = _pymdlsdk._IType_TK_VECTOR
    r""" A vector type. See #mi::neuraylib::IType_vector."""
    TK_MATRIX = _pymdlsdk._IType_TK_MATRIX
    r""" A matrix type. See #mi::neuraylib::IType_matrix."""
    TK_COLOR = _pymdlsdk._IType_TK_COLOR
    r""" The color type. See #mi::neuraylib::IType_color."""
    TK_ARRAY = _pymdlsdk._IType_TK_ARRAY
    r""" An array type. See #mi::neuraylib::IType_array."""
    TK_STRUCT = _pymdlsdk._IType_TK_STRUCT
    r""" A struct type. See #mi::neuraylib::IType_struct."""
    TK_TEXTURE = _pymdlsdk._IType_TK_TEXTURE
    r""" A texture type. See #mi::neuraylib::IType_texture."""
    TK_LIGHT_PROFILE = _pymdlsdk._IType_TK_LIGHT_PROFILE
    r""" The ``light_profile`` type. See #mi::neuraylib::IType_light_profile."""
    TK_BSDF_MEASUREMENT = _pymdlsdk._IType_TK_BSDF_MEASUREMENT
    r""" The ``bsdf_measurement`` type. See #mi::neuraylib::IType_bsdf_measurement."""
    TK_BSDF = _pymdlsdk._IType_TK_BSDF
    r""" The ``bsdf`` type. See #mi::neuraylib::IType_bsdf."""
    TK_HAIR_BSDF = _pymdlsdk._IType_TK_HAIR_BSDF
    r""" The ``hair_bsdf`` type. See #mi::neuraylib::IType_hair_bsdf."""
    TK_EDF = _pymdlsdk._IType_TK_EDF
    r""" The ``edf`` type. See #mi::neuraylib::IType_edf."""
    TK_VDF = _pymdlsdk._IType_TK_VDF
    r""" The ``vdf`` type. See #mi::neuraylib::IType_vdf."""
    TK_FORCE_32_BIT = _pymdlsdk._IType_TK_FORCE_32_BIT
    MK_NONE = _pymdlsdk._IType_MK_NONE
    r""" No type modifier (mutable, auto-typed)."""
    MK_UNIFORM = _pymdlsdk._IType_MK_UNIFORM
    r""" A uniform type."""
    MK_VARYING = _pymdlsdk._IType_MK_VARYING
    r""" A varying type."""
    MK_FORCE_32_BIT = _pymdlsdk._IType_MK_FORCE_32_BIT

    def _get_kind(self):
        r""" Returns the kind of type."""
        return _pymdlsdk._IType__get_kind(self)

    def get_all_type_modifiers(self):
        r"""
        Returns all type modifiers of a type.

        Returns 0 if ``this`` is not an alias. Otherwise, the method follows the chain of aliases by
        calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind() returns
        #TK_ALIAS. The method returns the union of
        #mi::neuraylib::IType_alias::get_type_modifiers() calls on ``this`` and all intermediate
        aliases.
        """
        return _pymdlsdk._IType_get_all_type_modifiers(self)

    def skip_all_type_aliases(self):
        r"""
        Returns the base type.

        Returns ``this`` if ``this`` is not an alias. Otherwise, the method follows the chain of
        aliases by calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind()
        returns #TK_ALIAS. The method returns the first non-alias type.
        """
        return _pymdlsdk._IType_skip_all_type_aliases(self)

# Register _IType in _pymdlsdk:
_pymdlsdk._IType_swigregister(_IType)

class Interface_declare_IType_alias(_IType):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IType_alias_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IType_alias

# Register Interface_declare_IType_alias in _pymdlsdk:
_pymdlsdk.Interface_declare_IType_alias_swigregister(Interface_declare_IType_alias)

def Interface_declare_IType_alias_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IType_alias_compare_iid(iid)

class _IType_alias(Interface_declare_IType_alias):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_aliased_type(self):
        r""" Returns the type aliased by this type."""
        return _pymdlsdk._IType_alias_get_aliased_type(self)

    def get_type_modifiers(self):
        r""" Returns the modifiers of this type."""
        return _pymdlsdk._IType_alias_get_type_modifiers(self)

    def get_symbol(self):
        r""" Returns the qualified name of the type, or ``NULL`` if no such name exists."""
        return _pymdlsdk._IType_alias_get_symbol(self)

# Register _IType_alias in _pymdlsdk:
_pymdlsdk._IType_alias_swigregister(_IType_alias)

class Interface_declare_IType_atomic(_IType):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IType_atomic_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IType_atomic

# Register Interface_declare_IType_atomic in _pymdlsdk:
_pymdlsdk.Interface_declare_IType_atomic_swigregister(Interface_declare_IType_atomic)

def Interface_declare_IType_atomic_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IType_atomic_compare_iid(iid)

class _IType_atomic(Interface_declare_IType_atomic):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

# Register _IType_atomic in _pymdlsdk:
_pymdlsdk._IType_atomic_swigregister(_IType_atomic)

class Interface_declare_IType_bool(_IType_atomic):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IType_bool_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IType_bool

# Register Interface_declare_IType_bool in _pymdlsdk:
_pymdlsdk.Interface_declare_IType_bool_swigregister(Interface_declare_IType_bool)

def Interface_declare_IType_bool_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IType_bool_compare_iid(iid)

class _IType_bool(Interface_declare_IType_bool):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

# Register _IType_bool in _pymdlsdk:
_pymdlsdk._IType_bool_swigregister(_IType_bool)

class Interface_declare_IType_int(_IType_atomic):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IType_int_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IType_int

# Register Interface_declare_IType_int in _pymdlsdk:
_pymdlsdk.Interface_declare_IType_int_swigregister(Interface_declare_IType_int)

def Interface_declare_IType_int_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IType_int_compare_iid(iid)

class _IType_int(Interface_declare_IType_int):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

# Register _IType_int in _pymdlsdk:
_pymdlsdk._IType_int_swigregister(_IType_int)

class Interface_declare_IType_enum(_IType_atomic):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IType_enum_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IType_enum

# Register Interface_declare_IType_enum in _pymdlsdk:
_pymdlsdk.Interface_declare_IType_enum_swigregister(Interface_declare_IType_enum)

def Interface_declare_IType_enum_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IType_enum_compare_iid(iid)

class _IType_enum(Interface_declare_IType_enum):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    EID_USER = _pymdlsdk._IType_enum_EID_USER
    r""" A user-defined enum type."""
    EID_TEX_GAMMA_MODE = _pymdlsdk._IType_enum_EID_TEX_GAMMA_MODE
    r""" The ``"::tex::gamma_mode"`` enum type."""
    EID_INTENSITY_MODE = _pymdlsdk._IType_enum_EID_INTENSITY_MODE
    r""" The ``"::intensity_mode"`` enum type."""
    EID_FORCE_32_BIT = _pymdlsdk._IType_enum_EID_FORCE_32_BIT

    def get_symbol(self):
        r""" Returns the qualified name of this enum type."""
        return _pymdlsdk._IType_enum_get_symbol(self)

    def get_size(self):
        r""" Returns the number of values."""
        return _pymdlsdk._IType_enum_get_size(self)

    def get_value_name(self, index):
        r"""
        Returns the name of a value.

        :type index: int
        :param index:         The index of the value.
        :rtype: string
        :return: The unqualified name of the value, or ``NULL`` if ``index`` is invalid.
        """
        return _pymdlsdk._IType_enum_get_value_name(self, index)

    def get_value_code_with_ret(self, index):
        r"""
        Returns the code of a value.

        :type index: int
        :param index:         The index of the value.
        :type errors: int, out, optional
        :param errors:
                                 -  0: Success.
                                 - -1: ``index`` is invalid.
        :rtype: int
        :return: The code of the value, or 0 in case of errors.
        """
        return _pymdlsdk._IType_enum_get_value_code_with_ret(self, index)

    def get_value_code(self, index):
        r"""
        Returns the code of a value.

        :type index: int
        :param index:         The index of the value.
        :param errors:
                                 -  0: Success.
                                 - -1: ``index`` is invalid.
        :rtype: int
        :return: The code of the value, or 0 in case of errors.
        """
        return _pymdlsdk._IType_enum_get_value_code(self, index)

    def find_value(self, *args):
        r"""
        *Overload 1:*
        Returns the index of a value in linear time.

        :type name: string
        :param name:          The unqualified name of the value.
        :rtype: int
        :return: The index of the value, or -1 if there is no such value.

        |

        *Overload 2:*
        Returns the index of a value in linear time.

        :type code: int
        :param code:          The code of the value.
        :rtype: int
        :return: The index of the value, or -1 if there is no such value.
        """
        return _pymdlsdk._IType_enum_find_value(self, *args)

    def get_predefined_id(self):
        r""" If this enum is a predefined one, return its ID, else EID_USER."""
        return _pymdlsdk._IType_enum_get_predefined_id(self)

    def get_annotations(self):
        r"""
        Returns the annotations of the enum type.

        :rtype: :py:class:`IAnnotation_block`
        :return: The annotations of the enum type, or ``NULL`` if there are no
                                 annotations for the enum type.
        """
        return _pymdlsdk._IType_enum_get_annotations(self)

    def get_value_annotations(self, index):
        r"""
        Returns the annotations of a value.

        :type index: int
        :param index:         The index of the value.
        :rtype: :py:class:`IAnnotation_block`
        :return: The annotation of that value, or ``NULL`` if ``index`` is out of bounds,
                                 or there are no annotations for that value.
        """
        return _pymdlsdk._IType_enum_get_value_annotations(self, index)

# Register _IType_enum in _pymdlsdk:
_pymdlsdk._IType_enum_swigregister(_IType_enum)

class Interface_declare_IType_float(_IType_atomic):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IType_float_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IType_float

# Register Interface_declare_IType_float in _pymdlsdk:
_pymdlsdk.Interface_declare_IType_float_swigregister(Interface_declare_IType_float)

def Interface_declare_IType_float_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IType_float_compare_iid(iid)

class _IType_float(Interface_declare_IType_float):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

# Register _IType_float in _pymdlsdk:
_pymdlsdk._IType_float_swigregister(_IType_float)

class Interface_declare_IType_double(_IType_atomic):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IType_double_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IType_double

# Register Interface_declare_IType_double in _pymdlsdk:
_pymdlsdk.Interface_declare_IType_double_swigregister(Interface_declare_IType_double)

def Interface_declare_IType_double_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IType_double_compare_iid(iid)

class _IType_double(Interface_declare_IType_double):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

# Register _IType_double in _pymdlsdk:
_pymdlsdk._IType_double_swigregister(_IType_double)

class Interface_declare_IType_string(_IType_atomic):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IType_string_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IType_string

# Register Interface_declare_IType_string in _pymdlsdk:
_pymdlsdk.Interface_declare_IType_string_swigregister(Interface_declare_IType_string)

def Interface_declare_IType_string_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IType_string_compare_iid(iid)

class _IType_string(Interface_declare_IType_string):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

# Register _IType_string in _pymdlsdk:
_pymdlsdk._IType_string_swigregister(_IType_string)

class Interface_declare_IType_compound(_IType):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IType_compound_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IType_compound

# Register Interface_declare_IType_compound in _pymdlsdk:
_pymdlsdk.Interface_declare_IType_compound_swigregister(Interface_declare_IType_compound)

def Interface_declare_IType_compound_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IType_compound_compare_iid(iid)

class _IType_compound(Interface_declare_IType_compound):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_component_type(self, index):
        r""" Returns the component type at ``index``."""
        return _pymdlsdk._IType_compound_get_component_type(self, index)

    def get_size(self):
        r""" Returns the number of components."""
        return _pymdlsdk._IType_compound_get_size(self)

# Register _IType_compound in _pymdlsdk:
_pymdlsdk._IType_compound_swigregister(_IType_compound)

class Interface_declare_IType_vector(_IType_compound):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IType_vector_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IType_vector

# Register Interface_declare_IType_vector in _pymdlsdk:
_pymdlsdk.Interface_declare_IType_vector_swigregister(Interface_declare_IType_vector)

def Interface_declare_IType_vector_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IType_vector_compare_iid(iid)

class _IType_vector(Interface_declare_IType_vector):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_element_type(self):
        r"""
        Returns the type of the vector elements.

        The element type of vectors is either #mi::neuraylib::IType_bool, #mi::neuraylib::IType_int,
        #mi::neuraylib::IType_float, or #mi::neuraylib::IType_double. If the vector is a column
        vector of a matrix, then the element type is either #mi::neuraylib::IType_float or
        #mi::neuraylib::IType_double.
        """
        return _pymdlsdk._IType_vector_get_element_type(self)

# Register _IType_vector in _pymdlsdk:
_pymdlsdk._IType_vector_swigregister(_IType_vector)

class Interface_declare_IType_matrix(_IType_compound):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IType_matrix_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IType_matrix

# Register Interface_declare_IType_matrix in _pymdlsdk:
_pymdlsdk.Interface_declare_IType_matrix_swigregister(Interface_declare_IType_matrix)

def Interface_declare_IType_matrix_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IType_matrix_compare_iid(iid)

class _IType_matrix(Interface_declare_IType_matrix):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_element_type(self):
        r""" Returns the type of the matrix elements, i.e., the type of a column vector."""
        return _pymdlsdk._IType_matrix_get_element_type(self)

# Register _IType_matrix in _pymdlsdk:
_pymdlsdk._IType_matrix_swigregister(_IType_matrix)

class Interface_declare_IType_color(_IType_compound):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IType_color_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IType_color

# Register Interface_declare_IType_color in _pymdlsdk:
_pymdlsdk.Interface_declare_IType_color_swigregister(Interface_declare_IType_color)

def Interface_declare_IType_color_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IType_color_compare_iid(iid)

class _IType_color(Interface_declare_IType_color):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

# Register _IType_color in _pymdlsdk:
_pymdlsdk._IType_color_swigregister(_IType_color)

class Interface_declare_IType_array(_IType_compound):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IType_array_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IType_array

# Register Interface_declare_IType_array in _pymdlsdk:
_pymdlsdk.Interface_declare_IType_array_swigregister(Interface_declare_IType_array)

def Interface_declare_IType_array_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IType_array_compare_iid(iid)

class _IType_array(Interface_declare_IType_array):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_element_type(self):
        r""" Returns the type of the array elements."""
        return _pymdlsdk._IType_array_get_element_type(self)

    def is_immediate_sized(self):
        r""" Indicates whether the array is immediate-sized or deferred-sized."""
        return _pymdlsdk._IType_array_is_immediate_sized(self)

    def get_size(self):
        r""" Returns the size of the array in case of immediate-sized arrays, and -1 otherwise."""
        return _pymdlsdk._IType_array_get_size(self)

    def get_deferred_size(self):
        r"""
        Returns the abstract size of the array in case of deferred-sized arrays, and ``NULL``
        otherwise.

        Note that the empty string is a valid return value for deferred-sized arrays.
        """
        return _pymdlsdk._IType_array_get_deferred_size(self)

# Register _IType_array in _pymdlsdk:
_pymdlsdk._IType_array_swigregister(_IType_array)

class Interface_declare_IType_struct(_IType_compound):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IType_struct_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IType_struct

# Register Interface_declare_IType_struct in _pymdlsdk:
_pymdlsdk.Interface_declare_IType_struct_swigregister(Interface_declare_IType_struct)

def Interface_declare_IType_struct_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IType_struct_compare_iid(iid)

class _IType_struct(Interface_declare_IType_struct):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    SID_USER = _pymdlsdk._IType_struct_SID_USER
    r""" A user-defined struct type."""
    SID_MATERIAL_EMISSION = _pymdlsdk._IType_struct_SID_MATERIAL_EMISSION
    r""" The ``"::material_emission"`` struct type."""
    SID_MATERIAL_SURFACE = _pymdlsdk._IType_struct_SID_MATERIAL_SURFACE
    r""" The ``"::material_surface"`` struct type."""
    SID_MATERIAL_VOLUME = _pymdlsdk._IType_struct_SID_MATERIAL_VOLUME
    r""" The ``"::material_volume"`` struct type."""
    SID_MATERIAL_GEOMETRY = _pymdlsdk._IType_struct_SID_MATERIAL_GEOMETRY
    r""" The ``"::material_geometry"`` struct type."""
    SID_MATERIAL = _pymdlsdk._IType_struct_SID_MATERIAL
    r""" The ``"::material"`` struct type."""
    SID_FORCE_32_BIT = _pymdlsdk._IType_struct_SID_FORCE_32_BIT

    def get_symbol(self):
        r""" Returns the qualified name of the struct type."""
        return _pymdlsdk._IType_struct_get_symbol(self)

    def get_field_type(self, index):
        r"""
        Returns a field type.

        :type index: int
        :param index:    The index of the field.
        :rtype: :py:class:`IType`
        :return: The type of the field.
        """
        return _pymdlsdk._IType_struct_get_field_type(self, index)

    def get_field_name(self, index):
        r"""
        Returns a field name.

        :type index: int
        :param index:    The index of the field.
        :rtype: string
        :return: The unqualified name of the field.
        """
        return _pymdlsdk._IType_struct_get_field_name(self, index)

    def find_field(self, name):
        r"""
        Returns the index of a field in linear time.

        :type name: string
        :param name:     The unqualified name of the field.
        :rtype: int
        :return: The index of the field, or -1 if there is no such field.
        """
        return _pymdlsdk._IType_struct_find_field(self, name)

    def get_predefined_id(self):
        r""" If this struct is a predefined one, return its ID, else SID_USER."""
        return _pymdlsdk._IType_struct_get_predefined_id(self)

    def get_annotations(self):
        r"""
        Returns the annotations of the struct type.

        :rtype: :py:class:`IAnnotation_block`
        :return: The annotations of the struct type, or ``NULL`` if there are no
                                 annotations for the struct type.
        """
        return _pymdlsdk._IType_struct_get_annotations(self)

    def get_field_annotations(self, index):
        r"""
        Returns the annotations of a field.

        :type index: int
        :param index:         The index of the field.
        :rtype: :py:class:`IAnnotation_block`
        :return: The annotation of that field, or ``NULL`` if ``index`` is out of bounds,
                                 or there are no annotations for that field.
        """
        return _pymdlsdk._IType_struct_get_field_annotations(self, index)

# Register _IType_struct in _pymdlsdk:
_pymdlsdk._IType_struct_swigregister(_IType_struct)

class Interface_declare_IType_reference(_IType):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IType_reference_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IType_reference

# Register Interface_declare_IType_reference in _pymdlsdk:
_pymdlsdk.Interface_declare_IType_reference_swigregister(Interface_declare_IType_reference)

def Interface_declare_IType_reference_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IType_reference_compare_iid(iid)

class _IType_reference(Interface_declare_IType_reference):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

# Register _IType_reference in _pymdlsdk:
_pymdlsdk._IType_reference_swigregister(_IType_reference)

class Interface_declare_IType_resource(_IType_reference):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IType_resource_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IType_resource

# Register Interface_declare_IType_resource in _pymdlsdk:
_pymdlsdk.Interface_declare_IType_resource_swigregister(Interface_declare_IType_resource)

def Interface_declare_IType_resource_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IType_resource_compare_iid(iid)

class _IType_resource(Interface_declare_IType_resource):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

# Register _IType_resource in _pymdlsdk:
_pymdlsdk._IType_resource_swigregister(_IType_resource)

class Interface_declare_IType_texture(_IType_resource):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IType_texture_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IType_texture

# Register Interface_declare_IType_texture in _pymdlsdk:
_pymdlsdk.Interface_declare_IType_texture_swigregister(Interface_declare_IType_texture)

def Interface_declare_IType_texture_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IType_texture_compare_iid(iid)

class _IType_texture(Interface_declare_IType_texture):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    TS_2D = _pymdlsdk._IType_texture_TS_2D
    r""" Two-dimensional texture."""
    TS_3D = _pymdlsdk._IType_texture_TS_3D
    r""" Three-dimensional texture."""
    TS_CUBE = _pymdlsdk._IType_texture_TS_CUBE
    r""" Cube map texture."""
    TS_PTEX = _pymdlsdk._IType_texture_TS_PTEX
    r""" PTEX texture."""
    TS_BSDF_DATA = _pymdlsdk._IType_texture_TS_BSDF_DATA
    r""" Three-dimensional texture representing"""
    TS_FORCE_32_BIT = _pymdlsdk._IType_texture_TS_FORCE_32_BIT
    r"""  a BSDF data table."""

    def get_shape(self):
        r""" Returns the texture type."""
        return _pymdlsdk._IType_texture_get_shape(self)

# Register _IType_texture in _pymdlsdk:
_pymdlsdk._IType_texture_swigregister(_IType_texture)

class Interface_declare_IType_light_profile(_IType_resource):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IType_light_profile_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IType_light_profile

# Register Interface_declare_IType_light_profile in _pymdlsdk:
_pymdlsdk.Interface_declare_IType_light_profile_swigregister(Interface_declare_IType_light_profile)

def Interface_declare_IType_light_profile_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IType_light_profile_compare_iid(iid)

class _IType_light_profile(Interface_declare_IType_light_profile):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

# Register _IType_light_profile in _pymdlsdk:
_pymdlsdk._IType_light_profile_swigregister(_IType_light_profile)

class Interface_declare_IType_bsdf_measurement(_IType_resource):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IType_bsdf_measurement_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IType_bsdf_measurement

# Register Interface_declare_IType_bsdf_measurement in _pymdlsdk:
_pymdlsdk.Interface_declare_IType_bsdf_measurement_swigregister(Interface_declare_IType_bsdf_measurement)

def Interface_declare_IType_bsdf_measurement_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IType_bsdf_measurement_compare_iid(iid)

class _IType_bsdf_measurement(Interface_declare_IType_bsdf_measurement):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

# Register _IType_bsdf_measurement in _pymdlsdk:
_pymdlsdk._IType_bsdf_measurement_swigregister(_IType_bsdf_measurement)

class Interface_declare_IType_df(_IType_reference):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IType_df_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IType_df

# Register Interface_declare_IType_df in _pymdlsdk:
_pymdlsdk.Interface_declare_IType_df_swigregister(Interface_declare_IType_df)

def Interface_declare_IType_df_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IType_df_compare_iid(iid)

class _IType_df(Interface_declare_IType_df):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

# Register _IType_df in _pymdlsdk:
_pymdlsdk._IType_df_swigregister(_IType_df)

class Interface_declare_IType_bsdf(_IType_df):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IType_bsdf_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IType_bsdf

# Register Interface_declare_IType_bsdf in _pymdlsdk:
_pymdlsdk.Interface_declare_IType_bsdf_swigregister(Interface_declare_IType_bsdf)

def Interface_declare_IType_bsdf_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IType_bsdf_compare_iid(iid)

class _IType_bsdf(Interface_declare_IType_bsdf):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

# Register _IType_bsdf in _pymdlsdk:
_pymdlsdk._IType_bsdf_swigregister(_IType_bsdf)

class Interface_declare_IType_hair_bsdf(_IType_df):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IType_hair_bsdf_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IType_hair_bsdf

# Register Interface_declare_IType_hair_bsdf in _pymdlsdk:
_pymdlsdk.Interface_declare_IType_hair_bsdf_swigregister(Interface_declare_IType_hair_bsdf)

def Interface_declare_IType_hair_bsdf_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IType_hair_bsdf_compare_iid(iid)

class _IType_hair_bsdf(Interface_declare_IType_hair_bsdf):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

# Register _IType_hair_bsdf in _pymdlsdk:
_pymdlsdk._IType_hair_bsdf_swigregister(_IType_hair_bsdf)

class Interface_declare_IType_edf(_IType_df):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IType_edf_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IType_edf

# Register Interface_declare_IType_edf in _pymdlsdk:
_pymdlsdk.Interface_declare_IType_edf_swigregister(Interface_declare_IType_edf)

def Interface_declare_IType_edf_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IType_edf_compare_iid(iid)

class _IType_edf(Interface_declare_IType_edf):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

# Register _IType_edf in _pymdlsdk:
_pymdlsdk._IType_edf_swigregister(_IType_edf)

class Interface_declare_IType_vdf(_IType_df):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IType_vdf_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IType_vdf

# Register Interface_declare_IType_vdf in _pymdlsdk:
_pymdlsdk.Interface_declare_IType_vdf_swigregister(Interface_declare_IType_vdf)

def Interface_declare_IType_vdf_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IType_vdf_compare_iid(iid)

class _IType_vdf(Interface_declare_IType_vdf):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

# Register _IType_vdf in _pymdlsdk:
_pymdlsdk._IType_vdf_swigregister(_IType_vdf)

class Interface_declare_IType_list(object):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IType_list_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IType_list

# Register Interface_declare_IType_list in _pymdlsdk:
_pymdlsdk.Interface_declare_IType_list_swigregister(Interface_declare_IType_list)

def Interface_declare_IType_list_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IType_list_compare_iid(iid)

class _IType_list(Interface_declare_IType_list):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_size(self):
        r""" Returns the number of elements."""
        return _pymdlsdk._IType_list_get_size(self)

    def get_index(self, name):
        r""" Returns the index for the given name, or -1 if there is no such type."""
        return _pymdlsdk._IType_list_get_index(self, name)

    def get_name(self, index):
        r""" Returns the name for the given index, or ``NULL`` if there is no such type."""
        return _pymdlsdk._IType_list_get_name(self, index)

    def get_type(self, *args):
        r"""
        *Overload 1:*
        Returns the type for ``index``, or ``NULL`` if there is no such type.

        |

        *Overload 2:*
        Returns the type for ``name``, or ``NULL`` if there is no such type.
        """
        return _pymdlsdk._IType_list_get_type(self, *args)

    def set_type(self, *args):
        r"""
        *Overload 1:*
        Sets a type at a given index.

        :rtype: int
        :return: -  0: Success.
                      - -1: Invalid parameters (``NULL`` pointer).
                      - -2: ``index`` is out of bounds.

        |

        *Overload 2:*
        Sets a type identified by name.

        :rtype: int
        :return: -  0: Success.
                      - -1: Invalid parameters (``NULL`` pointer).
                      - -2: There is no type mapped to ``name`` in the list.
        """
        return _pymdlsdk._IType_list_set_type(self, *args)

    def add_type(self, name, type):
        r"""
        Adds a type at the end of the list.

        :rtype: int
        :return: -  0: Success.
                      - -1: Invalid parameters (``NULL`` pointer).
                      - -2: There is already a type mapped to ``name`` in the list.
        """
        return _pymdlsdk._IType_list_add_type(self, name, type)

# Register _IType_list in _pymdlsdk:
_pymdlsdk._IType_list_swigregister(_IType_list)

class Interface_declare_IType_factory(object):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IType_factory_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IType_factory

# Register Interface_declare_IType_factory in _pymdlsdk:
_pymdlsdk.Interface_declare_IType_factory_swigregister(Interface_declare_IType_factory)

def Interface_declare_IType_factory_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IType_factory_compare_iid(iid)

class _IType_factory(Interface_declare_IType_factory):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def create_alias(self, type, modifiers, symbol):
        r""" Creates a new instance of the type alias."""
        return _pymdlsdk._IType_factory_create_alias(self, type, modifiers, symbol)

    def create_bool(self):
        r""" Creates a new instance of the type boolean."""
        return _pymdlsdk._IType_factory_create_bool(self)

    def create_int(self):
        r""" Creates a new instance of the type int."""
        return _pymdlsdk._IType_factory_create_int(self)

    def create_enum(self, symbol):
        r""" Returns a registered enum type, or ``NULL`` if ``symbol`` is invalid or unknown."""
        return _pymdlsdk._IType_factory_create_enum(self, symbol)

    def create_float(self):
        r""" Creates a new instance of the float type."""
        return _pymdlsdk._IType_factory_create_float(self)

    def create_double(self):
        r""" Creates a new instance of the double type."""
        return _pymdlsdk._IType_factory_create_double(self)

    def create_string(self):
        r""" Creates a new instance of the string type."""
        return _pymdlsdk._IType_factory_create_string(self)

    def create_vector(self, element_type, size):
        r"""
        Creates a new instance of a vector type.

        :type element_type: :py:class:`IType_atomic`
        :param element_type:   The element type needs to be either #mi::neuraylib::IType_bool,
                                  #mi::neuraylib::IType_int, #mi::neuraylib::IType_float, or
                                  #mi::neuraylib::IType_double.
        :type size: int
        :param size:           The number of elements, either 2, 3, or 4.
        :rtype: :py:class:`IType_vector`
        :return: The corresponding vector type, or ``NULL`` in case of errors.
        """
        return _pymdlsdk._IType_factory_create_vector(self, element_type, size)

    def create_matrix(self, column_type, columns):
        r"""
        Creates a new instance of a matrix type.

        :type column_type: :py:class:`IType_vector`
        :param column_type:    The column type needs to be a vector of either
                                  #mi::neuraylib::IType_float or #mi::neuraylib::IType_double.
        :type columns: int
        :param columns:        The number of columns, either 2, 3, or 4.
        :rtype: :py:class:`IType_matrix`
        :return: The corresponding matrix type, or ``NULL`` in case of errors.
        """
        return _pymdlsdk._IType_factory_create_matrix(self, column_type, columns)

    def create_color(self):
        r""" Creates a new instance of the type color."""
        return _pymdlsdk._IType_factory_create_color(self)

    def create_immediate_sized_array(self, element_type, size):
        r""" Creates a new instance of an immediate-sized array type."""
        return _pymdlsdk._IType_factory_create_immediate_sized_array(self, element_type, size)

    def create_deferred_sized_array(self, element_type, size):
        r""" Creates a new instance of a deferred-sized array type."""
        return _pymdlsdk._IType_factory_create_deferred_sized_array(self, element_type, size)

    def create_struct(self, symbol):
        r""" Returns a registered struct type, or ``NULL`` if ``symbol`` is invalid or unknown."""
        return _pymdlsdk._IType_factory_create_struct(self, symbol)

    def create_texture(self, shape):
        r""" Creates a new instance of the type texture."""
        return _pymdlsdk._IType_factory_create_texture(self, shape)

    def create_light_profile(self):
        r""" Creates a new instance of the type light_profile."""
        return _pymdlsdk._IType_factory_create_light_profile(self)

    def create_bsdf_measurement(self):
        r""" Creates a new instance of the type bsdf_measurement."""
        return _pymdlsdk._IType_factory_create_bsdf_measurement(self)

    def create_bsdf(self):
        r""" Creates a new instance of the type bsdf."""
        return _pymdlsdk._IType_factory_create_bsdf(self)

    def create_hair_bsdf(self):
        r""" Creates a new instance of the type hair_bsdf."""
        return _pymdlsdk._IType_factory_create_hair_bsdf(self)

    def create_edf(self):
        r""" Creates a new instance of the type edf."""
        return _pymdlsdk._IType_factory_create_edf(self)

    def create_vdf(self):
        r""" Creates a new instance of the type vdf."""
        return _pymdlsdk._IType_factory_create_vdf(self)

    def create_type_list(self):
        r""" Creates a new type map."""
        return _pymdlsdk._IType_factory_create_type_list(self)

    def get_predefined_enum(self, id):
        r""" Returns a registered enum type, or ``NULL`` if ``id`` is unknown."""
        return _pymdlsdk._IType_factory_get_predefined_enum(self, id)

    def get_predefined_struct(self, id):
        r""" Returns a registered struct type, or ``NULL`` if ``id`` is unknown."""
        return _pymdlsdk._IType_factory_get_predefined_struct(self, id)

    def clone(self, type_list):
        r""" Clones the given type list."""
        return _pymdlsdk._IType_factory_clone(self, type_list)

    def compare(self, *args):
        r"""
        *Overload 1:*
        Compares two instances of #mi::neuraylib::IType.

        The comparison operator for instances of #mi::neuraylib::IType is defined as follows:
        - If ``lhs`` or ``rhs`` is ``NULL``, the result is the lexicographic comparison of
          the pointer addresses themselves.
        - Otherwise, the kind of the types are compared. If they are different, the result is
          determined by ``operator``< on the #mi::neuraylib::IType::Kind values.
        - Finally, specific types are compared as follows:
          - #mi::neuraylib::IType_enum and #mi::neuraylib::IType_struct: The result is determined by
            ``strcmp()`` on the corresponding symbol names.
          - #mi::neuraylib::IType_vector, #mi::neuraylib::IType_matrix, #mi::neuraylib::IType_array:
            If the element types are different, they determine the result of the comparison. If the
            element types are identical the number of compound elements determines the result.
          - #mi::neuraylib::IType_alias: If the modifiers are different, they determine the result
            of the comparison. If the modifiers are identical, the aliased types determine the
            result.
          - #mi::neuraylib::IType_texture: The result is determined by a comparison of the
            corresponding shapes.
          - All other pairs of (the same kind of) types are considered equal.

        :type lhs: :py:class:`IType`
        :param lhs:   The left-hand side operand for the comparison.
        :type rhs: :py:class:`IType`
        :param rhs:   The right-hand side operand for the comparison.
        :rtype: int
        :return: -1 if ``lhs`` < ``rhs``, 0 if ``lhs`` == ``rhs``, and +1 if ``lhs`` > ``rhs``.

        |

        *Overload 2:*
        Compares two instances of #mi::neuraylib::IType_list.

        The comparison operator for instances of #mi::neuraylib::IType_list is defined as follows:
        - If ``lhs`` or ``rhs`` is ``NULL``, the result is the lexicographic comparison of
          the pointer addresses themselves.
        - Next, the list sizes are compared using ``operator``<().
        - Next, the lists are traversed by increasing index and the names are compared using
          ``strcmp()``.
        - Finally, the list elements are enumerated by increasing index and the types are compared.

        :type lhs: :py:class:`IType_list`
        :param lhs:   The left-hand side operand for the comparison.
        :type rhs: :py:class:`IType_list`
        :param rhs:   The right-hand side operand for the comparison.
        :rtype: int
        :return: -1 if ``lhs`` < ``rhs``, 0 if ``lhs`` == ``rhs``, and +1 if ``lhs`` > ``rhs``.
        """
        return _pymdlsdk._IType_factory_compare(self, *args)

    def is_compatible(self, src, dst):
        r"""
        Checks, if two instances of #mi::neuraylib::IType are compatible, meaning that ``src``
        can be casted to ``dst``.

        ``src`` is compatible with and therefore can be casted to ``dst``, if
        - ``src`` and ``dst`` are of identical type (see #mi::neuraylib::IType_factory::compare()).
        - ``src`` and ``dst`` are of type #mi::neuraylib::IType_struct, have the same number of
          fields and all fields are compatible.
        - ``src`` and ``dst`` are of type #mi::neuraylib::IType_enum and both enumeration types have
          the same set of numerical enumeration values. The name of the enumeration values, their
          order, or whether multiple enumeration value names share the same numerical value
          do not matter.
        - ``src`` and ``dst`` are of type #mi::neuraylib::IType_array, both arrays have the same size
          and their element types are compatible.

        :type src: :py:class:`IType`
        :param src: The source type.
        :type dst: :py:class:`IType`
        :param dst: the target type to which src is intended to be compatible.
        :rtype: int
        :return: 
                      -  0 if ``src`` can be casted to ``dst``, but ``src`` and ``dst`` are not of identical
                           type.
                      -  1 if ``src`` and ``dst`` are of identical type.
                      - -1 if ``src`` cannot be casted to ``dst``.
        """
        return _pymdlsdk._IType_factory_is_compatible(self, src, dst)

    def dump(self, *args):
        r"""
        *Overload 1:*
         Returns a textual representation of a type.

         The representation of the type might contain line breaks, for example for structures and
         enums. Subsequent lines have a suitable indentation. The assumed indentation level of the
         first line is specified by ``depth``.

         Notes: The exact format of the textual representation is unspecified and might change in
               future releases. The textual representation is primarily meant as a debugging aid. Do
               *not* base application logic on it.

        |

        *Overload 2:*
         Returns a textual representation of a type list.

         The representation of the type list will contain line breaks. Subsequent lines have a
         suitable indentation. The assumed indentation level of the first line is specified by
        ``depth``.

         Notes: The exact format of the textual representation is unspecified and might change in
               future releases. The textual representation is primarily meant as a debugging aid. Do
               *not* base application logic on it.

        |

        *Overload 3:*
         Returns a textual representation of a type list.

         The representation of the type list will contain line breaks. Subsequent lines have a
         suitable indentation. The assumed indentation level of the first line is specified by
        ``depth``.

         Notes: The exact format of the textual representation is unspecified and might change in
               future releases. The textual representation is primarily meant as a debugging aid. Do
               *not* base application logic on it.
        """
        return _pymdlsdk._IType_factory_dump(self, *args)

# Register _IType_factory in _pymdlsdk:
_pymdlsdk._IType_factory_swigregister(_IType_factory)

class Interface_declare_IValue(object):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IValue_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IValue

# Register Interface_declare_IValue in _pymdlsdk:
_pymdlsdk.Interface_declare_IValue_swigregister(Interface_declare_IValue)

def Interface_declare_IValue_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IValue_compare_iid(iid)

class _IValue(Interface_declare_IValue):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    VK_BOOL = _pymdlsdk._IValue_VK_BOOL
    r""" A boolean value. See #mi::neuraylib::IValue_bool."""
    VK_INT = _pymdlsdk._IValue_VK_INT
    r""" An integer value. See #mi::neuraylib::IValue_int."""
    VK_ENUM = _pymdlsdk._IValue_VK_ENUM
    r""" An enum value. See #mi::neuraylib::IValue_enum."""
    VK_FLOAT = _pymdlsdk._IValue_VK_FLOAT
    r""" A float value. See #mi::neuraylib::IValue_float."""
    VK_DOUBLE = _pymdlsdk._IValue_VK_DOUBLE
    r""" A double value. See #mi::neuraylib::IValue_double."""
    VK_STRING = _pymdlsdk._IValue_VK_STRING
    r""" A string value. See #mi::neuraylib::IValue_string."""
    VK_VECTOR = _pymdlsdk._IValue_VK_VECTOR
    r""" A vector value. See #mi::neuraylib::IValue_vector."""
    VK_MATRIX = _pymdlsdk._IValue_VK_MATRIX
    r""" A matrix value. See #mi::neuraylib::IValue_matrix."""
    VK_COLOR = _pymdlsdk._IValue_VK_COLOR
    r""" A color value. See #mi::neuraylib::IValue_color."""
    VK_ARRAY = _pymdlsdk._IValue_VK_ARRAY
    r""" An array value. See #mi::neuraylib::IValue_array."""
    VK_STRUCT = _pymdlsdk._IValue_VK_STRUCT
    r""" A struct value. See #mi::neuraylib::IValue_struct."""
    VK_INVALID_DF = _pymdlsdk._IValue_VK_INVALID_DF
    r""" An invalid distribution function value. See #mi::neuraylib::IValue_invalid_df."""
    VK_TEXTURE = _pymdlsdk._IValue_VK_TEXTURE
    r""" A texture value. See #mi::neuraylib::IValue_texture."""
    VK_LIGHT_PROFILE = _pymdlsdk._IValue_VK_LIGHT_PROFILE
    r""" A light_profile value. See #mi::neuraylib::IValue_light_profile."""
    VK_BSDF_MEASUREMENT = _pymdlsdk._IValue_VK_BSDF_MEASUREMENT
    r""" A bsdf_measurement value. See #mi::neuraylib::IValue_bsdf_measurement."""
    VK_FORCE_32_BIT = _pymdlsdk._IValue_VK_FORCE_32_BIT

    def _get_kind(self):
        r""" Returns the kind of the value."""
        return _pymdlsdk._IValue__get_kind(self)

    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk._IValue_get_type(self)

# Register _IValue in _pymdlsdk:
_pymdlsdk._IValue_swigregister(_IValue)

class Interface_declare_IValue_atomic(_IValue):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IValue_atomic_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IValue_atomic

# Register Interface_declare_IValue_atomic in _pymdlsdk:
_pymdlsdk.Interface_declare_IValue_atomic_swigregister(Interface_declare_IValue_atomic)

def Interface_declare_IValue_atomic_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IValue_atomic_compare_iid(iid)

class _IValue_atomic(Interface_declare_IValue_atomic):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk._IValue_atomic_get_type(self)

# Register _IValue_atomic in _pymdlsdk:
_pymdlsdk._IValue_atomic_swigregister(_IValue_atomic)

class Interface_declare_IValue_bool(_IValue_atomic):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IValue_bool_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IValue_bool

# Register Interface_declare_IValue_bool in _pymdlsdk:
_pymdlsdk.Interface_declare_IValue_bool_swigregister(Interface_declare_IValue_bool)

def Interface_declare_IValue_bool_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IValue_bool_compare_iid(iid)

class _IValue_bool(Interface_declare_IValue_bool):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk._IValue_bool_get_type(self)

    def get_value(self):
        r""" Returns the value."""
        return _pymdlsdk._IValue_bool_get_value(self)

    def set_value(self, value):
        r""" Sets the value."""
        return _pymdlsdk._IValue_bool_set_value(self, value)

# Register _IValue_bool in _pymdlsdk:
_pymdlsdk._IValue_bool_swigregister(_IValue_bool)

class Interface_declare_IValue_int(_IValue_atomic):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IValue_int_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IValue_int

# Register Interface_declare_IValue_int in _pymdlsdk:
_pymdlsdk.Interface_declare_IValue_int_swigregister(Interface_declare_IValue_int)

def Interface_declare_IValue_int_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IValue_int_compare_iid(iid)

class _IValue_int(Interface_declare_IValue_int):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk._IValue_int_get_type(self)

    def get_value(self):
        r""" Returns the value."""
        return _pymdlsdk._IValue_int_get_value(self)

    def set_value(self, value):
        r""" Sets the value."""
        return _pymdlsdk._IValue_int_set_value(self, value)

# Register _IValue_int in _pymdlsdk:
_pymdlsdk._IValue_int_swigregister(_IValue_int)

class Interface_declare_IValue_enum(_IValue_atomic):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IValue_enum_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IValue_enum

# Register Interface_declare_IValue_enum in _pymdlsdk:
_pymdlsdk.Interface_declare_IValue_enum_swigregister(Interface_declare_IValue_enum)

def Interface_declare_IValue_enum_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IValue_enum_compare_iid(iid)

class _IValue_enum(Interface_declare_IValue_enum):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk._IValue_enum_get_type(self)

    def get_value(self):
        r""" Returns the (integer) value of this enum value."""
        return _pymdlsdk._IValue_enum_get_value(self)

    def get_index(self):
        r""" Returns the index of this enum value."""
        return _pymdlsdk._IValue_enum_get_index(self)

    def set_value(self, value):
        r"""
        Sets the enum value by integer in linear time.

        If there are multiple indices with the same value the one with the smallest index is chosen.

        :rtype: int
        :return: 0 in case of success, -1 if ``value`` is not valid for this enum type
        """
        return _pymdlsdk._IValue_enum_set_value(self, value)

    def set_index(self, index):
        r"""
        Sets the enum value by index.

        :rtype: int
        :return: 0 in case of success, -1 if ``index`` is not valid for this enum type
        """
        return _pymdlsdk._IValue_enum_set_index(self, index)

    def get_name(self):
        r""" Returns the string representation of this enum value."""
        return _pymdlsdk._IValue_enum_get_name(self)

    def set_name(self, name):
        r"""
        Sets the enum value by string representation in linear time.

        :rtype: int
        :return: 0 in case of success, -1 if ``name`` is not valid for this enum type
        """
        return _pymdlsdk._IValue_enum_set_name(self, name)

# Register _IValue_enum in _pymdlsdk:
_pymdlsdk._IValue_enum_swigregister(_IValue_enum)

class Interface_declare_IValue_float(_IValue_atomic):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IValue_float_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IValue_float

# Register Interface_declare_IValue_float in _pymdlsdk:
_pymdlsdk.Interface_declare_IValue_float_swigregister(Interface_declare_IValue_float)

def Interface_declare_IValue_float_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IValue_float_compare_iid(iid)

class _IValue_float(Interface_declare_IValue_float):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk._IValue_float_get_type(self)

    def get_value(self):
        r""" Returns the value."""
        return _pymdlsdk._IValue_float_get_value(self)

    def set_value(self, value):
        r""" Sets the value."""
        return _pymdlsdk._IValue_float_set_value(self, value)

# Register _IValue_float in _pymdlsdk:
_pymdlsdk._IValue_float_swigregister(_IValue_float)

class Interface_declare_IValue_double(_IValue_atomic):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IValue_double_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IValue_double

# Register Interface_declare_IValue_double in _pymdlsdk:
_pymdlsdk.Interface_declare_IValue_double_swigregister(Interface_declare_IValue_double)

def Interface_declare_IValue_double_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IValue_double_compare_iid(iid)

class _IValue_double(Interface_declare_IValue_double):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk._IValue_double_get_type(self)

    def get_value(self):
        r""" Returns the value."""
        return _pymdlsdk._IValue_double_get_value(self)

    def set_value(self, value):
        r""" Sets the value."""
        return _pymdlsdk._IValue_double_set_value(self, value)

# Register _IValue_double in _pymdlsdk:
_pymdlsdk._IValue_double_swigregister(_IValue_double)

class Interface_declare_IValue_string(_IValue_atomic):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IValue_string_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IValue_string

# Register Interface_declare_IValue_string in _pymdlsdk:
_pymdlsdk.Interface_declare_IValue_string_swigregister(Interface_declare_IValue_string)

def Interface_declare_IValue_string_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IValue_string_compare_iid(iid)

class _IValue_string(Interface_declare_IValue_string):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk._IValue_string_get_type(self)

    def get_value(self):
        r""" Returns the value."""
        return _pymdlsdk._IValue_string_get_value(self)

    def set_value(self, value):
        r""" Sets the value."""
        return _pymdlsdk._IValue_string_set_value(self, value)

# Register _IValue_string in _pymdlsdk:
_pymdlsdk._IValue_string_swigregister(_IValue_string)

class Interface_declare_IValue_string_localized(_IValue_string):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IValue_string_localized_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IValue_string_localized

# Register Interface_declare_IValue_string_localized in _pymdlsdk:
_pymdlsdk.Interface_declare_IValue_string_localized_swigregister(Interface_declare_IValue_string_localized)

def Interface_declare_IValue_string_localized_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IValue_string_localized_compare_iid(iid)

class _IValue_string_localized(Interface_declare_IValue_string_localized):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_original_value(self):
        r"""
        Returns the original value of a localized string.
        While IValue_string::value() returns the translated string.
        """
        return _pymdlsdk._IValue_string_localized_get_original_value(self)

# Register _IValue_string_localized in _pymdlsdk:
_pymdlsdk._IValue_string_localized_swigregister(_IValue_string_localized)

class Interface_declare_IValue_compound(_IValue):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IValue_compound_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IValue_compound

# Register Interface_declare_IValue_compound in _pymdlsdk:
_pymdlsdk.Interface_declare_IValue_compound_swigregister(Interface_declare_IValue_compound)

def Interface_declare_IValue_compound_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IValue_compound_compare_iid(iid)

class _IValue_compound(Interface_declare_IValue_compound):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk._IValue_compound_get_type(self)

    def get_size(self):
        r""" Returns the number of components in this compound value."""
        return _pymdlsdk._IValue_compound_get_size(self)

    def _get_value(self, *args):
        r"""
        *Overload 1:*
        Returns the value at ``index``, or ``NULL`` if ``index`` is out of bounds.

        |

        *Overload 2:*
        Returns the value at ``index``, or ``NULL`` if ``index`` is out of bounds.
        """
        return _pymdlsdk._IValue_compound__get_value(self, *args)

    def set_value(self, index, value):
        r"""
        Sets the value at ``index``.

        :type index: int
        :param index:   The index of the field.
        :type value: :py:class:`IValue`
        :param value:   The new value of the field.
        :rtype: int
        :return: 
                           -  0: Success.
                           - -1: Invalid parameter (``NULL`` pointer).
                           - -2: ``index`` is out of bounds.
                           - -3: Incorrect type of ``value``.
        """
        return _pymdlsdk._IValue_compound_set_value(self, index, value)

# Register _IValue_compound in _pymdlsdk:
_pymdlsdk._IValue_compound_swigregister(_IValue_compound)

class Interface_declare_IValue_vector(_IValue_compound):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IValue_vector_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IValue_vector

# Register Interface_declare_IValue_vector in _pymdlsdk:
_pymdlsdk.Interface_declare_IValue_vector_swigregister(Interface_declare_IValue_vector)

def Interface_declare_IValue_vector_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IValue_vector_compare_iid(iid)

class _IValue_vector(Interface_declare_IValue_vector):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk._IValue_vector_get_type(self)

    def _get_value(self, *args):
        r"""
        *Overload 1:*
        Returns the value at ``index``, or ``NULL`` if ``index`` is out of bounds.

        |

        *Overload 2:*
        Returns the value at ``index``, or ``NULL`` if ``index`` is out of bounds.
        """
        return _pymdlsdk._IValue_vector__get_value(self, *args)

# Register _IValue_vector in _pymdlsdk:
_pymdlsdk._IValue_vector_swigregister(_IValue_vector)

class Interface_declare_IValue_matrix(_IValue_compound):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IValue_matrix_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IValue_matrix

# Register Interface_declare_IValue_matrix in _pymdlsdk:
_pymdlsdk.Interface_declare_IValue_matrix_swigregister(Interface_declare_IValue_matrix)

def Interface_declare_IValue_matrix_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IValue_matrix_compare_iid(iid)

class _IValue_matrix(Interface_declare_IValue_matrix):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk._IValue_matrix_get_type(self)

    def _get_value(self, *args):
        r"""
        *Overload 1:*
        Returns the value at ``index``, or ``NULL`` if ``index`` is out of bounds.

        |

        *Overload 2:*
        Returns the value at ``index``, or ``NULL`` if ``index`` is out of bounds.
        """
        return _pymdlsdk._IValue_matrix__get_value(self, *args)

# Register _IValue_matrix in _pymdlsdk:
_pymdlsdk._IValue_matrix_swigregister(_IValue_matrix)

class Interface_declare_IValue_color(_IValue_compound):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IValue_color_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IValue_color

# Register Interface_declare_IValue_color in _pymdlsdk:
_pymdlsdk.Interface_declare_IValue_color_swigregister(Interface_declare_IValue_color)

def Interface_declare_IValue_color_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IValue_color_compare_iid(iid)

class _IValue_color(Interface_declare_IValue_color):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk._IValue_color_get_type(self)

    def _get_value(self, *args):
        r"""
        *Overload 1:*
        Returns the value at ``index``, or ``NULL`` if ``index`` is out of bounds.

        |

        *Overload 2:*
        Returns the value at ``index``, or ``NULL`` if ``index`` is out of bounds.
        """
        return _pymdlsdk._IValue_color__get_value(self, *args)

    def set_value(self, *args):
        r"""
        *Overload 1:*
        Sets the value at ``index``.

        :rtype: int
        :return: 
                           -  0: Success.
                           - -1: Invalid parameter (``NULL`` pointer).
                           - -2: ``index`` is out of bounds.

        |

        *Overload 2:*
        Sets the value at ``index``.

        :type index: int
        :param index:   The index of the field.
        :type value: :py:class:`IValue`
        :param value:   The new value of the field.
        :rtype: int
        :return: 
                           -  0: Success.
                           - -1: Invalid parameter (``NULL`` pointer).
                           - -2: ``index`` is out of bounds.
                           - -3: Incorrect type of ``value``.
        """
        return _pymdlsdk._IValue_color_set_value(self, *args)

# Register _IValue_color in _pymdlsdk:
_pymdlsdk._IValue_color_swigregister(_IValue_color)

class Interface_declare_IValue_array(_IValue_compound):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IValue_array_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IValue_array

# Register Interface_declare_IValue_array in _pymdlsdk:
_pymdlsdk.Interface_declare_IValue_array_swigregister(Interface_declare_IValue_array)

def Interface_declare_IValue_array_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IValue_array_compare_iid(iid)

class _IValue_array(Interface_declare_IValue_array):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk._IValue_array_get_type(self)

    def set_size(self, size):
        r"""
        Sets the size for dynamic arrays.

        :type size: int
        :param size:   The desired array size.
        :rtype: int
        :return: 
                          -  0: Success.
                          - -1: The array is a static array.
        """
        return _pymdlsdk._IValue_array_set_size(self, size)

# Register _IValue_array in _pymdlsdk:
_pymdlsdk._IValue_array_swigregister(_IValue_array)

class Interface_declare_IValue_struct(_IValue_compound):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IValue_struct_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IValue_struct

# Register Interface_declare_IValue_struct in _pymdlsdk:
_pymdlsdk.Interface_declare_IValue_struct_swigregister(Interface_declare_IValue_struct)

def Interface_declare_IValue_struct_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IValue_struct_compare_iid(iid)

class _IValue_struct(Interface_declare_IValue_struct):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk._IValue_struct_get_type(self)

    def _get_field(self, *args):
        r"""
        *Overload 1:*
        Returns a field by name in linear time.

        :type name: string
        :param name:    The name of the field.
        :rtype: :py:class:`IValue`
        :return: The value of the field, or ``NULL`` if there is no such field.

        |

        *Overload 2:*
        Returns a field by name in linear time.

        :type name: string
        :param name:    The name of the field.
        :rtype: :py:class:`IValue`
        :return: The value of the field, or ``NULL`` if there is no such field.
        """
        return _pymdlsdk._IValue_struct__get_field(self, *args)

    def set_field(self, name, value):
        r"""
        Sets a field by name in linear time.

        :type name: string
        :param name:    The name of the field.
        :type value: :py:class:`IValue`
        :param value:   The new value of the field.
        :rtype: int
        :return: 
                           -  0: Success.
                           - -1: Invalid parameter (``NULL`` pointer).
                           - -2: There is no such field of the given name.
                           - -3: Incorrect type of ``value``.
        """
        return _pymdlsdk._IValue_struct_set_field(self, name, value)

# Register _IValue_struct in _pymdlsdk:
_pymdlsdk._IValue_struct_swigregister(_IValue_struct)

class Interface_declare_IValue_resource(_IValue):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IValue_resource_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IValue_resource

# Register Interface_declare_IValue_resource in _pymdlsdk:
_pymdlsdk.Interface_declare_IValue_resource_swigregister(Interface_declare_IValue_resource)

def Interface_declare_IValue_resource_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IValue_resource_compare_iid(iid)

class _IValue_resource(Interface_declare_IValue_resource):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk._IValue_resource_get_type(self)

    def get_value(self):
        r"""
        Returns the name of the DB element representing this resource.

        :rtype: string
        :return: The name of the DB element, or ``NULL`` if no valid resource is set.
        """
        return _pymdlsdk._IValue_resource_get_value(self)

    def set_value(self, value):
        r"""
        Sets the name of the DB element representing this resource.

        Pointing this instance to a different DB element resets the MDL file path returned by
        #get_file_path().

        :type value: string
        :param value:   The name of the resource, or ``NULL`` to release the current resource.
        :rtype: int
        :return: 
                           -  0: Success.
                           - -1: There is no DB element with that name.
                           - -2: The DB element has not the correct type for this resource.
        """
        return _pymdlsdk._IValue_resource_set_value(self, value)

    def get_file_path(self):
        r"""
        Returns the absolute MDL file path of the resource, or ``NULL`` if not known.

        Notes: The value returned here is not a property of this object, but a property of the
              referenced resource.
        """
        return _pymdlsdk._IValue_resource_get_file_path(self)

# Register _IValue_resource in _pymdlsdk:
_pymdlsdk._IValue_resource_swigregister(_IValue_resource)

class Interface_declare_IValue_texture(_IValue_resource):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IValue_texture_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IValue_texture

# Register Interface_declare_IValue_texture in _pymdlsdk:
_pymdlsdk.Interface_declare_IValue_texture_swigregister(Interface_declare_IValue_texture)

def Interface_declare_IValue_texture_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IValue_texture_compare_iid(iid)

class _IValue_texture(Interface_declare_IValue_texture):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk._IValue_texture_get_type(self)

    def get_gamma(self):
        r"""
        Returns the gamma value of this texture.

        Notes: : A gamma value of 0 corresponds to the default gamma value for the given texture
               kind.
        """
        return _pymdlsdk._IValue_texture_get_gamma(self)

# Register _IValue_texture in _pymdlsdk:
_pymdlsdk._IValue_texture_swigregister(_IValue_texture)

class Interface_declare_IValue_light_profile(_IValue_resource):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IValue_light_profile_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IValue_light_profile

# Register Interface_declare_IValue_light_profile in _pymdlsdk:
_pymdlsdk.Interface_declare_IValue_light_profile_swigregister(Interface_declare_IValue_light_profile)

def Interface_declare_IValue_light_profile_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IValue_light_profile_compare_iid(iid)

class _IValue_light_profile(Interface_declare_IValue_light_profile):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk._IValue_light_profile_get_type(self)

# Register _IValue_light_profile in _pymdlsdk:
_pymdlsdk._IValue_light_profile_swigregister(_IValue_light_profile)

class Interface_declare_IValue_bsdf_measurement(_IValue_resource):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IValue_bsdf_measurement_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IValue_bsdf_measurement

# Register Interface_declare_IValue_bsdf_measurement in _pymdlsdk:
_pymdlsdk.Interface_declare_IValue_bsdf_measurement_swigregister(Interface_declare_IValue_bsdf_measurement)

def Interface_declare_IValue_bsdf_measurement_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IValue_bsdf_measurement_compare_iid(iid)

class _IValue_bsdf_measurement(Interface_declare_IValue_bsdf_measurement):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk._IValue_bsdf_measurement_get_type(self)

# Register _IValue_bsdf_measurement in _pymdlsdk:
_pymdlsdk._IValue_bsdf_measurement_swigregister(_IValue_bsdf_measurement)

class Interface_declare_IValue_invalid_df(_IValue):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IValue_invalid_df_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IValue_invalid_df

# Register Interface_declare_IValue_invalid_df in _pymdlsdk:
_pymdlsdk.Interface_declare_IValue_invalid_df_swigregister(Interface_declare_IValue_invalid_df)

def Interface_declare_IValue_invalid_df_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IValue_invalid_df_compare_iid(iid)

class _IValue_invalid_df(Interface_declare_IValue_invalid_df):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk._IValue_invalid_df_get_type(self)

# Register _IValue_invalid_df in _pymdlsdk:
_pymdlsdk._IValue_invalid_df_swigregister(_IValue_invalid_df)

class Interface_declare_IValue_list(object):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IValue_list_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IValue_list

# Register Interface_declare_IValue_list in _pymdlsdk:
_pymdlsdk.Interface_declare_IValue_list_swigregister(Interface_declare_IValue_list)

def Interface_declare_IValue_list_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IValue_list_compare_iid(iid)

class _IValue_list(Interface_declare_IValue_list):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_size(self):
        r""" Returns the number of elements."""
        return _pymdlsdk._IValue_list_get_size(self)

    def get_index(self, name):
        r""" Returns the index for the given name, or -1 if there is no such value."""
        return _pymdlsdk._IValue_list_get_index(self, name)

    def get_name(self, index):
        r""" Returns the name for the given index, or ``NULL`` if there is no such value."""
        return _pymdlsdk._IValue_list_get_name(self, index)

    def get_value(self, *args):
        r"""
        *Overload 1:*
        Returns the value for ``index``, or ``NULL`` if there is no such value.

        |

        *Overload 2:*
        Returns the value for ``name``, or ``NULL`` if there is no such value.
        """
        return _pymdlsdk._IValue_list_get_value(self, *args)

    def set_value(self, *args):
        r"""
        *Overload 1:*
        Sets a value at a given index.

        :rtype: int
        :return: 
                      -  0: Success.
                      - -1: Invalid parameter (``NULL`` pointer).
                      - -2: ``index`` is out of bounds.

        |

        *Overload 2:*
        Sets a value identified by name.

        :rtype: int
        :return: 
                      -  0: Success.
                      - -1: Invalid parameter (``NULL`` pointer).
                      - -2: There is no value mapped to ``name`` in the list.
        """
        return _pymdlsdk._IValue_list_set_value(self, *args)

    def add_value(self, name, value):
        r"""
        Adds a value at the end of the list.

        :rtype: int
        :return: 
                      -  0: Success.
                      - -1: Invalid parameter (``NULL`` pointer).
                      - -2: There is already a value mapped to ``name`` in the list.
        """
        return _pymdlsdk._IValue_list_add_value(self, name, value)

# Register _IValue_list in _pymdlsdk:
_pymdlsdk._IValue_list_swigregister(_IValue_list)

class Interface_declare_IValue_factory(object):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IValue_factory_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IValue_factory

# Register Interface_declare_IValue_factory in _pymdlsdk:
_pymdlsdk.Interface_declare_IValue_factory_swigregister(Interface_declare_IValue_factory)

def Interface_declare_IValue_factory_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IValue_factory_compare_iid(iid)

class _IValue_factory(Interface_declare_IValue_factory):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_type_factory(self):
        r""" Returns the type factory associated with this value factory."""
        return _pymdlsdk._IValue_factory_get_type_factory(self)

    def create_bool(self, value=False):
        r""" Creates a new value of type boolean."""
        return _pymdlsdk._IValue_factory_create_bool(self, value)

    def create_int(self, value=0):
        r""" Creates a new value of type integer."""
        return _pymdlsdk._IValue_factory_create_int(self, value)

    def create_enum(self, type, index=0):
        r""" Creates a new value of type enum, or returns ``NULL`` in case of errors."""
        return _pymdlsdk._IValue_factory_create_enum(self, type, index)

    def create_float(self, value=0.0):
        r""" Creates a new value of type float."""
        return _pymdlsdk._IValue_factory_create_float(self, value)

    def create_double(self, value=0.0):
        r""" Creates a new value of type double."""
        return _pymdlsdk._IValue_factory_create_double(self, value)

    def create_string(self, *args):
        r"""
        Creates a new value of type string.

        :type value: string, optional
        :param value:   The value ``NULL`` is handled like the empty string.
        """
        return _pymdlsdk._IValue_factory_create_string(self, *args)

    def create_vector(self, type):
        r""" Creates a new value of type vector, or returns ``NULL`` in case of errors."""
        return _pymdlsdk._IValue_factory_create_vector(self, type)

    def create_matrix(self, type):
        r""" Creates a new value of type matrix, or returns ``NULL`` in case of errors."""
        return _pymdlsdk._IValue_factory_create_matrix(self, type)

    def create_color(self, red=0.0, green=0.0, blue=0.0):
        r""" Creates a new value of type color."""
        return _pymdlsdk._IValue_factory_create_color(self, red, green, blue)

    def create_array(self, type):
        r""" Creates a new value of type array, or returns ``NULL`` in case of errors."""
        return _pymdlsdk._IValue_factory_create_array(self, type)

    def create_struct(self, type):
        r""" Creates a new value of type struct, or returns ``NULL`` in case of errors."""
        return _pymdlsdk._IValue_factory_create_struct(self, type)

    def create_texture(self, type, value):
        r""" Creates a new texture value, or returns ``NULL`` in case of errors."""
        return _pymdlsdk._IValue_factory_create_texture(self, type, value)

    def create_light_profile(self, value):
        r""" Creates a new light profile value, or returns ``NULL`` in case of errors."""
        return _pymdlsdk._IValue_factory_create_light_profile(self, value)

    def create_bsdf_measurement(self, value):
        r""" Creates a new BSDF measurement value, or returns ``NULL`` in case of errors."""
        return _pymdlsdk._IValue_factory_create_bsdf_measurement(self, value)

    def create_invalid_df(self, type):
        r""" Creates a new invalid distribution function value."""
        return _pymdlsdk._IValue_factory_create_invalid_df(self, type)

    def create(self, type):
        r""" Creates a default-constructed value of the given type."""
        return _pymdlsdk._IValue_factory_create(self, type)

    def create_value_list(self):
        r""" Creates a new value list."""
        return _pymdlsdk._IValue_factory_create_value_list(self)

    def clone(self, *args):
        r"""
        *Overload 1:*
        Clones the given value.

        Note that referenced DB elements, e.g., resources, are not copied, but shared.

        |

        *Overload 2:*
        Clones the given value list.

        Note that referenced DB elements, e.g., resources, are not copied, but shared.
        """
        return _pymdlsdk._IValue_factory_clone(self, *args)

    def compare(self, *args):
        r"""
        *Overload 1:*
        Compares two instances of #mi::neuraylib::IValue.

        The comparison operator for instances of #mi::neuraylib::IValue is defined as follows:
        - If ``lhs`` or ``rhs`` is ``NULL``, the result is the lexicographic comparison of
          the pointer addresses themselves.
        - Otherwise, the types of ``lhs`` and ``rhs`` are compared. If they are different, the result
          is determined by that comparison.
        - Next, the kind of the values are compared. If they are different, the result is determined
          by ``operator``< on the #mi::neuraylib::IValue::Kind values.
        - Finally, the values are compared as follows:
          - For atomic types, their values are compared using ``operator``< or ``strcmp()``, with the
            exception of enums, for which the indices rather than the values are compared.
          - For compounds, the compound size is compared using ``operator``< (the compound size might
            be different for dynamic arrays). If both compounds are of equal size, the compounds
            elements are compared in lexicographic order.
          - For resources, the values are compared using ``strcmp()``.

        :type lhs: :py:class:`IValue`
        :param lhs:          The left-hand side operand for the comparison.
        :type rhs: :py:class:`IValue`
        :param rhs:          The right-hand side operand for the comparison.
        :rtype: int
        :return: -1 if ``lhs`` < ``rhs``, 0 if ``lhs`` == ``rhs``, and +1 if ``lhs`` > ``rhs``.

        |

        *Overload 2:*
        Compares two instances of #mi::neuraylib::IValue_list.

        The comparison operator for instances of #mi::neuraylib::IValue_list is defined as follows:
        - If ``lhs`` or ``rhs`` is ``NULL``, the result is the lexicographic comparison of
          the pointer addresses themselves.
        - Next, the list sizes are compared using ``operator``<().
        - Next, the lists are traversed by increasing index and the names are compared
          using ``strcmp()``.
        - Finally, the list elements are enumerated by increasing index and the values are compared.

        :type lhs: :py:class:`IValue_list`
        :param lhs:          The left-hand side operand for the comparison.
        :type rhs: :py:class:`IValue_list`
        :param rhs:          The right-hand side operand for the comparison.
        :rtype: int
        :return: -1 if ``lhs`` < ``rhs``, 0 if ``lhs`` == ``rhs``, and +1 if ``lhs`` > ``rhs``.
        """
        return _pymdlsdk._IValue_factory_compare(self, *args)

    def dump(self, *args):
        r"""
        *Overload 1:*
         Returns a textual representation of a value.

         The textual representation is of the form "type name = value" if ``name`` is not ``NULL``, and
         of the form "value" if ``name`` is ``NULL``. The representation of the value might contain
         line breaks, for example for structures, enums, and arrays. Subsequent lines have a suitable
         indentation. The assumed indentation level of the first line is specified by ``depth``.

         Notes: The exact format of the textual representation is unspecified and might change in
               future releases. The textual representation is primarily meant as a debugging aid. Do
               *not* base application logic on it.

        |

        *Overload 2:*
         Returns a textual representation of a value list.

         The representation of the value list will contain line breaks. Subsequent lines have a
         suitable indentation. The assumed indentation level of the first line is specified by
        ``depth``.

         Notes: The exact format of the textual representation is unspecified and might change in
               future releases. The textual representation is primarily meant as a debugging aid. Do
               *not* base application logic on it.

        |

        *Overload 3:*
         Returns a textual representation of a value list.

         The representation of the value list will contain line breaks. Subsequent lines have a
         suitable indentation. The assumed indentation level of the first line is specified by
        ``depth``.

         Notes: The exact format of the textual representation is unspecified and might change in
               future releases. The textual representation is primarily meant as a debugging aid. Do
               *not* base application logic on it.
        """
        return _pymdlsdk._IValue_factory_dump(self, *args)

# Register _IValue_factory in _pymdlsdk:
_pymdlsdk._IValue_factory_swigregister(_IValue_factory)


def set_value(*args):
    r"""
    *Overload 1:*
    This specialization handles #mi::neuraylib::IValue_bool.

    It expects a ``bool`` as second argument. See #mi::neuraylib::set_value() for details.

    |

    *Overload 2:*
    This specialization handles #mi::neuraylib::IValue_float and #mi::neuraylib::IValue_double.

    It expects an #mi::Float32 as second argument. See #mi::neuraylib::set_value() for details.

    |

    *Overload 3:*
    This specialization handles #mi::neuraylib::IValue_float and #mi::neuraylib::IValue_double.

    It expects an #mi::Float64 as second argument. See #mi::neuraylib::set_value() for details.

    |

    *Overload 4:*
    This specialization handles #mi::neuraylib::IValue_enum, #mi::neuraylib::IValue_string and
    #mi::neuraylib::IValue_resource.

    It expects a ``const`` ``char*`` as second argument. See #mi::neuraylib::set_value() for details.

    |

    *Overload 5:*
    This specialization handles #mi::neuraylib::IValue_color.

    It expects an #mi::math::Color as second argument. See #mi::neuraylib::set_value() for details.

    |

    *Overload 6:*
    This specialization handles #mi::neuraylib::IValue_color.

    It expects an #mi::math::Spectrum as second argument. See #mi::neuraylib::set_value() for
    details.
    """
    return _pymdlsdk.set_value(*args)

def get_value(*args):
    r"""
    *Overload 1:*
    This specialization handles #mi::neuraylib::IValue_bool.

    It expects a ``bool`` as second argument. See #mi::neuraylib::get_value() for details.

    |

    *Overload 2:*
    This specialization handles #mi::neuraylib::IValue_float and #mi::neuraylib::IValue_double.

    It expects an #mi::Float32 as second argument. See #mi::neuraylib::get_value() for details.

    |

    *Overload 3:*
    This specialization handles #mi::neuraylib::IValue_float and #mi::neuraylib::IValue_double.

    It expects an #mi::Float64 as second argument. See #mi::neuraylib::get_value() for details.

    |

    *Overload 4:*
    This specialization handles #mi::neuraylib::IValue_enum, #mi::neuraylib::IValue_string and
    #mi::neuraylib::IValue_resource.

    It expects a ``const`` ``char*`` as second argument. See #mi::neuraylib::get_value() for details.

    |

    *Overload 5:*
    This specialization handles #mi::neuraylib::IValue_color.

    It expects an #mi::math::Color as second argument. See #mi::neuraylib::get_value() for details.

    |

    *Overload 6:*
    This specialization handles #mi::neuraylib::IValue_color.

    It expects an #mi::math::Spectrum as second argument. See #mi::neuraylib::get_value() for
    details.
    """
    return _pymdlsdk.get_value(*args)
MDL_VERSION_1_0 = _pymdlsdk.MDL_VERSION_1_0
r""" MDL version 1.0"""
MDL_VERSION_1_1 = _pymdlsdk.MDL_VERSION_1_1
r""" MDL version 1.1"""
MDL_VERSION_1_2 = _pymdlsdk.MDL_VERSION_1_2
r""" MDL version 1.2"""
MDL_VERSION_1_3 = _pymdlsdk.MDL_VERSION_1_3
r""" MDL version 1.3"""
MDL_VERSION_1_4 = _pymdlsdk.MDL_VERSION_1_4
r""" MDL version 1.4"""
MDL_VERSION_1_5 = _pymdlsdk.MDL_VERSION_1_5
r""" MDL version 1.5"""
MDL_VERSION_1_6 = _pymdlsdk.MDL_VERSION_1_6
r""" MDL version 1.6"""
MDL_VERSION_1_7 = _pymdlsdk.MDL_VERSION_1_7
r""" MDL version 1.7"""
MDL_VERSION_LATEST = _pymdlsdk.MDL_VERSION_LATEST
r""" Latest MDL version"""
MDL_VERSION_INVALID = _pymdlsdk.MDL_VERSION_INVALID
r""" Invalid MDL version"""
MDL_VERSION_FORCE_32_BIT = _pymdlsdk.MDL_VERSION_FORCE_32_BIT
class Interface_declare_IExpression(object):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IExpression_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IExpression

# Register Interface_declare_IExpression in _pymdlsdk:
_pymdlsdk.Interface_declare_IExpression_swigregister(Interface_declare_IExpression)

def Interface_declare_IExpression_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IExpression_compare_iid(iid)

class _IExpression(Interface_declare_IExpression):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    EK_CONSTANT = _pymdlsdk._IExpression_EK_CONSTANT
    r""" A constant expression. See #mi::neuraylib::IExpression_constant."""
    EK_CALL = _pymdlsdk._IExpression_EK_CALL
    r""" An indirect call expression. See #mi::neuraylib::IExpression_call."""
    EK_PARAMETER = _pymdlsdk._IExpression_EK_PARAMETER
    r""" A parameter reference expression. See #mi::neuraylib::IExpression_parameter."""
    EK_DIRECT_CALL = _pymdlsdk._IExpression_EK_DIRECT_CALL
    r""" A direct call expression. See #mi::neuraylib::IExpression_direct_call."""
    EK_TEMPORARY = _pymdlsdk._IExpression_EK_TEMPORARY
    r""" A temporary reference expression. See #mi::neuraylib::IExpression_temporary."""
    EK_FORCE_32_BIT = _pymdlsdk._IExpression_EK_FORCE_32_BIT

    def _get_kind(self):
        r""" Returns the kind of this expression."""
        return _pymdlsdk._IExpression__get_kind(self)

    def _get_type(self):
        r""" Returns the type of this expression."""
        return _pymdlsdk._IExpression__get_type(self)

# Register _IExpression in _pymdlsdk:
_pymdlsdk._IExpression_swigregister(_IExpression)

class Interface_declare_IExpression_constant(_IExpression):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IExpression_constant_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IExpression_constant

# Register Interface_declare_IExpression_constant in _pymdlsdk:
_pymdlsdk.Interface_declare_IExpression_constant_swigregister(Interface_declare_IExpression_constant)

def Interface_declare_IExpression_constant_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IExpression_constant_compare_iid(iid)

class _IExpression_constant(Interface_declare_IExpression_constant):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def _get_value(self, *args):
        r"""
        *Overload 1:*
        Returns the value of the constant.

        |

        *Overload 2:*
        Returns the value of the constant.
        """
        return _pymdlsdk._IExpression_constant__get_value(self, *args)

    def set_value(self, value):
        r"""
        Sets the value of the constant.

        :rtype: int
        :return: 
                      -  0: Success.
                      - -1: Invalid parameter (``NULL`` pointer).
                      - -2: The type of ``value`` does not match the type of the constant.
        """
        return _pymdlsdk._IExpression_constant_set_value(self, value)

# Register _IExpression_constant in _pymdlsdk:
_pymdlsdk._IExpression_constant_swigregister(_IExpression_constant)

class Interface_declare_IExpression_call(_IExpression):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IExpression_call_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IExpression_call

# Register Interface_declare_IExpression_call in _pymdlsdk:
_pymdlsdk.Interface_declare_IExpression_call_swigregister(Interface_declare_IExpression_call)

def Interface_declare_IExpression_call_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IExpression_call_compare_iid(iid)

class _IExpression_call(Interface_declare_IExpression_call):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_call(self):
        r""" Returns the DB name of the referenced function call or material instance."""
        return _pymdlsdk._IExpression_call_get_call(self)

    def set_call(self, name):
        r"""
        Sets the name of the referenced function call or material instance.

        :type name: string
        :param name:    The DB name of the function call or material instance.
        :rtype: int
        :return: 
                           -  0: Success.
                           - -1: Invalid parameter (``NULL`` pointer).
                           - -2: There is no DB element with that name.
                           - -3: The DB element has not the correct type.
                           - -4: The return type of the DB element does not match the type of this
                                 expression.
                           - -5: The material instance or function call referenced by "name" is
                                 a parameter default and therefore cannot be used in a call.
                           - -6: The material instance or function call referenced by "name" is
                                 invalid and therefore cannot be used in a call.
        """
        return _pymdlsdk._IExpression_call_set_call(self, name)

# Register _IExpression_call in _pymdlsdk:
_pymdlsdk._IExpression_call_swigregister(_IExpression_call)

class Interface_declare_IExpression_parameter(_IExpression):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IExpression_parameter_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IExpression_parameter

# Register Interface_declare_IExpression_parameter in _pymdlsdk:
_pymdlsdk.Interface_declare_IExpression_parameter_swigregister(Interface_declare_IExpression_parameter)

def Interface_declare_IExpression_parameter_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IExpression_parameter_compare_iid(iid)

class _IExpression_parameter(Interface_declare_IExpression_parameter):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_index(self):
        r""" Returns the index of the referenced parameter."""
        return _pymdlsdk._IExpression_parameter_get_index(self)

    def set_index(self, index):
        r""" Sets the index of the referenced parameter."""
        return _pymdlsdk._IExpression_parameter_set_index(self, index)

# Register _IExpression_parameter in _pymdlsdk:
_pymdlsdk._IExpression_parameter_swigregister(_IExpression_parameter)

class Interface_declare_IExpression_direct_call(_IExpression):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IExpression_direct_call_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IExpression_direct_call

# Register Interface_declare_IExpression_direct_call in _pymdlsdk:
_pymdlsdk.Interface_declare_IExpression_direct_call_swigregister(Interface_declare_IExpression_direct_call)

def Interface_declare_IExpression_direct_call_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IExpression_direct_call_compare_iid(iid)

class _IExpression_direct_call(Interface_declare_IExpression_direct_call):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_definition(self):
        r""" Returns the DB name of the corresponding function or material definition."""
        return _pymdlsdk._IExpression_direct_call_get_definition(self)

    def get_arguments(self):
        r""" Returns the arguments of the direct call."""
        return _pymdlsdk._IExpression_direct_call_get_arguments(self)

# Register _IExpression_direct_call in _pymdlsdk:
_pymdlsdk._IExpression_direct_call_swigregister(_IExpression_direct_call)

class Interface_declare_IExpression_temporary(_IExpression):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IExpression_temporary_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IExpression_temporary

# Register Interface_declare_IExpression_temporary in _pymdlsdk:
_pymdlsdk.Interface_declare_IExpression_temporary_swigregister(Interface_declare_IExpression_temporary)

def Interface_declare_IExpression_temporary_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IExpression_temporary_compare_iid(iid)

class _IExpression_temporary(Interface_declare_IExpression_temporary):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_index(self):
        r""" Returns the index of the referenced temporary."""
        return _pymdlsdk._IExpression_temporary_get_index(self)

    def set_index(self, index):
        r""" Sets the index of the referenced temporary."""
        return _pymdlsdk._IExpression_temporary_set_index(self, index)

# Register _IExpression_temporary in _pymdlsdk:
_pymdlsdk._IExpression_temporary_swigregister(_IExpression_temporary)

class Interface_declare_IExpression_list(object):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IExpression_list_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IExpression_list

# Register Interface_declare_IExpression_list in _pymdlsdk:
_pymdlsdk.Interface_declare_IExpression_list_swigregister(Interface_declare_IExpression_list)

def Interface_declare_IExpression_list_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IExpression_list_compare_iid(iid)

class _IExpression_list(Interface_declare_IExpression_list):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_size(self):
        r""" Returns the number of elements."""
        return _pymdlsdk._IExpression_list_get_size(self)

    def get_index(self, name):
        r""" Returns the index for the given name, or -1 if there is no such expression."""
        return _pymdlsdk._IExpression_list_get_index(self, name)

    def get_name(self, index):
        r""" Returns the name for the given index, or ``NULL`` if there is no such expression."""
        return _pymdlsdk._IExpression_list_get_name(self, index)

    def _get_expression(self, *args):
        r"""
        *Overload 1:*
        Returns the expression for ``index``, or ``NULL`` if there is no such expression.

        |

        *Overload 2:*
        Returns the expression for ``name``, or ``NULL`` if there is no such expression.
        """
        return _pymdlsdk._IExpression_list__get_expression(self, *args)

    def set_expression(self, *args):
        r"""
        *Overload 1:*
        Sets an expression at a given index.

        :rtype: int
        :return: -  0: Success.
                      - -1: Invalid parameter (``NULL`` pointer).
                      - -2: ``index`` is out of bounds.

        |

        *Overload 2:*
        Sets an expression identified by name.

        :rtype: int
        :return: -  0: Success.
                      - -1: Invalid parameter (``NULL`` pointer).
                      - -2: There is no expression mapped to ``name`` in the list.
        """
        return _pymdlsdk._IExpression_list_set_expression(self, *args)

    def add_expression(self, name, expression):
        r"""
        Adds an expression at the end of the list.

        :rtype: int
        :return: -  0: Success.
                      - -1: Invalid parameter (``NULL`` pointer).
                      - -2: There is already an expression mapped to ``name`` in the list.
        """
        return _pymdlsdk._IExpression_list_add_expression(self, name, expression)

# Register _IExpression_list in _pymdlsdk:
_pymdlsdk._IExpression_list_swigregister(_IExpression_list)

class Interface_declare_IAnnotation_definition(object):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IAnnotation_definition_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IAnnotation_definition

# Register Interface_declare_IAnnotation_definition in _pymdlsdk:
_pymdlsdk.Interface_declare_IAnnotation_definition_swigregister(Interface_declare_IAnnotation_definition)

def Interface_declare_IAnnotation_definition_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IAnnotation_definition_compare_iid(iid)

class _IAnnotation_definition(Interface_declare_IAnnotation_definition):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    AS_UNKNOWN = _pymdlsdk._IAnnotation_definition_AS_UNKNOWN
    r""" Unknown semantics."""
    AS_ANNOTATION_FIRST = _pymdlsdk._IAnnotation_definition_AS_ANNOTATION_FIRST
    AS_INTRINSIC_ANNOTATION = _pymdlsdk._IAnnotation_definition_AS_INTRINSIC_ANNOTATION
    r""" This is the internal intrinsic() annotation."""
    AS_THROWS_ANNOTATION = _pymdlsdk._IAnnotation_definition_AS_THROWS_ANNOTATION
    r""" This is the internal throws() annotation."""
    AS_SINCE_ANNOTATION = _pymdlsdk._IAnnotation_definition_AS_SINCE_ANNOTATION
    r""" This is the internal since() annotation."""
    AS_REMOVED_ANNOTATION = _pymdlsdk._IAnnotation_definition_AS_REMOVED_ANNOTATION
    r""" This is the internal removed() annotation."""
    AS_CONST_EXPR_ANNOTATION = _pymdlsdk._IAnnotation_definition_AS_CONST_EXPR_ANNOTATION
    r""" This is the internal const_expr() annotation."""
    AS_DERIVABLE_ANNOTATION = _pymdlsdk._IAnnotation_definition_AS_DERIVABLE_ANNOTATION
    r""" This is the internal derivable() annotation."""
    AS_NATIVE_ANNOTATION = _pymdlsdk._IAnnotation_definition_AS_NATIVE_ANNOTATION
    r""" This is the internal native() annotation."""
    AS_UNUSED_ANNOTATION = _pymdlsdk._IAnnotation_definition_AS_UNUSED_ANNOTATION
    r""" This is the unused() annotation."""
    AS_NOINLINE_ANNOTATION = _pymdlsdk._IAnnotation_definition_AS_NOINLINE_ANNOTATION
    r""" This is the noinline() annotation."""
    AS_SOFT_RANGE_ANNOTATION = _pymdlsdk._IAnnotation_definition_AS_SOFT_RANGE_ANNOTATION
    r""" This is the soft_range() annotation."""
    AS_HARD_RANGE_ANNOTATION = _pymdlsdk._IAnnotation_definition_AS_HARD_RANGE_ANNOTATION
    r""" This is the hard_range() annotation."""
    AS_HIDDEN_ANNOTATION = _pymdlsdk._IAnnotation_definition_AS_HIDDEN_ANNOTATION
    r""" This is the hidden() annotation."""
    AS_DEPRECATED_ANNOTATION = _pymdlsdk._IAnnotation_definition_AS_DEPRECATED_ANNOTATION
    r""" This is the deprecated() annotation."""
    AS_VERSION_NUMBER_ANNOTATION = _pymdlsdk._IAnnotation_definition_AS_VERSION_NUMBER_ANNOTATION
    r""" This is the (old) version_number() annotation."""
    AS_VERSION_ANNOTATION = _pymdlsdk._IAnnotation_definition_AS_VERSION_ANNOTATION
    r""" This is the version() annotation."""
    AS_DEPENDENCY_ANNOTATION = _pymdlsdk._IAnnotation_definition_AS_DEPENDENCY_ANNOTATION
    r""" This is the dependency() annotation."""
    AS_UI_ORDER_ANNOTATION = _pymdlsdk._IAnnotation_definition_AS_UI_ORDER_ANNOTATION
    r""" This is the ui_order() annotation."""
    AS_USAGE_ANNOTATION = _pymdlsdk._IAnnotation_definition_AS_USAGE_ANNOTATION
    r""" This is the usage() annotation."""
    AS_ENABLE_IF_ANNOTATION = _pymdlsdk._IAnnotation_definition_AS_ENABLE_IF_ANNOTATION
    r""" This is the enable_if() annotation."""
    AS_THUMBNAIL_ANNOTATION = _pymdlsdk._IAnnotation_definition_AS_THUMBNAIL_ANNOTATION
    r""" This is the thumbnail() annotation."""
    AS_DISPLAY_NAME_ANNOTATION = _pymdlsdk._IAnnotation_definition_AS_DISPLAY_NAME_ANNOTATION
    r""" This is the display_name() annotation."""
    AS_IN_GROUP_ANNOTATION = _pymdlsdk._IAnnotation_definition_AS_IN_GROUP_ANNOTATION
    r""" This is the in_group() annotation."""
    AS_DESCRIPTION_ANNOTATION = _pymdlsdk._IAnnotation_definition_AS_DESCRIPTION_ANNOTATION
    r""" This is the description() annotation."""
    AS_AUTHOR_ANNOTATION = _pymdlsdk._IAnnotation_definition_AS_AUTHOR_ANNOTATION
    r""" This is the author() annotation."""
    AS_CONTRIBUTOR_ANNOTATION = _pymdlsdk._IAnnotation_definition_AS_CONTRIBUTOR_ANNOTATION
    r""" This is the contributor() annotation."""
    AS_COPYRIGHT_NOTICE_ANNOTATION = _pymdlsdk._IAnnotation_definition_AS_COPYRIGHT_NOTICE_ANNOTATION
    r""" This is the copyright_notice() annotation."""
    AS_CREATED_ANNOTATION = _pymdlsdk._IAnnotation_definition_AS_CREATED_ANNOTATION
    r""" This is the created() annotation."""
    AS_MODIFIED_ANNOTATION = _pymdlsdk._IAnnotation_definition_AS_MODIFIED_ANNOTATION
    r""" This is the modified() annotation."""
    AS_KEYWORDS_ANNOTATION = _pymdlsdk._IAnnotation_definition_AS_KEYWORDS_ANNOTATION
    r""" This is the key_words() annotation."""
    AS_ORIGIN_ANNOTATION = _pymdlsdk._IAnnotation_definition_AS_ORIGIN_ANNOTATION
    r""" This is the origin() annotation."""
    AS_ANNOTATION_LAST = _pymdlsdk._IAnnotation_definition_AS_ANNOTATION_LAST
    AS_FORCE_32_BIT = _pymdlsdk._IAnnotation_definition_AS_FORCE_32_BIT

    def get_module(self):
        r"""
        Returns the DB name of the module containing this annotation definition.

        The type of the module is #mi::neuraylib::IModule.
        """
        return _pymdlsdk._IAnnotation_definition_get_module(self)

    def get_name(self):
        r""" Returns the MDL name of the annotation definition."""
        return _pymdlsdk._IAnnotation_definition_get_name(self)

    def get_mdl_module_name(self):
        r""" Returns the MDL name of the module containing this annotation definition."""
        return _pymdlsdk._IAnnotation_definition_get_mdl_module_name(self)

    def get_mdl_simple_name(self):
        r"""
        Returns the simple MDL name of the annotation definition.

        The simple name is the last component of the MDL name, i.e., without any packages and
        scope qualifiers, and without the parameter type names.

        :rtype: string
        :return: The simple MDL name of the annotation definition.
        """
        return _pymdlsdk._IAnnotation_definition_get_mdl_simple_name(self)

    def get_mdl_parameter_type_name(self, index):
        r"""
        Returns the type name of the parameter at ``index``.

        Notes: The type names provided here are substrings of the MDL name returned by #get_name().
              They are provided here such that parsing of the MDL name is not necessary. However,
              for most use cases it is strongly recommended to use #get_parameter_types() instead.

        :type index: int
        :param index:    The index of the parameter.
        :rtype: string
        :return: The type name of the parameter, or ``NULL`` if ``index`` is out of range.
        """
        return _pymdlsdk._IAnnotation_definition_get_mdl_parameter_type_name(self, index)

    def get_semantic(self):
        r""" Returns the semantic of this annotation definition."""
        return _pymdlsdk._IAnnotation_definition_get_semantic(self)

    def is_exported(self):
        r""" Indicates whether the annotation definition is exported by its module."""
        return _pymdlsdk._IAnnotation_definition_is_exported(self)

    def get_mdl_version(self, since, removed):
        r"""
        Returns the MDL version when this annotation definition was added and removed.

        :type since: int, out
        :param since:     The MDL version in which this annotation definition was added. If the
                                  annotation definition does not belong to the standard library, the
                                  MDL version of the corresponding module is returned.
        :type removed: int, out
        :param removed:   The MDL version in which this annotation definition was removed, or
                                  mi::neuraylib::MDL_VERSION_INVALID if the annotation has not been
                                  removed so far or does not belong to the standard library.
        """
        return _pymdlsdk._IAnnotation_definition_get_mdl_version(self, since, removed)

    def get_parameter_count(self):
        r""" Returns the parameter count of the annotation definition."""
        return _pymdlsdk._IAnnotation_definition_get_parameter_count(self)

    def get_parameter_name(self, index):
        r"""
        Returns the parameter name of the given index.

        :type index: int
        :param index:    The parameter index.
        :rtype: string
        :return: The name of the parameter or ``NULL`` if index
                            is out of range.
        """
        return _pymdlsdk._IAnnotation_definition_get_parameter_name(self, index)

    def get_parameter_index(self, name):
        r"""
        Returns the parameter index of the given name.

        :type name: string
        :param name:     The parameter name.
        :rtype: int
        :return: The index of the parameter or ``-1`` if there is no
                            parameter of that ``name``.
        """
        return _pymdlsdk._IAnnotation_definition_get_parameter_index(self, name)

    def get_parameter_types(self):
        r""" Returns the parameter types of the annotation definition."""
        return _pymdlsdk._IAnnotation_definition_get_parameter_types(self)

    def get_defaults(self):
        r""" Returns the parameter defaults of the annotation definition."""
        return _pymdlsdk._IAnnotation_definition_get_defaults(self)

    def get_annotations(self):
        r"""
        Returns the annotations of this definition or ``NULL`` if no
        annotations exist.
        """
        return _pymdlsdk._IAnnotation_definition_get_annotations(self)

    def create_annotation(self, arguments):
        r"""
        Creates an annotation.

        :type arguments: :py:class:`IExpression_list`
        :param arguments:    The arguments for new annotation.
        :rtype: :py:class:`IAnnotation`
        :return: The created annotation or ``NULL`` if one of the arguments
                                does not correspond to an actual parameter of the annotation or
                                is not a constant expression.
        """
        return _pymdlsdk._IAnnotation_definition_create_annotation(self, arguments)

# Register _IAnnotation_definition in _pymdlsdk:
_pymdlsdk._IAnnotation_definition_swigregister(_IAnnotation_definition)

class Interface_declare_IAnnotation(object):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IAnnotation_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IAnnotation

# Register Interface_declare_IAnnotation in _pymdlsdk:
_pymdlsdk.Interface_declare_IAnnotation_swigregister(Interface_declare_IAnnotation)

def Interface_declare_IAnnotation_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IAnnotation_compare_iid(iid)

class _IAnnotation(Interface_declare_IAnnotation):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_name(self):
        r""" Returns the name of the annotation."""
        return _pymdlsdk._IAnnotation_get_name(self)

    def set_name(self, name):
        r""" Sets the name of the annotation."""
        return _pymdlsdk._IAnnotation_set_name(self, name)

    def get_arguments(self):
        r"""
        Returns the arguments of the annotation.

        The arguments of annotations are always constant expressions.
        """
        return _pymdlsdk._IAnnotation_get_arguments(self)

    def get_definition(self):
        r""" Returns the definition of this annotation."""
        return _pymdlsdk._IAnnotation_get_definition(self)

# Register _IAnnotation in _pymdlsdk:
_pymdlsdk._IAnnotation_swigregister(_IAnnotation)

class Interface_declare_IAnnotation_block(object):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IAnnotation_block_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IAnnotation_block

# Register Interface_declare_IAnnotation_block in _pymdlsdk:
_pymdlsdk.Interface_declare_IAnnotation_block_swigregister(Interface_declare_IAnnotation_block)

def Interface_declare_IAnnotation_block_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IAnnotation_block_compare_iid(iid)

class _IAnnotation_block(Interface_declare_IAnnotation_block):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_size(self):
        r""" Returns the number of annotations in this block."""
        return _pymdlsdk._IAnnotation_block_get_size(self)

    def get_annotation(self, index):
        r""" Returns the annotation for ``index``, or ``NULL`` if index is out of bounds."""
        return _pymdlsdk._IAnnotation_block_get_annotation(self, index)

    def set_annotation(self, index, annotation):
        r"""
        Sets an annotation block at a given index.

        :rtype: int
        :return: -  0: Success.
                      - -1: Invalid parameter (``NULL`` pointer).
                      - -2: ``index`` is out of bounds.
        """
        return _pymdlsdk._IAnnotation_block_set_annotation(self, index, annotation)

    def add_annotation(self, annotation):
        r"""
        Adds an annotation at the end of the annotation block.

        :rtype: int
        :return: -  0: Success.
                      - -1: Invalid parameter (``NULL`` pointer).
        """
        return _pymdlsdk._IAnnotation_block_add_annotation(self, annotation)

# Register _IAnnotation_block in _pymdlsdk:
_pymdlsdk._IAnnotation_block_swigregister(_IAnnotation_block)

class Interface_declare_IAnnotation_list(object):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IAnnotation_list_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IAnnotation_list

# Register Interface_declare_IAnnotation_list in _pymdlsdk:
_pymdlsdk.Interface_declare_IAnnotation_list_swigregister(Interface_declare_IAnnotation_list)

def Interface_declare_IAnnotation_list_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IAnnotation_list_compare_iid(iid)

class _IAnnotation_list(Interface_declare_IAnnotation_list):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_size(self):
        r""" Returns the number of elements."""
        return _pymdlsdk._IAnnotation_list_get_size(self)

    def get_index(self, name):
        r""" Returns the index for the given name, or -1 if there is no such block."""
        return _pymdlsdk._IAnnotation_list_get_index(self, name)

    def get_name(self, index):
        r""" Returns the name for the given index, or ``NULL`` if there is no such block."""
        return _pymdlsdk._IAnnotation_list_get_name(self, index)

    def get_annotation_block(self, *args):
        r"""
        *Overload 1:*
        Returns the annotation block for ``index``, or ``NULL`` if there is no such block.

        |

        *Overload 2:*
        Returns the annotation block for ``name``, or ``NULL`` if there is no such block.
        """
        return _pymdlsdk._IAnnotation_list_get_annotation_block(self, *args)

    def set_annotation_block(self, *args):
        r"""
        *Overload 1:*
        Sets an annotation block at a given index.

        :rtype: int
        :return: -  0: Success.
                      - -1: Invalid parameter (``NULL`` pointer).
                      - -2: ``index`` is out of bounds.

        |

        *Overload 2:*
        Sets an annotation block identified by name.

        :rtype: int
        :return: -  0: Success.
                      - -1: Invalid parameter (``NULL`` pointer).
                      - -2: There is no annotation block mapped to ``name`` in the list.
        """
        return _pymdlsdk._IAnnotation_list_set_annotation_block(self, *args)

    def add_annotation_block(self, name, block):
        r"""
        Adds an annotation block at the end of the list.

        :rtype: int
        :return: -  0: Success.
                      - -1: Invalid parameter (``NULL`` pointer).
                      - -2: There is already an annotation block mapped to ``name`` in the list.
        """
        return _pymdlsdk._IAnnotation_list_add_annotation_block(self, name, block)

# Register _IAnnotation_list in _pymdlsdk:
_pymdlsdk._IAnnotation_list_swigregister(_IAnnotation_list)

class Interface_declare_IExpression_factory(object):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IExpression_factory_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IExpression_factory

# Register Interface_declare_IExpression_factory in _pymdlsdk:
_pymdlsdk.Interface_declare_IExpression_factory_swigregister(Interface_declare_IExpression_factory)

def Interface_declare_IExpression_factory_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IExpression_factory_compare_iid(iid)

class _IExpression_factory(Interface_declare_IExpression_factory):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_value_factory(self):
        r""" Returns the value factory associated with this expression factory."""
        return _pymdlsdk._IExpression_factory_get_value_factory(self)

    def create_constant(self, value):
        r"""
        Creates a constant (const).

        :type value: :py:class:`IValue`
        :param value:        The value of the constant.
        :rtype: :py:class:`IExpression_constant`
        :return: The created constant.
        """
        return _pymdlsdk._IExpression_factory_create_constant(self, value)

    def create_call(self, name):
        r"""
        Creates a call.

        :type name: string
        :param name:         The DB name of the referenced function call or material instance.
        :rtype: :py:class:`IExpression_call`
        :return: The created call, or ``NULL`` in case of errors.
        """
        return _pymdlsdk._IExpression_factory_create_call(self, name)

    def create_parameter(self, type, index):
        r"""
        Creates a parameter reference.

        :type type: :py:class:`IType`
        :param type:         The type of the parameter.
        :type index: int
        :param index:        The index of the parameter.
        :rtype: :py:class:`IExpression_parameter`
        :return: The created parameter reference, or ``NULL`` in case of errors.
        """
        return _pymdlsdk._IExpression_factory_create_parameter(self, type, index)

    def create_direct_call_with_ret(self, name, arguments):
        r"""
        Creates a direct call.

        :type name: string
        :param name:         The DB name of the referenced function or material definition.
        :type arguments: :py:class:`IExpression_list`
        :param arguments:    The arguments of the created direct call.

                                Arguments for parameters without default are mandatory, otherwise
                                optional. The type of an argument must match the corresponding parameter
                                type. Any argument missing in ``arguments`` will be set to the default of
                                the corresponding parameter.

                                Note that the expressions in ``arguments`` are copied. Valid
                                subexpressions are constants, direct calls, and parameter references.
                                operation is a deep copy, e.g., DB elements referenced in call
                                expressions are also copied.

                                ``NULL`` is a valid argument which is handled like an empty expression
                                list.
        :type errors: int, out, optional
        :param errors:  An optional pointer to an #mi::Sint32 to which an error code will be
                                written. The error codes have the following meaning:
                                -  0: Success.
                                - -1: An argument for a non-existing parameter was provided in
                                      ``arguments``.
                                - -2: The type of an argument in ``arguments`` does not have the correct
                                      type.
                                - -3: A parameter that has no default was not provided with an argument
                                      value.
                                - -4: The function or material definition can not be instantiated
                                      because it is not exported.
                                - -5: A parameter type is uniform, but the corresponding argument has a
                                      varying return type.
                                - -6: An argument expression is not a constant, a direct call, nor a
                                      parameter.
                                - -7: Invalid parameters (``NULL`` pointer) or ``name`` is not a valid
                                      DB name of a function or material definition.
                                - -8: One of the parameter types is uniform, but the corresponding
                                      argument or default is a call expression and the return type of
                                      the called function or material definition is effectively varying
                                      since the function or material definition itself is varying.
                                - -9: The function or material definition is invalid due to a module
                                      reload.
        :rtype: :py:class:`IExpression_direct_call`
        :return: The created call, or ``NULL`` in case of errors.
        """
        return _pymdlsdk._IExpression_factory_create_direct_call_with_ret(self, name, arguments)

    def create_direct_call(self, name, arguments):
        r"""
        Creates a direct call.

        :type name: string
        :param name:         The DB name of the referenced function or material definition.
        :type arguments: :py:class:`IExpression_list`
        :param arguments:    The arguments of the created direct call.

                                Arguments for parameters without default are mandatory, otherwise
                                optional. The type of an argument must match the corresponding parameter
                                type. Any argument missing in ``arguments`` will be set to the default of
                                the corresponding parameter.

                                Note that the expressions in ``arguments`` are copied. Valid
                                subexpressions are constants, direct calls, and parameter references.
                                operation is a deep copy, e.g., DB elements referenced in call
                                expressions are also copied.

                                ``NULL`` is a valid argument which is handled like an empty expression
                                list.
        :param errors:  An optional pointer to an #mi::Sint32 to which an error code will be
                                written. The error codes have the following meaning:
                                -  0: Success.
                                - -1: An argument for a non-existing parameter was provided in
                                      ``arguments``.
                                - -2: The type of an argument in ``arguments`` does not have the correct
                                      type.
                                - -3: A parameter that has no default was not provided with an argument
                                      value.
                                - -4: The function or material definition can not be instantiated
                                      because it is not exported.
                                - -5: A parameter type is uniform, but the corresponding argument has a
                                      varying return type.
                                - -6: An argument expression is not a constant, a direct call, nor a
                                      parameter.
                                - -7: Invalid parameters (``NULL`` pointer) or ``name`` is not a valid
                                      DB name of a function or material definition.
                                - -8: One of the parameter types is uniform, but the corresponding
                                      argument or default is a call expression and the return type of
                                      the called function or material definition is effectively varying
                                      since the function or material definition itself is varying.
                                - -9: The function or material definition is invalid due to a module
                                      reload.
        :rtype: :py:class:`IExpression_direct_call`
        :return: The created call, or ``NULL`` in case of errors.
        """
        return _pymdlsdk._IExpression_factory_create_direct_call(self, name, arguments)

    def create_expression_list(self):
        r""" Creates a new expression list."""
        return _pymdlsdk._IExpression_factory_create_expression_list(self)

    def create_annotation(self, name, arguments):
        r"""
        Creates a new annotation.

        Returns ``NULL`` if one of the arguments is not a constant expression.
        """
        return _pymdlsdk._IExpression_factory_create_annotation(self, name, arguments)

    def create_annotation_block(self):
        r""" Creates a new annotation block."""
        return _pymdlsdk._IExpression_factory_create_annotation_block(self)

    def create_annotation_list(self):
        r""" Creates a new annotation list."""
        return _pymdlsdk._IExpression_factory_create_annotation_list(self)

    def clone(self, *args):
        r"""
        *Overload 1:*
        Clones the given expression.

        Note that referenced DB elements, e.g., resources in constant expressions, or function calls
        and material instances in call expressions, are not copied, but shared. Function calls and
        material instances that serve as default arguments, are copied, though.

        |

        *Overload 2:*
        Clones the given expression list.

        Note that referenced DB elements, e.g., resources in constant expressions, or function calls
        and material instances in call expressions, are not copied, but shared.
        """
        return _pymdlsdk._IExpression_factory_clone(self, *args)

    def compare(self, *args):
        r"""
        *Overload 1:*
        Compares two instances of #mi::neuraylib::IExpression.

        The comparison operator for instances of #mi::neuraylib::IExpression is defined as follows:
        - If ``lhs`` or ``rhs`` is ``NULL``, the result is the lexicographic comparison of
          the pointer addresses themselves.
        - Otherwise, the types of ``lhs`` and ``rhs`` are compared. If they are different, the result
          is determined by that comparison.
        - Next, the kind of the expressions are compared. If they are different, the result is
          determined by ``operator``< on the #mi::neuraylib::IExpression::Kind values.
        - Finally, the expressions are compared as follows:
          - For constants the results is defined by comparing their values.
          - For calls the result is defined by ``strcmp()`` on the names of the referenced DB
            elements.
          - For parameter and temporary references, the results is defined by ``operator``<() on the
            indices.

        :type lhs: :py:class:`IExpression`
        :param lhs:          The left-hand side operand for the comparison.
        :type rhs: :py:class:`IExpression`
        :param rhs:          The right-hand side operand for the comparison.
        :rtype: int
        :return: -1 if ``lhs`` < ``rhs``, 0 if ``lhs`` == ``rhs``, and +1 if ``lhs`` > ``rhs``.

        |

        *Overload 2:*
        Compares two instances of #mi::neuraylib::IExpression_list.

        The comparison operator for instances of #mi::neuraylib::IExpression_list is defined as
        follows:
        - If ``lhs`` or ``rhs`` is ``NULL``, the result is the lexicographic comparison of
          the pointer addresses themselves.
        - Next, the list sizes are compared using ``operator``<().
        - Next, the lists are traversed by increasing index and the names are compared using
          ``strcmp()``.
        - Finally, the list elements are enumerated by increasing index and the expressions are
          compared.

        :type lhs: :py:class:`IExpression_list`
        :param lhs:          The left-hand side operand for the comparison.
        :type rhs: :py:class:`IExpression_list`
        :param rhs:          The right-hand side operand for the comparison.
        :rtype: int
        :return: -1 if ``lhs`` < ``rhs``, 0 if ``lhs`` == ``rhs``, and +1 if ``lhs`` > ``rhs``.
        """
        return _pymdlsdk._IExpression_factory_compare(self, *args)

    def dump(self, *args):
        r"""
        *Overload 1:*
         Returns a textual representation of an expression.

         The parameter ``depth`` is only relevant for constants, where the argument is passed to
         #mi::neuraylib::IValue_factory::dump().

         Notes: The exact format of the textual representation is unspecified and might change in
               future releases. The textual representation is primarily meant as a debugging aid. Do
               *not* base application logic on it.

        |

        *Overload 2:*
         Returns a textual representation of an expression list.

         The representation of the expression list will contain line breaks. Subsequent lines have a
         suitable indentation. The assumed indentation level of the first line is specified by
        ``depth``.

         Notes: The exact format of the textual representation is unspecified and might change in
               future releases. The textual representation is primarily meant as a debugging aid. Do
               *not* base application logic on it.

        |

        *Overload 3:*
         Returns a textual representation of an expression list.

         The representation of the expression list will contain line breaks. Subsequent lines have a
         suitable indentation. The assumed indentation level of the first line is specified by
        ``depth``.

         Notes: The exact format of the textual representation is unspecified and might change in
               future releases. The textual representation is primarily meant as a debugging aid. Do
               *not* base application logic on it.

        |

        *Overload 4:*
         Returns a textual representation of an annotation.

         The representation of the annotation will contain line breaks. Subsequent lines have a
         suitable indentation. The assumed indentation level of the first line is specified by
        ``depth``.

         Notes: The exact format of the textual representation is unspecified and might change in
               future releases. The textual representation is primarily meant as a debugging aid. Do
               *not* base application logic on it.

        |

        *Overload 5:*
         Returns a textual representation of an annotation.

         The representation of the annotation will contain line breaks. Subsequent lines have a
         suitable indentation. The assumed indentation level of the first line is specified by
        ``depth``.

         Notes: The exact format of the textual representation is unspecified and might change in
               future releases. The textual representation is primarily meant as a debugging aid. Do
               *not* base application logic on it.

        |

        *Overload 6:*
         Returns a textual representation of an annotation block.

         The representation of the annotation block will contain line breaks. Subsequent lines have a
         suitable indentation. The assumed indentation level of the first line is specified by
        ``depth``.

         Notes: The exact format of the textual representation is unspecified and might change in
               future releases. The textual representation is primarily meant as a debugging aid. Do
               *not* base application logic on it.

        |

        *Overload 7:*
         Returns a textual representation of an annotation block.

         The representation of the annotation block will contain line breaks. Subsequent lines have a
         suitable indentation. The assumed indentation level of the first line is specified by
        ``depth``.

         Notes: The exact format of the textual representation is unspecified and might change in
               future releases. The textual representation is primarily meant as a debugging aid. Do
               *not* base application logic on it.

        |

        *Overload 8:*
         Returns a textual representation of an annotation list.

         The representation of the annotation list will contain line breaks. Subsequent lines have a
         suitable indentation. The assumed indentation level of the first line is specified by
        ``depth``.

         Notes: The exact format of the textual representation is unspecified and might change in
               future releases. The textual representation is primarily meant as a debugging aid. Do
               *not* base application logic on it.

        |

        *Overload 9:*
         Returns a textual representation of an annotation list.

         The representation of the annotation list will contain line breaks. Subsequent lines have a
         suitable indentation. The assumed indentation level of the first line is specified by
        ``depth``.

         Notes: The exact format of the textual representation is unspecified and might change in
               future releases. The textual representation is primarily meant as a debugging aid. Do
               *not* base application logic on it.
        """
        return _pymdlsdk._IExpression_factory_dump(self, *args)

    def create_cast_with_ret(self, src_expr, target_type, cast_db_name, force_cast):
        r"""
        Returns an expression which casts the source expression to the ``target_type``.

        This is a convenience function that creates an instance of the cast operator with
        the necessary arguments, stores it in the database and creates and returns an
        #mi::neuraylib::IExpression_call using the just created function. If ``force_cast`` is
        set to ``true``, the cast will always be inserted, even if the types match. If ``force_cast``
        is set to ``false``, the original expression is returned for identical types.
        If the type of ``src_expr`` and ``target_type`` are not compatible, ``NULL`` is returned.

        :type src_expr: :py:class:`IExpression`
        :param src_expr:     The expression whose type is supposed to be casted.
        :type target_type: :py:class:`IType`
        :param target_type:  The result type of the cast.
        :type cast_db_name: string
        :param cast_db_name: This name is used when storing the instance
                                of the cast-operator function into the database. If the name is already
                                taken by another DB element, this string will be used as the base for
                                generating a unique name. If NULL, a unique name is generated.
        :type force_cast: boolean
        :param force_cast:   If true, the cast will be created even if the types are
                                identical. Please note that a cast cannot be forced for
                                incompatible types.
        :type errors: int, optional
        :param errors:       An optional pointer to an #mi::Sint32 to which an error code will be
                                written. The error codes have the following meaning:
                                - 0: Success.
                                - 1: Invalid parameters (``NULL`` pointer).
                                - 2: The type of ``src_expr`` cannot be cast to ``target_type``.

        :rtype: :py:class:`IExpression`
        :return: The resulting expression or ``NULL`` in case of failure.
        """
        return _pymdlsdk._IExpression_factory_create_cast_with_ret(self, src_expr, target_type, cast_db_name, force_cast)

    def create_cast(self, src_expr, target_type, cast_db_name, force_cast):
        r"""
        Returns an expression which casts the source expression to the ``target_type``.

        This is a convenience function that creates an instance of the cast operator with
        the necessary arguments, stores it in the database and creates and returns an
        #mi::neuraylib::IExpression_call using the just created function. If ``force_cast`` is
        set to ``true``, the cast will always be inserted, even if the types match. If ``force_cast``
        is set to ``false``, the original expression is returned for identical types.
        If the type of ``src_expr`` and ``target_type`` are not compatible, ``NULL`` is returned.

        :type src_expr: :py:class:`IExpression`
        :param src_expr:     The expression whose type is supposed to be casted.
        :type target_type: :py:class:`IType`
        :param target_type:  The result type of the cast.
        :type cast_db_name: string
        :param cast_db_name: This name is used when storing the instance
                                of the cast-operator function into the database. If the name is already
                                taken by another DB element, this string will be used as the base for
                                generating a unique name. If NULL, a unique name is generated.
        :type force_cast: boolean
        :param force_cast:   If true, the cast will be created even if the types are
                                identical. Please note that a cast cannot be forced for
                                incompatible types.
        :param errors:       An optional pointer to an #mi::Sint32 to which an error code will be
                                written. The error codes have the following meaning:
                                - 0: Success.
                                - 1: Invalid parameters (``NULL`` pointer).
                                - 2: The type of ``src_expr`` cannot be cast to ``target_type``.

        :rtype: :py:class:`IExpression`
        :return: The resulting expression or ``NULL`` in case of failure.
        """
        return _pymdlsdk._IExpression_factory_create_cast(self, src_expr, target_type, cast_db_name, force_cast)

# Register _IExpression_factory in _pymdlsdk:
_pymdlsdk._IExpression_factory_swigregister(_IExpression_factory)

class Interface_declare_IFunction_call(_IScene_element):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IFunction_call_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IFunction_call

# Register Interface_declare_IFunction_call in _pymdlsdk:
_pymdlsdk.Interface_declare_IFunction_call_swigregister(Interface_declare_IFunction_call)

def Interface_declare_IFunction_call_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IFunction_call_compare_iid(iid)

class _IFunction_call(Interface_declare_IFunction_call):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_function_definition(self):
        r"""
        Returns the DB name of the corresponding function definition.

        The type of the function definition is #mi::neuraylib::IFunction_definition.

        Notes: The DB name of the function definition is different from its MDL name (see
              #get_mdl_function_definition()).
        """
        return _pymdlsdk._IFunction_call_get_function_definition(self)

    def get_mdl_function_definition(self):
        r"""
        Returns the MDL name of the corresponding function definition.

        Notes: The MDL name of the function definition is different from the name of the DB element
              (see #get_function_definition()).
        """
        return _pymdlsdk._IFunction_call_get_mdl_function_definition(self)

    def is_material(self):
        r"""
        Indicates whether the call represents a material instance.

        If materials-are-functions is enabled, then this method returns ``true`` iff
        #mi::neuraylib::IFunction_call::get_interface<mi::neuraylib::IMaterial_instance>()
        succeeds. Otherwise, this method always returns ``false``.

        See also: #mi::neuraylib::IMdl_configuration::set_materials_are_functions().
        """
        return _pymdlsdk._IFunction_call_is_material(self)

    def is_array_constructor(self):
        r"""
        Indicates whether this call is an instance of the array constructor.

        See also: 'mi_neuray_mdl_arrays'
        """
        return _pymdlsdk._IFunction_call_is_array_constructor(self)

    def get_return_type(self):
        r""" Returns the return type of the corresponding function definition."""
        return _pymdlsdk._IFunction_call_get_return_type(self)

    def get_parameter_count(self):
        r""" Returns the number of parameters."""
        return _pymdlsdk._IFunction_call_get_parameter_count(self)

    def get_parameter_name(self, index):
        r"""
        Returns the name of the parameter at ``index``.

        :type index: int
        :param index:        The index of the parameter.
        :rtype: string
        :return: The name of the parameter, or ``NULL`` if ``index`` is out of range.
        """
        return _pymdlsdk._IFunction_call_get_parameter_name(self, index)

    def get_parameter_index(self, name):
        r"""
        Returns the index position of a parameter.

        :type name: string
        :param name:         The name of the parameter.
        :rtype: int
        :return: The index of the parameter, or -1 if ``name`` is invalid.
        """
        return _pymdlsdk._IFunction_call_get_parameter_index(self, name)

    def get_parameter_types(self):
        r""" Returns the types of all parameters."""
        return _pymdlsdk._IFunction_call_get_parameter_types(self)

    def get_arguments(self):
        r""" Returns all arguments."""
        return _pymdlsdk._IFunction_call_get_arguments(self)

    def set_arguments(self, arguments):
        r"""
        Sets multiple arguments.

        :type arguments: :py:class:`IExpression_list`
        :param arguments:    The arguments. Note that the expressions are copied. This copy operation
                                is a shallow copy, e.g., DB elements referenced in call expressions are
                                *not* copied.
        :rtype: int
        :return: 
                                -  0: Success.
                                - -1: Invalid parameters (``NULL`` pointer).
                                - -2: One of the parameters in ``arguments`` does not exist.
                                - -3: One of the argument types does not match the corresponding
                                      parameter type.
                                - -4: The function call is immutable (because it appears in a default of
                                      a function or material definition).
                                - -5: One of the parameter types is uniform, but the corresponding
                                      argument type is varying.
                                - -6: One of the arguments is not a constant nor a call.
                                - -7: One of the arguments contains references to DB elements in a scope
                                      that is more private scope than the scope of this material
                                      instance.
                                - -8: One of the parameter types is uniform, but the corresponding
                                      argument is a call expression and the return type of the
                                      called function definition is effectively varying since the
                                      function definition itself is varying.
        """
        return _pymdlsdk._IFunction_call_set_arguments(self, arguments)

    def set_argument(self, *args):
        r"""
        *Overload 1:*
        Sets the argument at ``index``.

        :type index: int
        :param index:        The index of the argument.
        :type argument: :py:class:`IExpression`
        :param argument:     The argument. Note that the expression is copied. This copy operation
                                is a shallow copy, e.g., DB elements referenced in call expressions are
                                *not* copied.
        :rtype: int
        :return: 
                                -  0: Success.
                                - -1: Invalid parameters (``NULL`` pointer).
                                - -2: Parameter ``index`` does not exist.
                                - -3: The argument type does not match the parameter type.
                                - -4: The function call is immutable (because it appears in a default of
                                      a function or material definition).
                                - -5: The parameter type is uniform, but the argument type is varying.
                                - -6: The argument expression is not a constant nor a call.
                                - -7: The argument contains references to DB elements in a scope that is
                                      more private scope than the scope of this material instance.
                                - -8: The parameter types is uniform, but the argument is a call
                                      expression and the return type of the called function definition
                                      is effectively varying since the function definition itself is
                                      varying.

        |

        *Overload 2:*
        Sets an argument identified by name.

        :type name: string
        :param name:         The name of the parameter.
        :type argument: :py:class:`IExpression`
        :param argument:     The argument. Note that the expression is copied. This copy operation
                                is a shallow copy, e.g., DB elements referenced in call expressions are
                                *not* copied.
        :rtype: int
        :return: 
                                -  0: Success.
                                - -1: Invalid parameters (``NULL`` pointer).
                                - -2: Parameter ``name`` does not exist.
                                - -3: The argument type does not match the parameter type.
                                - -4: The function call is immutable (because it appears in a default of
                                      a function or material definition).
                                - -5: The parameter type is uniform, but the argument type is varying.
                                - -6: The argument expression is not a constant nor a call.
                                - -7: The argument contains references to DB elements in a scope that is
                                      more private scope than the scope of this material instance.
                                - -8: The parameter types is uniform, but the argument is a call
                                      expression and the return type of the called function definition
                                      is effectively varying since the function definition itself is
                                      varying.
        """
        return _pymdlsdk._IFunction_call_set_argument(self, *args)

    def is_default(self):
        r"""
        Indicates, if this function call acts as a default argument of a material or function
        definition.

        Defaults are immutable, their arguments cannot be changed and they cannot be used
        in call expressions.

        :rtype: boolean
        :return: true, if this function call is a default, false otherwise.
        """
        return _pymdlsdk._IFunction_call_is_default(self)

    def is_valid(self, context):
        r"""
        Returns ``true`` if this function call and all its arguments point to valid
        material and function definitions, ``false`` otherwise.

        Material and function definitions can become invalid due to a module reload.

        See also: #mi::neuraylib::IModule::reload(), #mi::neuraylib::IMaterial_instance::repair()

        :type context: :py:class:`IMdl_execution_context`
        :param context:  Execution context that can be queried for error messages
                            after the operation has finished. Can be ``NULL``.
        :rtype: boolean
        :return: 
                 - ``true``:  The instance is valid.
                 - ``false``: The instance is invalid.
        """
        return _pymdlsdk._IFunction_call_is_valid(self, context)

    def repair(self, flags, context):
        r"""
        Attempts to repair an invalid function call.

        :type flags: int
        :param flags:    Repair options, see #mi::neuraylib::Mdl_repair_options.
        :type context: :py:class:`IMdl_execution_context`
        :param context:  Execution context that can be queried for error messages
                            after the operation has finished. Can be ``NULL``.
        :rtype: int
        :return: 
                -   0:   Success.
                -  -1:   Repair failed. Check the ``context`` for details.
        """
        return _pymdlsdk._IFunction_call_repair(self, flags, context)

# Register _IFunction_call in _pymdlsdk:
_pymdlsdk._IFunction_call_swigregister(_IFunction_call)

class Interface_declare_IFunction_definition(_IScene_element):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IFunction_definition_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IFunction_definition

# Register Interface_declare_IFunction_definition in _pymdlsdk:
_pymdlsdk.Interface_declare_IFunction_definition_swigregister(Interface_declare_IFunction_definition)

def Interface_declare_IFunction_definition_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IFunction_definition_compare_iid(iid)

class _IFunction_definition(Interface_declare_IFunction_definition):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    DS_UNKNOWN = _pymdlsdk._IFunction_definition_DS_UNKNOWN
    r""" Unknown semantics."""
    DS_CONV_CONSTRUCTOR = _pymdlsdk._IFunction_definition_DS_CONV_CONSTRUCTOR
    r""" The conversion constructor."""
    DS_ELEM_CONSTRUCTOR = _pymdlsdk._IFunction_definition_DS_ELEM_CONSTRUCTOR
    r""" The elemental constructor."""
    DS_COLOR_SPECTRUM_CONSTRUCTOR = _pymdlsdk._IFunction_definition_DS_COLOR_SPECTRUM_CONSTRUCTOR
    r""" The color from spectrum constructor."""
    DS_MATRIX_ELEM_CONSTRUCTOR = _pymdlsdk._IFunction_definition_DS_MATRIX_ELEM_CONSTRUCTOR
    r""" The matrix elemental constructor."""
    DS_MATRIX_DIAG_CONSTRUCTOR = _pymdlsdk._IFunction_definition_DS_MATRIX_DIAG_CONSTRUCTOR
    r""" The matrix diagonal constructor."""
    DS_INVALID_REF_CONSTRUCTOR = _pymdlsdk._IFunction_definition_DS_INVALID_REF_CONSTRUCTOR
    r""" The invalid reference constructor."""
    DS_DEFAULT_STRUCT_CONSTRUCTOR = _pymdlsdk._IFunction_definition_DS_DEFAULT_STRUCT_CONSTRUCTOR
    r""" The default constructor for a struct."""
    DS_TEXTURE_CONSTRUCTOR = _pymdlsdk._IFunction_definition_DS_TEXTURE_CONSTRUCTOR
    r""" The texture constructor."""
    DS_CONV_OPERATOR = _pymdlsdk._IFunction_definition_DS_CONV_OPERATOR
    r""" The type conversion operator."""
    DS_COPY_CONSTRUCTOR = _pymdlsdk._IFunction_definition_DS_COPY_CONSTRUCTOR
    r""" The copy constructor."""
    DS_OPERATOR_FIRST = _pymdlsdk._IFunction_definition_DS_OPERATOR_FIRST
    DS_UNARY_FIRST = _pymdlsdk._IFunction_definition_DS_UNARY_FIRST
    DS_BITWISE_COMPLEMENT = _pymdlsdk._IFunction_definition_DS_BITWISE_COMPLEMENT
    r""" The bitwise complement operator."""
    DS_LOGICAL_NOT = _pymdlsdk._IFunction_definition_DS_LOGICAL_NOT
    r""" The unary logical negation operator."""
    DS_POSITIVE = _pymdlsdk._IFunction_definition_DS_POSITIVE
    r""" The unary arithmetic positive operator."""
    DS_NEGATIVE = _pymdlsdk._IFunction_definition_DS_NEGATIVE
    r""" The unary arithmetic negation operator."""
    DS_PRE_INCREMENT = _pymdlsdk._IFunction_definition_DS_PRE_INCREMENT
    r""" The pre-increment operator."""
    DS_PRE_DECREMENT = _pymdlsdk._IFunction_definition_DS_PRE_DECREMENT
    r""" The pre-decrement operator."""
    DS_POST_INCREMENT = _pymdlsdk._IFunction_definition_DS_POST_INCREMENT
    r""" The post-increment operator."""
    DS_POST_DECREMENT = _pymdlsdk._IFunction_definition_DS_POST_DECREMENT
    r""" The post-decrement operator."""
    DS_CAST = _pymdlsdk._IFunction_definition_DS_CAST
    r""" The cast operator. See 'mi_neuray_mdl_cast_operator'."""
    DS_UNARY_LAST = _pymdlsdk._IFunction_definition_DS_UNARY_LAST
    DS_BINARY_FIRST = _pymdlsdk._IFunction_definition_DS_BINARY_FIRST
    DS_SELECT = _pymdlsdk._IFunction_definition_DS_SELECT
    r""" The select operator."""
    DS_ARRAY_INDEX = _pymdlsdk._IFunction_definition_DS_ARRAY_INDEX
    r""" The array index operator. See 'mi_neuray_mdl_array_index_operator'."""
    DS_MULTIPLY = _pymdlsdk._IFunction_definition_DS_MULTIPLY
    r""" The multiplication operator."""
    DS_DIVIDE = _pymdlsdk._IFunction_definition_DS_DIVIDE
    r""" The division operator."""
    DS_MODULO = _pymdlsdk._IFunction_definition_DS_MODULO
    r""" The modulus operator."""
    DS_PLUS = _pymdlsdk._IFunction_definition_DS_PLUS
    r""" The addition operator."""
    DS_MINUS = _pymdlsdk._IFunction_definition_DS_MINUS
    r""" The subtraction operator."""
    DS_SHIFT_LEFT = _pymdlsdk._IFunction_definition_DS_SHIFT_LEFT
    r""" The shift-left operator."""
    DS_SHIFT_RIGHT = _pymdlsdk._IFunction_definition_DS_SHIFT_RIGHT
    r""" The arithmetic shift-right operator."""
    DS_UNSIGNED_SHIFT_RIGHT = _pymdlsdk._IFunction_definition_DS_UNSIGNED_SHIFT_RIGHT
    r""" The unsigned shift-right operator."""
    DS_LESS = _pymdlsdk._IFunction_definition_DS_LESS
    r""" The less operator."""
    DS_LESS_OR_EQUAL = _pymdlsdk._IFunction_definition_DS_LESS_OR_EQUAL
    r""" The less-or-equal operator."""
    DS_GREATER_OR_EQUAL = _pymdlsdk._IFunction_definition_DS_GREATER_OR_EQUAL
    r""" The greater-or-equal operator."""
    DS_GREATER = _pymdlsdk._IFunction_definition_DS_GREATER
    r""" The greater operator."""
    DS_EQUAL = _pymdlsdk._IFunction_definition_DS_EQUAL
    r""" The equal operator."""
    DS_NOT_EQUAL = _pymdlsdk._IFunction_definition_DS_NOT_EQUAL
    r""" The not-equal operator."""
    DS_BITWISE_AND = _pymdlsdk._IFunction_definition_DS_BITWISE_AND
    r""" The bitwise and operator."""
    DS_BITWISE_XOR = _pymdlsdk._IFunction_definition_DS_BITWISE_XOR
    r""" The bitwise xor operator."""
    DS_BITWISE_OR = _pymdlsdk._IFunction_definition_DS_BITWISE_OR
    r""" The bitwise or operator."""
    DS_LOGICAL_AND = _pymdlsdk._IFunction_definition_DS_LOGICAL_AND
    r""" The logical and operator."""
    DS_LOGICAL_OR = _pymdlsdk._IFunction_definition_DS_LOGICAL_OR
    r""" The logical or operator."""
    DS_ASSIGN = _pymdlsdk._IFunction_definition_DS_ASSIGN
    r""" The assign operator."""
    DS_MULTIPLY_ASSIGN = _pymdlsdk._IFunction_definition_DS_MULTIPLY_ASSIGN
    r""" The multiplication-assign operator."""
    DS_DIVIDE_ASSIGN = _pymdlsdk._IFunction_definition_DS_DIVIDE_ASSIGN
    r""" The division-assign operator."""
    DS_MODULO_ASSIGN = _pymdlsdk._IFunction_definition_DS_MODULO_ASSIGN
    r""" The modulus-assign operator."""
    DS_PLUS_ASSIGN = _pymdlsdk._IFunction_definition_DS_PLUS_ASSIGN
    r""" The plus-assign operator."""
    DS_MINUS_ASSIGN = _pymdlsdk._IFunction_definition_DS_MINUS_ASSIGN
    r""" The minus-assign operator."""
    DS_SHIFT_LEFT_ASSIGN = _pymdlsdk._IFunction_definition_DS_SHIFT_LEFT_ASSIGN
    r""" The shift-left-assign operator."""
    DS_SHIFT_RIGHT_ASSIGN = _pymdlsdk._IFunction_definition_DS_SHIFT_RIGHT_ASSIGN
    r""" The arithmetic shift-right-assign operator."""
    DS_UNSIGNED_SHIFT_RIGHT_ASSIGN = _pymdlsdk._IFunction_definition_DS_UNSIGNED_SHIFT_RIGHT_ASSIGN
    r""" The unsigned shift-right-assign operator."""
    DS_BITWISE_OR_ASSIGN = _pymdlsdk._IFunction_definition_DS_BITWISE_OR_ASSIGN
    r""" The bitwise or-assign operator."""
    DS_BITWISE_XOR_ASSIGN = _pymdlsdk._IFunction_definition_DS_BITWISE_XOR_ASSIGN
    r""" The bitwise xor-assign operator."""
    DS_BITWISE_AND_ASSIGN = _pymdlsdk._IFunction_definition_DS_BITWISE_AND_ASSIGN
    r""" The bitwise and-assign operator."""
    DS_SEQUENCE = _pymdlsdk._IFunction_definition_DS_SEQUENCE
    r""" The comma operator."""
    DS_BINARY_LAST = _pymdlsdk._IFunction_definition_DS_BINARY_LAST
    DS_TERNARY = _pymdlsdk._IFunction_definition_DS_TERNARY
    r""" The ternary operator (conditional). See 'mi_neuray_mdl_ternary_operator'."""
    DS_OPERATOR_LAST = _pymdlsdk._IFunction_definition_DS_OPERATOR_LAST
    DS_INTRINSIC_MATH_FIRST = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_FIRST
    DS_INTRINSIC_MATH_ABS = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_ABS
    r""" The %math::abs() intrinsic function."""
    DS_INTRINSIC_MATH_ACOS = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_ACOS
    r""" The %math::acos() intrinsic function."""
    DS_INTRINSIC_MATH_ALL = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_ALL
    r""" The %math::all() intrinsic function."""
    DS_INTRINSIC_MATH_ANY = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_ANY
    r""" The %math::any() intrinsic function."""
    DS_INTRINSIC_MATH_ASIN = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_ASIN
    r""" The %math::asin() intrinsic function."""
    DS_INTRINSIC_MATH_ATAN = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_ATAN
    r""" The %math::atan() intrinsic function."""
    DS_INTRINSIC_MATH_ATAN2 = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_ATAN2
    r""" The %math::atan2() intrinsic function."""
    DS_INTRINSIC_MATH_AVERAGE = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_AVERAGE
    r""" The %math::average() intrinsic function."""
    DS_INTRINSIC_MATH_CEIL = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_CEIL
    r""" The %math::ceil() intrinsic function."""
    DS_INTRINSIC_MATH_CLAMP = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_CLAMP
    r""" The %math::clamp() intrinsic function."""
    DS_INTRINSIC_MATH_COS = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_COS
    r""" The %math::cos() intrinsic function."""
    DS_INTRINSIC_MATH_CROSS = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_CROSS
    r""" The %math::cross() intrinsic function."""
    DS_INTRINSIC_MATH_DEGREES = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_DEGREES
    r""" The %math::degrees() intrinsic function."""
    DS_INTRINSIC_MATH_DISTANCE = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_DISTANCE
    r""" The %math::distance() intrinsic function."""
    DS_INTRINSIC_MATH_DOT = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_DOT
    r""" The %math::dot() intrinsic function."""
    DS_INTRINSIC_MATH_EVAL_AT_WAVELENGTH = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_EVAL_AT_WAVELENGTH
    r""" The %math::eval_at_wavelength() intrinsic function."""
    DS_INTRINSIC_MATH_EXP = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_EXP
    r""" The %math::exp() intrinsic function."""
    DS_INTRINSIC_MATH_EXP2 = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_EXP2
    r""" The %math::exp2() intrinsic function."""
    DS_INTRINSIC_MATH_FLOOR = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_FLOOR
    r""" The %math::floor() intrinsic function."""
    DS_INTRINSIC_MATH_FMOD = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_FMOD
    r""" The %math::fmod() intrinsic function."""
    DS_INTRINSIC_MATH_FRAC = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_FRAC
    r""" The %math::frac() intrinsic function."""
    DS_INTRINSIC_MATH_ISNAN = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_ISNAN
    r""" The %math::isnan() intrinsic function."""
    DS_INTRINSIC_MATH_ISFINITE = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_ISFINITE
    r""" The %math::isfinite() intrinsic function."""
    DS_INTRINSIC_MATH_LENGTH = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_LENGTH
    r""" The %math::length() intrinsic function."""
    DS_INTRINSIC_MATH_LERP = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_LERP
    r""" The %math::lerp() intrinsic function."""
    DS_INTRINSIC_MATH_LOG = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_LOG
    r""" The %math::log() intrinsic function."""
    DS_INTRINSIC_MATH_LOG2 = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_LOG2
    r""" The %math::log2() intrinsic function."""
    DS_INTRINSIC_MATH_LOG10 = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_LOG10
    r""" The %math::log10() intrinsic function."""
    DS_INTRINSIC_MATH_LUMINANCE = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_LUMINANCE
    r""" The %math::luminance() intrinsic function."""
    DS_INTRINSIC_MATH_MAX = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_MAX
    r""" The %math::max() intrinsic function."""
    DS_INTRINSIC_MATH_MAX_VALUE = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_MAX_VALUE
    r""" The %math::max_value() intrinsic function."""
    DS_INTRINSIC_MATH_MAX_VALUE_WAVELENGTH = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_MAX_VALUE_WAVELENGTH
    r""" The %math::max_value_wavelength() intrinsic function."""
    DS_INTRINSIC_MATH_MIN = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_MIN
    r""" The %math::min() intrinsic function."""
    DS_INTRINSIC_MATH_MIN_VALUE = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_MIN_VALUE
    r""" The %math::min_value() intrinsic function."""
    DS_INTRINSIC_MATH_MIN_VALUE_WAVELENGTH = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_MIN_VALUE_WAVELENGTH
    r""" The %math::min_value_wavelength() intrinsic function."""
    DS_INTRINSIC_MATH_MODF = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_MODF
    r""" The %math::modf() intrinsic function."""
    DS_INTRINSIC_MATH_NORMALIZE = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_NORMALIZE
    r""" The %math::normalize() intrinsic function."""
    DS_INTRINSIC_MATH_POW = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_POW
    r""" The %math::pow() intrinsic function."""
    DS_INTRINSIC_MATH_RADIANS = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_RADIANS
    r""" The %math::radians() intrinsic function."""
    DS_INTRINSIC_MATH_ROUND = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_ROUND
    r""" The %math::round() intrinsic function."""
    DS_INTRINSIC_MATH_RSQRT = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_RSQRT
    r""" The %math::rsqrt() intrinsic function."""
    DS_INTRINSIC_MATH_SATURATE = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_SATURATE
    r""" The %math::saturate() intrinsic function."""
    DS_INTRINSIC_MATH_SIGN = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_SIGN
    r""" The %math::sign() intrinsic function."""
    DS_INTRINSIC_MATH_SIN = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_SIN
    r""" The %math::sin() intrinsic function."""
    DS_INTRINSIC_MATH_SINCOS = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_SINCOS
    r""" The %math::sincos() intrinsic function."""
    DS_INTRINSIC_MATH_SMOOTHSTEP = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_SMOOTHSTEP
    r""" The %math::smoothstep() intrinsic function."""
    DS_INTRINSIC_MATH_SQRT = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_SQRT
    r""" The %math::sqrt() intrinsic function."""
    DS_INTRINSIC_MATH_STEP = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_STEP
    r""" The %math::step() intrinsic function."""
    DS_INTRINSIC_MATH_TAN = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_TAN
    r""" The %math::tan() intrinsic function."""
    DS_INTRINSIC_MATH_TRANSPOSE = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_TRANSPOSE
    r""" The %math::transpose() intrinsic function."""
    DS_INTRINSIC_MATH_BLACKBODY = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_BLACKBODY
    r""" The %math::blackbody() intrinsic function."""
    DS_INTRINSIC_MATH_EMISSION_COLOR = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_EMISSION_COLOR
    r""" The %math::emission_color() intrinsic function."""
    DS_INTRINSIC_MATH_COSH = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_COSH
    r""" The %math::cosh() intrinsic function."""
    DS_INTRINSIC_MATH_SINH = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_SINH
    r""" The %math::sinh() intrinsic function."""
    DS_INTRINSIC_MATH_TANH = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_TANH
    r""" The %math::tanh() intrinsic function."""
    DS_INTRINSIC_MATH_INT_BITS_TO_FLOAT = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_INT_BITS_TO_FLOAT
    r""" The %math::int_bits_to_float() intrinsic"""
    DS_INTRINSIC_MATH_FLOAT_BITS_TO_INT = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_FLOAT_BITS_TO_INT
    r"""  function. The %math::float_bits_to_int() intrinsic"""
    DS_INTRINSIC_MATH_DX = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_DX
    r"""  function. The %math::DX() intrinsic function."""
    DS_INTRINSIC_MATH_DY = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_DY
    r""" The %math::DY() intrinsic function."""
    DS_INTRINSIC_MATH_LAST = _pymdlsdk._IFunction_definition_DS_INTRINSIC_MATH_LAST
    DS_INTRINSIC_STATE_FIRST = _pymdlsdk._IFunction_definition_DS_INTRINSIC_STATE_FIRST
    DS_INTRINSIC_STATE_POSITION = _pymdlsdk._IFunction_definition_DS_INTRINSIC_STATE_POSITION
    r""" The %state::position() function."""
    DS_INTRINSIC_STATE_NORMAL = _pymdlsdk._IFunction_definition_DS_INTRINSIC_STATE_NORMAL
    r""" The %state::normal() function."""
    DS_INTRINSIC_STATE_GEOMETRY_NORMAL = _pymdlsdk._IFunction_definition_DS_INTRINSIC_STATE_GEOMETRY_NORMAL
    r""" The %state::geometry_normal() function."""
    DS_INTRINSIC_STATE_MOTION = _pymdlsdk._IFunction_definition_DS_INTRINSIC_STATE_MOTION
    r""" The %state::motion() function."""
    DS_INTRINSIC_STATE_TEXTURE_SPACE_MAX = _pymdlsdk._IFunction_definition_DS_INTRINSIC_STATE_TEXTURE_SPACE_MAX
    r""" The %state::texture_space_max() function."""
    DS_INTRINSIC_STATE_TEXTURE_COORDINATE = _pymdlsdk._IFunction_definition_DS_INTRINSIC_STATE_TEXTURE_COORDINATE
    r""" The %state::texture_coordinate() function."""
    DS_INTRINSIC_STATE_TEXTURE_TANGENT_U = _pymdlsdk._IFunction_definition_DS_INTRINSIC_STATE_TEXTURE_TANGENT_U
    r""" The %state::texture_tangent_u() function."""
    DS_INTRINSIC_STATE_TEXTURE_TANGENT_V = _pymdlsdk._IFunction_definition_DS_INTRINSIC_STATE_TEXTURE_TANGENT_V
    r""" The %state::texture_tangent_v() function."""
    DS_INTRINSIC_STATE_TANGENT_SPACE = _pymdlsdk._IFunction_definition_DS_INTRINSIC_STATE_TANGENT_SPACE
    r""" The %state::tangent_space() function."""
    DS_INTRINSIC_STATE_GEOMETRY_TANGENT_U = _pymdlsdk._IFunction_definition_DS_INTRINSIC_STATE_GEOMETRY_TANGENT_U
    r""" The %state::geometry_tangent_u() function."""
    DS_INTRINSIC_STATE_GEOMETRY_TANGENT_V = _pymdlsdk._IFunction_definition_DS_INTRINSIC_STATE_GEOMETRY_TANGENT_V
    r""" The %state::geometry_tangent_v() function."""
    DS_INTRINSIC_STATE_DIRECTION = _pymdlsdk._IFunction_definition_DS_INTRINSIC_STATE_DIRECTION
    r""" The %state::direction() function."""
    DS_INTRINSIC_STATE_ANIMATION_TIME = _pymdlsdk._IFunction_definition_DS_INTRINSIC_STATE_ANIMATION_TIME
    r""" The %state::animation_time() function."""
    DS_INTRINSIC_STATE_WAVELENGTH_BASE = _pymdlsdk._IFunction_definition_DS_INTRINSIC_STATE_WAVELENGTH_BASE
    r""" The %state::wavelength_base() function."""
    DS_INTRINSIC_STATE_TRANSFORM = _pymdlsdk._IFunction_definition_DS_INTRINSIC_STATE_TRANSFORM
    r""" The %state::transform() function."""
    DS_INTRINSIC_STATE_TRANSFORM_POINT = _pymdlsdk._IFunction_definition_DS_INTRINSIC_STATE_TRANSFORM_POINT
    r""" The %state::transform_point() function."""
    DS_INTRINSIC_STATE_TRANSFORM_VECTOR = _pymdlsdk._IFunction_definition_DS_INTRINSIC_STATE_TRANSFORM_VECTOR
    r""" The %state::transform_vector() function."""
    DS_INTRINSIC_STATE_TRANSFORM_NORMAL = _pymdlsdk._IFunction_definition_DS_INTRINSIC_STATE_TRANSFORM_NORMAL
    r""" The %state::transform_normal() function."""
    DS_INTRINSIC_STATE_TRANSFORM_SCALE = _pymdlsdk._IFunction_definition_DS_INTRINSIC_STATE_TRANSFORM_SCALE
    r""" The %state::transform_scale() function."""
    DS_INTRINSIC_STATE_ROUNDED_CORNER_NORMAL = _pymdlsdk._IFunction_definition_DS_INTRINSIC_STATE_ROUNDED_CORNER_NORMAL
    r""" The %state::rounded_corner_normal() function."""
    DS_INTRINSIC_STATE_METERS_PER_SCENE_UNIT = _pymdlsdk._IFunction_definition_DS_INTRINSIC_STATE_METERS_PER_SCENE_UNIT
    r""" The %state::meters_per_scene_unit() function."""
    DS_INTRINSIC_STATE_SCENE_UNITS_PER_METER = _pymdlsdk._IFunction_definition_DS_INTRINSIC_STATE_SCENE_UNITS_PER_METER
    r""" The %state::scene_units_per_meter() function."""
    DS_INTRINSIC_STATE_OBJECT_ID = _pymdlsdk._IFunction_definition_DS_INTRINSIC_STATE_OBJECT_ID
    r""" The %state::object_id() function."""
    DS_INTRINSIC_STATE_WAVELENGTH_MIN = _pymdlsdk._IFunction_definition_DS_INTRINSIC_STATE_WAVELENGTH_MIN
    r""" The %state::wavelength_min() function."""
    DS_INTRINSIC_STATE_WAVELENGTH_MAX = _pymdlsdk._IFunction_definition_DS_INTRINSIC_STATE_WAVELENGTH_MAX
    r""" The %state::wavelength_max() function."""
    DS_INTRINSIC_STATE_LAST = _pymdlsdk._IFunction_definition_DS_INTRINSIC_STATE_LAST
    DS_INTRINSIC_TEX_FIRST = _pymdlsdk._IFunction_definition_DS_INTRINSIC_TEX_FIRST
    DS_INTRINSIC_TEX_WIDTH = _pymdlsdk._IFunction_definition_DS_INTRINSIC_TEX_WIDTH
    r""" The tex::width() function."""
    DS_INTRINSIC_TEX_HEIGHT = _pymdlsdk._IFunction_definition_DS_INTRINSIC_TEX_HEIGHT
    r""" The tex::height() function."""
    DS_INTRINSIC_TEX_DEPTH = _pymdlsdk._IFunction_definition_DS_INTRINSIC_TEX_DEPTH
    r""" The tex::depth() function."""
    DS_INTRINSIC_TEX_LOOKUP_FLOAT = _pymdlsdk._IFunction_definition_DS_INTRINSIC_TEX_LOOKUP_FLOAT
    r""" The tex::lookup_float() function."""
    DS_INTRINSIC_TEX_LOOKUP_FLOAT2 = _pymdlsdk._IFunction_definition_DS_INTRINSIC_TEX_LOOKUP_FLOAT2
    r""" The tex::lookup_float2() function."""
    DS_INTRINSIC_TEX_LOOKUP_FLOAT3 = _pymdlsdk._IFunction_definition_DS_INTRINSIC_TEX_LOOKUP_FLOAT3
    r""" The tex::lookup_float3() function."""
    DS_INTRINSIC_TEX_LOOKUP_FLOAT4 = _pymdlsdk._IFunction_definition_DS_INTRINSIC_TEX_LOOKUP_FLOAT4
    r""" The tex::lookup_float4() function."""
    DS_INTRINSIC_TEX_LOOKUP_COLOR = _pymdlsdk._IFunction_definition_DS_INTRINSIC_TEX_LOOKUP_COLOR
    r""" The tex::lookup_color() function."""
    DS_INTRINSIC_TEX_TEXEL_FLOAT = _pymdlsdk._IFunction_definition_DS_INTRINSIC_TEX_TEXEL_FLOAT
    r""" The tex::texel_float() function."""
    DS_INTRINSIC_TEX_TEXEL_FLOAT2 = _pymdlsdk._IFunction_definition_DS_INTRINSIC_TEX_TEXEL_FLOAT2
    r""" The tex::texel_float2() function."""
    DS_INTRINSIC_TEX_TEXEL_FLOAT3 = _pymdlsdk._IFunction_definition_DS_INTRINSIC_TEX_TEXEL_FLOAT3
    r""" The tex::texel_float3() function."""
    DS_INTRINSIC_TEX_TEXEL_FLOAT4 = _pymdlsdk._IFunction_definition_DS_INTRINSIC_TEX_TEXEL_FLOAT4
    r""" The tex::texel_float4() function."""
    DS_INTRINSIC_TEX_TEXEL_COLOR = _pymdlsdk._IFunction_definition_DS_INTRINSIC_TEX_TEXEL_COLOR
    r""" The tex::texel_color() function."""
    DS_INTRINSIC_TEX_TEXTURE_ISVALID = _pymdlsdk._IFunction_definition_DS_INTRINSIC_TEX_TEXTURE_ISVALID
    r""" The tex::texture_isvalid() function."""
    DS_INTRINSIC_TEX_WIDTH_OFFSET = _pymdlsdk._IFunction_definition_DS_INTRINSIC_TEX_WIDTH_OFFSET
    r""" The tex::width_offset() function."""
    DS_INTRINSIC_TEX_HEIGHT_OFFSET = _pymdlsdk._IFunction_definition_DS_INTRINSIC_TEX_HEIGHT_OFFSET
    r""" The tex::height_offset() function."""
    DS_INTRINSIC_TEX_DEPTH_OFFSET = _pymdlsdk._IFunction_definition_DS_INTRINSIC_TEX_DEPTH_OFFSET
    r""" The tex::depth_offset() function."""
    DS_INTRINSIC_TEX_FIRST_FRAME = _pymdlsdk._IFunction_definition_DS_INTRINSIC_TEX_FIRST_FRAME
    r""" The tex::first_frame() function."""
    DS_INTRINSIC_TEX_LAST_FRAME = _pymdlsdk._IFunction_definition_DS_INTRINSIC_TEX_LAST_FRAME
    r""" The tex::last_frame() function."""
    DS_INTRINSIC_TEX_GRID_TO_OBJECT_SPACE = _pymdlsdk._IFunction_definition_DS_INTRINSIC_TEX_GRID_TO_OBJECT_SPACE
    r""" The tex::grid_to_object_space() function."""
    DS_INTRINSIC_TEX_LAST = _pymdlsdk._IFunction_definition_DS_INTRINSIC_TEX_LAST
    DS_INTRINSIC_DF_FIRST = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_FIRST
    DS_INTRINSIC_DF_DIFFUSE_REFLECTION_BSDF = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_DIFFUSE_REFLECTION_BSDF
    r""" The df::diffuse_reflection_bsdf() function."""
    DS_INTRINSIC_DF_DIFFUSE_TRANSMISSION_BSDF = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_DIFFUSE_TRANSMISSION_BSDF
    r""" The df::diffuse_transmission_bsdf() function."""
    DS_INTRINSIC_DF_SPECULAR_BSDF = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_SPECULAR_BSDF
    r""" The df::specular_bsdf() function."""
    DS_INTRINSIC_DF_SIMPLE_GLOSSY_BSDF = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_SIMPLE_GLOSSY_BSDF
    r""" The df::simple_glossy_bsdf() function."""
    DS_INTRINSIC_DF_BACKSCATTERING_GLOSSY_REFLECTION_BSDF = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_BACKSCATTERING_GLOSSY_REFLECTION_BSDF
    r""" The df::backscattering_glossy_reflection_bsdf() function."""
    DS_INTRINSIC_DF_MEASURED_BSDF = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_MEASURED_BSDF
    r""" The df::measured_bsdf() function."""
    DS_INTRINSIC_DF_DIFFUSE_EDF = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_DIFFUSE_EDF
    r""" The df::diffuse_edf() function."""
    DS_INTRINSIC_DF_MEASURED_EDF = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_MEASURED_EDF
    r""" The df::measured_edf() function."""
    DS_INTRINSIC_DF_SPOT_EDF = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_SPOT_EDF
    r""" The df::spot_edf() function."""
    DS_INTRINSIC_DF_ANISOTROPIC_VDF = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_ANISOTROPIC_VDF
    r""" The df::anisotropic_vdf() function."""
    DS_INTRINSIC_DF_NORMALIZED_MIX = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_NORMALIZED_MIX
    r""" The df::normalized_mix() function."""
    DS_INTRINSIC_DF_CLAMPED_MIX = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_CLAMPED_MIX
    r""" The df::clamped_mix() function."""
    DS_INTRINSIC_DF_WEIGHTED_LAYER = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_WEIGHTED_LAYER
    r""" The df::weighted_layer() function."""
    DS_INTRINSIC_DF_FRESNEL_LAYER = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_FRESNEL_LAYER
    r""" The df::fresnel_layer() function."""
    DS_INTRINSIC_DF_CUSTOM_CURVE_LAYER = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_CUSTOM_CURVE_LAYER
    r""" The df::custom_curve_layer() function."""
    DS_INTRINSIC_DF_MEASURED_CURVE_LAYER = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_MEASURED_CURVE_LAYER
    r""" The df::measured_curve_layer() function."""
    DS_INTRINSIC_DF_THIN_FILM = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_THIN_FILM
    r""" The df::thin_film() function."""
    DS_INTRINSIC_DF_TINT = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_TINT
    r""" The df::tint() function."""
    DS_INTRINSIC_DF_DIRECTIONAL_FACTOR = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_DIRECTIONAL_FACTOR
    r""" The df::directional_factor() function."""
    DS_INTRINSIC_DF_MEASURED_CURVE_FACTOR = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_MEASURED_CURVE_FACTOR
    r""" The df::measured_curve_factor() function."""
    DS_INTRINSIC_DF_LIGHT_PROFILE_POWER = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_LIGHT_PROFILE_POWER
    r""" The df::light_profile_power() function."""
    DS_INTRINSIC_DF_LIGHT_PROFILE_MAXIMUM = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_LIGHT_PROFILE_MAXIMUM
    r""" The df::light_profile_maximum() function."""
    DS_INTRINSIC_DF_LIGHT_PROFILE_ISVALID = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_LIGHT_PROFILE_ISVALID
    r""" The df::light_profile_isvalid() function."""
    DS_INTRINSIC_DF_BSDF_MEASUREMENT_ISVALID = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_BSDF_MEASUREMENT_ISVALID
    r""" The df::bsdf_measurement_is_valid() function."""
    DS_INTRINSIC_DF_MICROFACET_BECKMANN_SMITH_BSDF = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_MICROFACET_BECKMANN_SMITH_BSDF
    r""" The df::microfacet_beckmann_smith_bsdf() function."""
    DS_INTRINSIC_DF_MICROFACET_GGX_SMITH_BSDF = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_MICROFACET_GGX_SMITH_BSDF
    r""" The df::microfacet_ggx_smith_bsdf() function."""
    DS_INTRINSIC_DF_MICROFACET_BECKMANN_VCAVITIES_BSDF = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_MICROFACET_BECKMANN_VCAVITIES_BSDF
    r""" The df::microfacet_beckmann_vcavities() function."""
    DS_INTRINSIC_DF_MICROFACET_GGX_VCAVITIES_BSDF = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_MICROFACET_GGX_VCAVITIES_BSDF
    r""" The df::microfacet_ggx_vcavities() function."""
    DS_INTRINSIC_DF_WARD_GEISLER_MORODER_BSDF = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_WARD_GEISLER_MORODER_BSDF
    r""" The df::ward_geisler_moroder_bsdf() function."""
    DS_INTRINSIC_DF_COLOR_NORMALIZED_MIX = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_COLOR_NORMALIZED_MIX
    r""" The df::color_normalized_mix() function."""
    DS_INTRINSIC_DF_COLOR_CLAMPED_MIX = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_COLOR_CLAMPED_MIX
    r""" The df::color_clamped_mix() function."""
    DS_INTRINSIC_DF_COLOR_WEIGHTED_LAYER = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_COLOR_WEIGHTED_LAYER
    r""" The df::color_weigthed_layer() function."""
    DS_INTRINSIC_DF_COLOR_FRESNEL_LAYER = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_COLOR_FRESNEL_LAYER
    r""" The df::color_fresnel_layer() function."""
    DS_INTRINSIC_DF_COLOR_CUSTOM_CURVE_LAYER = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_COLOR_CUSTOM_CURVE_LAYER
    r""" The df::color_custom_curve_layer() function."""
    DS_INTRINSIC_DF_COLOR_MEASURED_CURVE_LAYER = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_COLOR_MEASURED_CURVE_LAYER
    r""" The df::color_measured_curve_layer() function."""
    DS_INTRINSIC_DF_FRESNEL_FACTOR = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_FRESNEL_FACTOR
    r""" The df::fresnel_factor() function."""
    DS_INTRINSIC_DF_MEASURED_FACTOR = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_MEASURED_FACTOR
    r""" The df::measured_factor() function."""
    DS_INTRINSIC_DF_CHIANG_HAIR_BSDF = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_CHIANG_HAIR_BSDF
    r""" The df::chiang_hair_bsdf() function."""
    DS_INTRINSIC_DF_SHEEN_BSDF = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_SHEEN_BSDF
    r""" The df::sheen_bsdf() function."""
    DS_INTRINSIC_DF_UNBOUNDED_MIX = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_UNBOUNDED_MIX
    r""" The df::unbounded_mix() function."""
    DS_INTRINSIC_DF_COLOR_UNBOUNDED_MIX = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_COLOR_UNBOUNDED_MIX
    r""" The df::color_unbounded() function."""
    DS_INTRINSIC_DF_LAST = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DF_LAST
    DS_INTRINSIC_SCENE_FIRST = _pymdlsdk._IFunction_definition_DS_INTRINSIC_SCENE_FIRST
    DS_INTRINSIC_SCENE_DATA_ISVALID = _pymdlsdk._IFunction_definition_DS_INTRINSIC_SCENE_DATA_ISVALID
    DS_INTRINSIC_SCENE_DATA_LOOKUP_INT = _pymdlsdk._IFunction_definition_DS_INTRINSIC_SCENE_DATA_LOOKUP_INT
    r""" scene::data_lookup_int()"""
    DS_INTRINSIC_SCENE_DATA_LOOKUP_INT2 = _pymdlsdk._IFunction_definition_DS_INTRINSIC_SCENE_DATA_LOOKUP_INT2
    r""" scene::data_lookup_int2()"""
    DS_INTRINSIC_SCENE_DATA_LOOKUP_INT3 = _pymdlsdk._IFunction_definition_DS_INTRINSIC_SCENE_DATA_LOOKUP_INT3
    r""" scene::data_lookup_int3()"""
    DS_INTRINSIC_SCENE_DATA_LOOKUP_INT4 = _pymdlsdk._IFunction_definition_DS_INTRINSIC_SCENE_DATA_LOOKUP_INT4
    r""" scene::data_lookup_int4()"""
    DS_INTRINSIC_SCENE_DATA_LOOKUP_FLOAT = _pymdlsdk._IFunction_definition_DS_INTRINSIC_SCENE_DATA_LOOKUP_FLOAT
    r""" scene::data_lookup_float()"""
    DS_INTRINSIC_SCENE_DATA_LOOKUP_FLOAT2 = _pymdlsdk._IFunction_definition_DS_INTRINSIC_SCENE_DATA_LOOKUP_FLOAT2
    r""" scene::data_lookup_float2()"""
    DS_INTRINSIC_SCENE_DATA_LOOKUP_FLOAT3 = _pymdlsdk._IFunction_definition_DS_INTRINSIC_SCENE_DATA_LOOKUP_FLOAT3
    r""" scene::data_lookup_float3()"""
    DS_INTRINSIC_SCENE_DATA_LOOKUP_FLOAT4 = _pymdlsdk._IFunction_definition_DS_INTRINSIC_SCENE_DATA_LOOKUP_FLOAT4
    r""" scene::data_lookup_float4()"""
    DS_INTRINSIC_SCENE_DATA_LOOKUP_COLOR = _pymdlsdk._IFunction_definition_DS_INTRINSIC_SCENE_DATA_LOOKUP_COLOR
    r""" scene::data_lookup_color()"""
    DS_INTRINSIC_SCENE_DATA_LOOKUP_UNIFORM_INT = _pymdlsdk._IFunction_definition_DS_INTRINSIC_SCENE_DATA_LOOKUP_UNIFORM_INT
    r""" scene::data_lookup_uniorm_int()"""
    DS_INTRINSIC_SCENE_DATA_LOOKUP_UNIFORM_INT2 = _pymdlsdk._IFunction_definition_DS_INTRINSIC_SCENE_DATA_LOOKUP_UNIFORM_INT2
    r""" scene::data_lookup_uniorm_int2()"""
    DS_INTRINSIC_SCENE_DATA_LOOKUP_UNIFORM_INT3 = _pymdlsdk._IFunction_definition_DS_INTRINSIC_SCENE_DATA_LOOKUP_UNIFORM_INT3
    r""" scene::data_lookup_uniorm_int3()"""
    DS_INTRINSIC_SCENE_DATA_LOOKUP_UNIFORM_INT4 = _pymdlsdk._IFunction_definition_DS_INTRINSIC_SCENE_DATA_LOOKUP_UNIFORM_INT4
    r""" scene::data_lookup_uniorm_int4()"""
    DS_INTRINSIC_SCENE_DATA_LOOKUP_UNIFORM_FLOAT = _pymdlsdk._IFunction_definition_DS_INTRINSIC_SCENE_DATA_LOOKUP_UNIFORM_FLOAT
    r""" scene::data_lookup_uniorm_float()"""
    DS_INTRINSIC_SCENE_DATA_LOOKUP_UNIFORM_FLOAT2 = _pymdlsdk._IFunction_definition_DS_INTRINSIC_SCENE_DATA_LOOKUP_UNIFORM_FLOAT2
    r""" scene::data_lookup_uniorm_float2()"""
    DS_INTRINSIC_SCENE_DATA_LOOKUP_UNIFORM_FLOAT3 = _pymdlsdk._IFunction_definition_DS_INTRINSIC_SCENE_DATA_LOOKUP_UNIFORM_FLOAT3
    r""" scene::data_lookup_uniorm_float3()"""
    DS_INTRINSIC_SCENE_DATA_LOOKUP_UNIFORM_FLOAT4 = _pymdlsdk._IFunction_definition_DS_INTRINSIC_SCENE_DATA_LOOKUP_UNIFORM_FLOAT4
    r""" scene::data_lookup_uniorm_float4()"""
    DS_INTRINSIC_SCENE_DATA_LOOKUP_UNIFORM_COLOR = _pymdlsdk._IFunction_definition_DS_INTRINSIC_SCENE_DATA_LOOKUP_UNIFORM_COLOR
    r""" scene::data_lookup_uniorm_color()"""
    DS_INTRINSIC_SCENE_LAST = _pymdlsdk._IFunction_definition_DS_INTRINSIC_SCENE_LAST
    DS_INTRINSIC_DEBUG_FIRST = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DEBUG_FIRST
    DS_INTRINSIC_DEBUG_BREAKPOINT = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DEBUG_BREAKPOINT
    r""" The debug::breakpoint() function."""
    DS_INTRINSIC_DEBUG_ASSERT = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DEBUG_ASSERT
    r""" The debug::assert() function."""
    DS_INTRINSIC_DEBUG_PRINT = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DEBUG_PRINT
    r""" The debug::print() function."""
    DS_INTRINSIC_DEBUG_LAST = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DEBUG_LAST
    DS_INTRINSIC_DAG_FIRST = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DAG_FIRST
    DS_INTRINSIC_DAG_FIELD_ACCESS = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DAG_FIELD_ACCESS
    r""" The structure field access function."""
    DS_INTRINSIC_DAG_ARRAY_CONSTRUCTOR = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DAG_ARRAY_CONSTRUCTOR
    r""" The array constructor. See 'mi_neuray_mdl_array_constructor'."""
    DS_INTRINSIC_DAG_ARRAY_LENGTH = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DAG_ARRAY_LENGTH
    r""" The array length operator. See 'mi_neuray_mdl_array_length_operator'."""
    DS_INTRINSIC_DAG_LAST = _pymdlsdk._IFunction_definition_DS_INTRINSIC_DAG_LAST
    DS_FORCE_32_BIT = _pymdlsdk._IFunction_definition_DS_FORCE_32_BIT

    def get_module(self):
        r"""
        Returns the DB name of the module containing this function definition.

        The type of the module is #mi::neuraylib::IModule.
        """
        return _pymdlsdk._IFunction_definition_get_module(self)

    def get_mdl_name(self):
        r"""
        Returns the MDL name of the function definition.

        Notes: The MDL name of the function definition is different from the name of the DB element.
              Use #mi::neuraylib::ITransaction::name_of() to obtain the name of the DB element.

        :rtype: string
        :return: The MDL name of the function definition.
        """
        return _pymdlsdk._IFunction_definition_get_mdl_name(self)

    def get_mdl_module_name(self):
        r""" Returns the MDL name of the module containing this function definition."""
        return _pymdlsdk._IFunction_definition_get_mdl_module_name(self)

    def get_mdl_simple_name(self):
        r"""
        Returns the simple MDL name of the function definition.

        The simple name is the last component of the MDL name, i.e., without any packages and
        scope qualifiers, and without the parameter type names.

        :rtype: string
        :return: The simple MDL name of the function definition.
        """
        return _pymdlsdk._IFunction_definition_get_mdl_simple_name(self)

    def get_mdl_parameter_type_name(self, index):
        r"""
        Returns the type name of the parameter at ``index``.

        Notes: The type names provided here are substrings of the MDL name returned by
              #get_mdl_name(). They are provided here such that parsing of the MDL name is not
              necessary. Their main use case is one variant of overload resolution if no actual
              arguments are given (see
              #mi::neuraylib::IModule::get_function_overloads(const char*,const IArray*)const. For
              almost all other use cases it is strongly recommended to use #get_parameter_types()
              instead.

        :type index: int
        :param index:    The index of the parameter.
        :rtype: string
        :return: The type name of the parameter, or ``NULL`` if ``index`` is out of range.
        """
        return _pymdlsdk._IFunction_definition_get_mdl_parameter_type_name(self, index)

    def get_prototype(self):
        r"""
        Returns the DB name of the prototype, or ``NULL`` if this function definition is not a
        variant.
        """
        return _pymdlsdk._IFunction_definition_get_prototype(self)

    def get_mdl_version(self, since, removed):
        r"""
        Returns the MDL version when this function definition was added and removed.

        :type since: int, out
        :param since:     The MDL version in which this function definition was added. If the
                                  function definition does not belong to the standard library, the
                                  MDL version of the corresponding module is returned.
        :type removed: int, out
        :param removed:   The MDL version in which this function definition was removed, or
                                  mi::neuraylib::MDL_VERSION_INVALID if the function has not been
                                  removed so far or does not belong to the standard library.
        """
        return _pymdlsdk._IFunction_definition_get_mdl_version(self, since, removed)

    def get_semantic(self):
        r""" Returns the semantic of this function definition."""
        return _pymdlsdk._IFunction_definition_get_semantic(self)

    def is_array_constructor(self):
        r"""
        Indicates whether this definition represents the array constructor.

        See also: 'mi_neuray_mdl_arrays'
        """
        return _pymdlsdk._IFunction_definition_is_array_constructor(self)

    def is_exported(self):
        r""" Indicates whether the function definition is exported by its module."""
        return _pymdlsdk._IFunction_definition_is_exported(self)

    def is_uniform(self):
        r"""
        Indicates whether the function definition is uniform.

        Notes: This includes, in addition to functions definitions that are explicitly marked as
              uniform, also function definitions that are not explicitly marked either uniform or
              varying and that have been analyzed by the MDL compiler to be uniform.
        """
        return _pymdlsdk._IFunction_definition_is_uniform(self)

    def is_material(self):
        r"""
        Indicates whether the definition represents a material.

        If materials-are-functions is enabled, then this method returns ``true`` iff
        #mi::neuraylib::IFunction_definition::get_interface<mi::neuraylib::IMaterial_definition>()
        succeeds. Otherwise, this method always returns ``false``.

        See also: #mi::neuraylib::IMdl_configuration::set_materials_are_functions().
        """
        return _pymdlsdk._IFunction_definition_is_material(self)

    def get_return_type(self):
        r"""
        Returns the return type.

        :rtype: :py:class:`IType`
        :return: The return type.
        """
        return _pymdlsdk._IFunction_definition_get_return_type(self)

    def get_parameter_count(self):
        r""" Returns the number of parameters."""
        return _pymdlsdk._IFunction_definition_get_parameter_count(self)

    def get_parameter_name(self, index):
        r"""
        Returns the name of the parameter at ``index``.

        :type index: int
        :param index:    The index of the parameter.
        :rtype: string
        :return: The name of the parameter, or ``NULL`` if ``index`` is out of range.
        """
        return _pymdlsdk._IFunction_definition_get_parameter_name(self, index)

    def get_parameter_index(self, name):
        r"""
        Returns the index position of a parameter.

        :type name: string
        :param name:     The name of the parameter.
        :rtype: int
        :return: The index of the parameter, or -1 if ``name`` is invalid.
        """
        return _pymdlsdk._IFunction_definition_get_parameter_index(self, name)

    def get_parameter_types(self):
        r""" Returns the types of all parameters."""
        return _pymdlsdk._IFunction_definition_get_parameter_types(self)

    def get_defaults(self):
        r"""
        Returns the defaults of all parameters.

        Notes: Not all parameters have defaults. Hence, the indices in the returned expression list
              do not necessarily coincide with the parameter indices of this definition. Therefore,
              defaults should be retrieved via the name of the parameter instead of its index.
        """
        return _pymdlsdk._IFunction_definition_get_defaults(self)

    def get_enable_if_conditions(self):
        r"""
        Returns the enable_if conditions of all parameters.

        Notes: Not all parameters have a condition. Hence, the indices in the returned expression
              list do not necessarily coincide with the parameter indices of this definition.
              Therefore, conditions should be retrieved via the name of the parameter instead of
              its index.
        """
        return _pymdlsdk._IFunction_definition_get_enable_if_conditions(self)

    def get_enable_if_users(self, index):
        r"""
        Returns the number of other parameters whose enable_if condition might depend on the
        argument of the given parameter.

        :type index: int
        :param index:    The index of the parameter.
        :rtype: int
        :return: The number of other parameters whose enable_if condition depends on this
                            parameter argument.
        """
        return _pymdlsdk._IFunction_definition_get_enable_if_users(self, index)

    def get_enable_if_user(self, index, u_index):
        r"""
        Returns the index of a parameter whose enable_if condition might depend on the
        argument of the given parameter.

        :type index: int
        :param index:    The index of the parameter.
        :type u_index: int
        :param u_index:  The index of the enable_if user.
        :rtype: int
        :return: The index of a parameter whose enable_if condition depends on this
                            parameter argument, or ~0 if indexes are out of range.
        """
        return _pymdlsdk._IFunction_definition_get_enable_if_user(self, index, u_index)

    def get_annotations(self):
        r"""
        Returns the annotations of the function definition itself, or ``NULL`` if there are no such
        annotations.
        """
        return _pymdlsdk._IFunction_definition_get_annotations(self)

    def get_return_annotations(self):
        r"""
        Returns the annotations of the return type of this function definition, or ``NULL`` if there
        are no such annotations.
        """
        return _pymdlsdk._IFunction_definition_get_return_annotations(self)

    def get_parameter_annotations(self):
        r"""
        Returns the annotations of all parameters.

        Notes: Not all parameters have annotations. Hence, the indices in the returned annotation
              list do not necessarily coincide with the parameter indices of this definition.
              Therefore, annotation blocks should be retrieved via the name of the parameter
              instead of its index.
        """
        return _pymdlsdk._IFunction_definition_get_parameter_annotations(self)

    def get_thumbnail(self):
        r"""
        Returns the resolved file name of the thumbnail image for this function definition.

        The function first checks for a thumbnail annotation. If the annotation is provided,
        it uses the 'name' argument of the annotation and resolves that in the MDL search path.
        If the annotation is not provided or file resolution fails, it checks for a file
        module_name.material_name.png next to the MDL module.
        In case this cannot be found either ``NULL`` is returned.
        """
        return _pymdlsdk._IFunction_definition_get_thumbnail(self)

    def is_valid(self, context):
        r"""
        Returns ``true`` if the definition is valid, ``false`` otherwise.
        A definition can become invalid if the module it has been defined in
        or another module imported by that module has been reloaded. In the first case,
        the definition can no longer be used. In the second case, the
        definition can be validated by reloading the module it has been
        defined in.
        :type context: :py:class:`IMdl_execution_context`
        :param context:  Execution context that can be queried for error messages
                            after the operation has finished. Can be ``NULL``.
        :rtype: boolean
        :return: - ``true``   The definition is valid.
                        - ``false``  The definition is invalid.
        """
        return _pymdlsdk._IFunction_definition_is_valid(self, context)

    def get_body(self):
        r"""
        Returns the direct call expression that represents the body of the function (if possible).

        Notes: Functions bodies with control flow can not be represented by an expression. For such
              functions, this method always returns ``NULL``. For all other functions, i.e., for
              functions, whose body is an expression or a plain return statement, the method never
              returns ``NULL`` (unless there is no body at all, see below).

        Functions with a known semantic, i.e., different from
              #mi::neuraylib::IFunction_definition::DS_UNKNOWN, do not have a body as such, and the
              method returns ``NULL`` for such functions.
        """
        return _pymdlsdk._IFunction_definition_get_body(self)

    def get_temporary_count(self):
        r""" Returns the number of temporaries used by this function."""
        return _pymdlsdk._IFunction_definition_get_temporary_count(self)

    def get_temporary(self, index):
        r"""
        Returns the expression of a temporary.

        :type index: int
        :param index:            The index of the temporary.
        :rtype: :py:class:`IExpression`
        :return: The expression of the temporary, or ``NULL`` if ``index`` is out of
                                    range.
        """
        return _pymdlsdk._IFunction_definition_get_temporary(self, index)

    def get_temporary_name(self, index):
        r"""
        Returns the name of a temporary.

        Notes: Names of temporaries are not necessarily unique, e.g., due to inlining. Names are for
              informational purposes and should not be used to identify a particular temporary.

        See also: #mi::neuraylib::IMdl_configuration::set_expose_names_of_let_expressions()

        :type index: int
        :param index:            The index of the temporary.
        :rtype: string
        :return: The name of the temporary, or ``NULL`` if the temporary has no name
                                    or ``index`` is out of range.
        """
        return _pymdlsdk._IFunction_definition_get_temporary_name(self, index)

    def create_function_call_with_ret(self, arguments):
        r"""
        Creates a new function call.

        :type arguments: :py:class:`IExpression_list`
        :param arguments:    The arguments of the created function call.

                                Arguments for parameters without default are mandatory, otherwise
                                optional. The type of an argument must match the corresponding parameter
                                type. Any argument missing in ``arguments`` will be set to the default of
                                the corresponding parameter.

                                Note that the expressions in ``arguments`` are copied. This copy
                                operation is a deep copy, e.g., DB elements referenced in call
                                expressions are also copied.

                                ``NULL`` is a valid argument which is handled like an empty expression
                                list.
        :type errors: int, out, optional
        :param errors:  An optional pointer to an #mi::Sint32 to which an error code will be
                                written. The error codes have the following meaning:
                                -  0: Success.
                                - -1: An argument for a non-existing parameter was provided in
                                      ``arguments``.
                                - -2: The type of an argument in ``arguments`` does not have the correct
                                      type, see #get_parameter_types().
                                - -3: A parameter that has no default was not provided with an argument
                                      value.
                                - -4: The definition can not be instantiated because it is not exported.
                                - -5: A parameter type is uniform, but the corresponding argument has a
                                      varying return type.
                                - -6: An argument expression is not a constant nor a call.
                                - -8: One of the parameter types is uniform, but the corresponding
                                      argument or default is a call expression and the return type of
                                      the called function definition is effectively varying since the
                                      function definition itself is varying.
                                - -9: The function definition is invalid due to a module reload, see
                                      #is_valid() for diagnostics.
        :rtype: :py:class:`IFunction_call`
        :return: The created function call, or ``NULL`` in case of errors.
        """
        return _pymdlsdk._IFunction_definition_create_function_call_with_ret(self, arguments)

    def create_function_call(self, arguments):
        r"""
        Creates a new function call.

        :type arguments: :py:class:`IExpression_list`
        :param arguments:    The arguments of the created function call.

                                Arguments for parameters without default are mandatory, otherwise
                                optional. The type of an argument must match the corresponding parameter
                                type. Any argument missing in ``arguments`` will be set to the default of
                                the corresponding parameter.

                                Note that the expressions in ``arguments`` are copied. This copy
                                operation is a deep copy, e.g., DB elements referenced in call
                                expressions are also copied.

                                ``NULL`` is a valid argument which is handled like an empty expression
                                list.
        :param errors:  An optional pointer to an #mi::Sint32 to which an error code will be
                                written. The error codes have the following meaning:
                                -  0: Success.
                                - -1: An argument for a non-existing parameter was provided in
                                      ``arguments``.
                                - -2: The type of an argument in ``arguments`` does not have the correct
                                      type, see #get_parameter_types().
                                - -3: A parameter that has no default was not provided with an argument
                                      value.
                                - -4: The definition can not be instantiated because it is not exported.
                                - -5: A parameter type is uniform, but the corresponding argument has a
                                      varying return type.
                                - -6: An argument expression is not a constant nor a call.
                                - -8: One of the parameter types is uniform, but the corresponding
                                      argument or default is a call expression and the return type of
                                      the called function definition is effectively varying since the
                                      function definition itself is varying.
                                - -9: The function definition is invalid due to a module reload, see
                                      #is_valid() for diagnostics.
        :rtype: :py:class:`IFunction_call`
        :return: The created function call, or ``NULL`` in case of errors.
        """
        return _pymdlsdk._IFunction_definition_create_function_call(self, arguments)

# Register _IFunction_definition in _pymdlsdk:
_pymdlsdk._IFunction_definition_swigregister(_IFunction_definition)

class Interface_declare_IImage(_IScene_element):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IImage_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IImage

# Register Interface_declare_IImage in _pymdlsdk:
_pymdlsdk.Interface_declare_IImage_swigregister(Interface_declare_IImage)

def Interface_declare_IImage_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IImage_compare_iid(iid)

class _IImage(Interface_declare_IImage):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def reset_file(self, filename):
        r"""
        Sets the image to a file identified by ``filename``.

        Note that support for a given image format requires an image plugin capable of handling
        that format.

        The filename can include one of the following three uv-tileset markers in the filename:
        <UDIM>, <UVTILE0>, or <UVTILE1>. The image refers then to a
        whole uv-tileset, a set of images used together as a single large two-dimensional image.
        The different markers indicate the different filename conventions that encode where each
        image file is placed in the uv texture space.



          |Marker
          |Pattern
          |(0,0) index
          |Convention to format a (u, v)-index
        |
        -

          |<UDIM>
          |DDDD
          |1001
          |UDIM, expands to the four digit number 1000+(u+1+v∗10)
        |

          |<UVTILE0>
          |"_u"I"_v"I
          |_u0_v0
          |0-based uv-tileset, expands to "_u"u"_v"v
        |

          |<UVTILE1>
          |"_u"I"_v"I
          |_u1_v1
          |1-based uv-tileset, expands to "_u"(u+1)"_v"(v+1)
        |


        :rtype: int
        :return: 
                                  -  0: Success.
                                  - -1: Invalid parameters (``NULL`` pointer).
                                  - -2: Failure to resolve the given filename, e.g., the file does not
                                        exist.
                                  - -3: Failure to open the file.
                                  - -4: No image plugin found to handle the file.
                                  - -5: The image plugin failed to import the file.
        """
        return _pymdlsdk._IImage_reset_file(self, filename)

    def reset_reader(self, *args):
        r"""
        *Overload 1:*
        Sets the image to the data provided by a reader.

        :type reader: mi::neuraylib::IReader
        :param reader:         The reader that provides the data for the image. The reader needs to
                                  support absolute access.
        :type image_format: string
        :param image_format:   The image format of the data, e.g., ``"jpg"``. Note that support for a
                                  given image format requires an image plugin capable of handling that
                                  format.
        :rtype: int
        :return: 
                                  -  0: Success.
                                  - -1: Invalid parameters (``NULL`` pointer).
                                  - -3: The reader does not support absolute access.
                                  - -4: No image plugin found to handle the data.
                                  - -5: The image plugin failed to import the data.

        |

        *Overload 2:*
        Sets the image to the uv-tile data provided by an array of readers.

        :type reader: :py:class:`IArray`
        :param reader:         A static or dynamic array of structures of type ``Uvtile_reader``. Such
                                  a structure has the following members:
                                  - #mi::Sint32 **u**

                                    The u-component of this uv-tile.
                                  - #mi::Sint32 **v**

                                    The v-component of this uv-tile.
                                  - #mi::neuraylib::IReader* **reader**

                                    The reader that provides the data for this uv-tile. The reader needs
                                    to support absolute access.
        :type image_format: string
        :param image_format:   The image format of the data, e.g., ``"jpg"``. Note that support for a
                                  given image format requires an image plugin capable of handling that
                                  format.
        :rtype: int
        :return: 
                                  -  0: Success.
                                  - -1: Invalid parameters (``NULL`` pointer).
                                  - -3: The reader does not support absolute access.
                                  - -4: No image plugin found to handle the data.
                                  - -5: The image plugin failed to import the data.
        """
        return _pymdlsdk._IImage_reset_reader(self, *args)

    def get_filename(self, uvtile_id=0):
        r"""
        Returns the resolved file name of the file containing the image.

        The method returns ``NULL`` if there is no file associated with the image, e.g., after
        default construction, calls to #set_from_canvas(), or failures to resolve the file name
        passed to #reset_file().

        See also: #get_original_filename()
        """
        return _pymdlsdk._IImage_get_filename(self, uvtile_id)

    def get_original_filename(self):
        r"""
        Returns the unresolved file as passed to #reset_file().

        The method returns ``NULL`` after default construction or calls to #set_from_canvas().

        See also: #get_filename()
        """
        return _pymdlsdk._IImage_get_original_filename(self)

    def set_from_canvas(self, *args):
        r"""
        *Overload 1:*
        Sets the pixels of this image based on the passed canvas (possibly sharing the pixel data).

        :type canvas: mi::neuraylib::ICanvas
        :param canvas:   The pixel data to be used by this image.
        :type shared: boolean, optional
        :param shared:   If ``false`` (the default), the pixel data is copied from ``canvas`` and the
                            method does the same as
                            #mi::neuraylib::IImage::set_from_canvas(const mi::neuraylib::ICanvas*).
                            If set to ``true``, the image uses the canvas directly (doing reference
                            counting on the canvas pointer). You must not modify the canvas content
                            after this call.
        :rtype: boolean
        :return: ``true`` if the pixel data of this image has been set correctly, and
                            ``false`` otherwise.

        |

        *Overload 2:*
        Sets the pixels of the uv-tiles of this image based on the passed canvases (possibly sharing
        the pixel data).

        :type uvtiles: :py:class:`IArray`
        :param uvtiles:  A static or dynamic array of structures of type ``Uvtile``. Such a structure
                            has the following members:
                            - #mi::Sint32 **u**

                              The u-component of this uv-tile.
                            - #mi::Sint32 **v**

                              The v-component of this uv-tile.
                            - #mi::neuraylib::ICanvas* **canvas**

                              The pixel data to be used for this image. Note that the pixel data is
                              copied, not shared. If sharing is intended use
                              #mi::neuraylib::IImage::set_from_canvas(mi::IArray*,bool) instead.
        :type shared: boolean, optional
        :param shared:   If ``false`` (the default), the pixel data is copied from ``canvas`` and the
                            method does the same as
                            #mi::neuraylib::IImage::set_from_canvas(const mi::neuraylib::ICanvas*).
                            If set to ``true``, the image uses the canvases directly (doing reference
                            counting on the canvas pointers). You must not modify the canvas contents
                            after this call.
        :rtype: boolean
        :return: ``true`` if the pixel data of this image has been set correctly, and
                            ``false`` otherwise.
        """
        return _pymdlsdk._IImage_set_from_canvas(self, *args)

    def get_canvas(self, level=0, uvtile_id=0):
        r"""
        Returns a canvas with the pixel data of the image.

        Note that it is not possible to manipulate the pixel data.

        :type level: int, optional
        :param level:       The desired mipmap level. Level 0 is the highest resolution.
        :type uvtile_id: int, optional
        :param uvtile_id:   The uv-tile id of the canvas.
        :rtype: mi::neuraylib::ICanvas
        :return: A canvas pointing to the pixel data of the image, or ``NULL`` in case of
                               failure, e.g. because of an invalid tile id.
        """
        return _pymdlsdk._IImage_get_canvas(self, level, uvtile_id)

    def get_type(self, uvtile_id=0):
        r"""
        Returns the pixel type of the image.

        :type uvtile_id: int, optional
        :param uvtile_id:   The uv-tile id of the canvas to get the pixel type for.
        :rtype: char
        :return: The pixel type or 0 in case of an invalid tile id.
            See 'mi_neuray_types' for a list of supported pixel types.
        """
        return _pymdlsdk._IImage_get_type(self, uvtile_id)

    def get_levels(self, uvtile_id=0):
        r"""
        Returns the number of levels in the mipmap pyramid.

        :type uvtile_id: int, optional
        :param uvtile_id:   The uv-tile id of the canvas to get the number of levels for.
        :rtype: int
        :return: The number of levels or -1 in case of an invalid tile id.
        """
        return _pymdlsdk._IImage_get_levels(self, uvtile_id)

    def resolution_x(self, level=0, uvtile_id=0):
        r"""
        Returns the horizontal resolution of the image.

        :type level: int, optional
        :param level:       The desired mipmap level. Level 0 is the highest resolution.
        :type uvtile_id: int, optional
        :param uvtile_id:   The uv-tile id of the canvas to get the resolution for.
        :rtype: int
        :return: The horizontal resolution or -1 in case of an invalid tile id.
        """
        return _pymdlsdk._IImage_resolution_x(self, level, uvtile_id)

    def resolution_y(self, level=0, uvtile_id=0):
        r"""
        Returns the vertical resolution of the image.

        :type level: int, optional
        :param level:       The desired mipmap level. Level 0 is the highest resolution.
        :type uvtile_id: int, optional
        :param uvtile_id:   The uv-tile id of the canvas to get the resolution for.
        :rtype: int
        :return: The vertical resolution or -1 in case of an invalid tile id.
        """
        return _pymdlsdk._IImage_resolution_y(self, level, uvtile_id)

    def resolution_z(self, level=0, uvtile_id=0):
        r"""
        Returns the number of layers of the 3D image.

        :type level: int, optional
        :param level:       The desired mipmap level. Level 0 is the highest resolution.
        :type uvtile_id: int, optional
        :param uvtile_id:   The uv-tile id of the canvas to get the resolution for.
        :rtype: int
        :return: The number of layers or -1 in case of an invalid tile id.
        """
        return _pymdlsdk._IImage_resolution_z(self, level, uvtile_id)

    def get_uvtile_length(self):
        r""" Returns the number of uv-tiles of the image."""
        return _pymdlsdk._IImage_get_uvtile_length(self)

    def get_uvtile_uv(self, uvtile_id, u, v):
        r"""
        Returns the u and v tile indices of the uv-tile at the given index.

        :type uvtile_id: int
        :param uvtile_id:   The uv-tile id of the canvas.
        :type u: int
        :param u:           The u-component of the uv-tile
        :type v: int
        :param v:           The v-component of the uv-tile
        :rtype: int
        :return: 0 on success, -1 if uvtile_id is out of range.
        """
        return _pymdlsdk._IImage_get_uvtile_uv(self, uvtile_id, u, v)

    def get_uvtile_id(self, u, v):
        r"""
        Returns the uvtile-id corresponding to the tile at u,v.

        :type u: int
        :param u:           The u-component of the uv-tile
        :type v: int
        :param v:           The v-component of the uv-tile
        :rtype: int
        :return: The uvtile-id or -1 of there is no tile with the given coordinates.
        """
        return _pymdlsdk._IImage_get_uvtile_id(self, u, v)

    def is_uvtile(self):
        r""" Returns ``true`` if this image represents a uvtile/udim image sequence."""
        return _pymdlsdk._IImage_is_uvtile(self)

    def get_uvtile_uv_ranges(self, min_u, min_v, max_u, max_v):
        r"""
        Returns the ranges of u and v coordinates (or all values zero if #is_uvtile() returns
        ``false)``.
        """
        return _pymdlsdk._IImage_get_uvtile_uv_ranges(self, min_u, min_v, max_u, max_v)

# Register _IImage in _pymdlsdk:
_pymdlsdk._IImage_swigregister(_IImage)

class Interface_declare_IMaterial_definition(_IScene_element):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IMaterial_definition_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IMaterial_definition

# Register Interface_declare_IMaterial_definition in _pymdlsdk:
_pymdlsdk.Interface_declare_IMaterial_definition_swigregister(Interface_declare_IMaterial_definition)

def Interface_declare_IMaterial_definition_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IMaterial_definition_compare_iid(iid)

class _IMaterial_definition(Interface_declare_IMaterial_definition):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_module(self):
        r"""
        Returns the DB name of the module containing this material definition.

        The type of the module is #mi::neuraylib::IModule.
        """
        return _pymdlsdk._IMaterial_definition_get_module(self)

    def get_mdl_name(self):
        r"""
        Returns the MDL name of the material definition.

        Notes: The MDL name of the material definition is different from the name of the DB element.
              Use #mi::neuraylib::ITransaction::name_of() to obtain the name of the DB element.

        :rtype: string
        :return: The MDL name of the material definition.
        """
        return _pymdlsdk._IMaterial_definition_get_mdl_name(self)

    def get_mdl_module_name(self):
        r""" Returns the MDL name of the module containing this material definition."""
        return _pymdlsdk._IMaterial_definition_get_mdl_module_name(self)

    def get_mdl_simple_name(self):
        r"""
        Returns the simple MDL name of the function definition.

        The simple name is the last component of the MDL name, i.e., without any packages and scope
        qualifiers.

        :rtype: string
        :return: The simple MDL name of the function definition.
        """
        return _pymdlsdk._IMaterial_definition_get_mdl_simple_name(self)

    def get_mdl_parameter_type_name(self, index):
        r"""
        Returns the type name of the parameter at ``index``.

        Notes: The type names provided here are substrings of the MDL name returned by
              #get_mdl_name(). They are provided here such that parsing of the MDL name is not
              necessary. Their main use case is one variant of overload resolution if no actual
              arguments are given (see
              #mi::neuraylib::IModule::get_function_overloads(const char*,const IArray*)const. For
              almost all other use cases it is strongly recommended to use #get_parameter_types()
              instead.

        :type index: int
        :param index:    The index of the parameter.
        :rtype: string
        :return: The type name of the parameter, or ``NULL`` if ``index`` is out of range.
        """
        return _pymdlsdk._IMaterial_definition_get_mdl_parameter_type_name(self, index)

    def get_prototype(self):
        r"""
        Returns the DB name of the prototype, or ``NULL`` if this material definition is not a
        variant.
        """
        return _pymdlsdk._IMaterial_definition_get_prototype(self)

    def get_mdl_version(self, since, removed):
        r"""
        Returns the MDL version when this material definition was added and removed.

        :type since: int, out
        :param since:     The MDL version in which this material definition was added. Since
                                  there are no material definitions in the standard library, the
                                  MDL version of the corresponding module is returned.
        :type removed: int, out
        :param removed:   The MDL version in which this material definition was removed. Since
                                  there are no material definitions in the standard library,
                                  mi::neuraylib::MDL_VERSION_INVALID is always returned.
        """
        return _pymdlsdk._IMaterial_definition_get_mdl_version(self, since, removed)

    def get_semantic(self):
        r"""
        Returns the semantic of this material definition.

        Right now there are no materials with special semantics, i.e., this method always returns
        #mi::neuraylib::IFunction_definition::DS_UNKNOWN.
        """
        return _pymdlsdk._IMaterial_definition_get_semantic(self)

    def is_exported(self):
        r""" Indicates whether the material definition is exported by its module."""
        return _pymdlsdk._IMaterial_definition_is_exported(self)

    def get_return_type(self):
        r""" Returns the return type (the fixed material type)."""
        return _pymdlsdk._IMaterial_definition_get_return_type(self)

    def get_parameter_count(self):
        r""" Returns the number of parameters."""
        return _pymdlsdk._IMaterial_definition_get_parameter_count(self)

    def get_parameter_name(self, index):
        r"""
        Returns the name of the parameter at ``index``.

        :type index: int
        :param index:    The index of the parameter.
        :rtype: string
        :return: The name of the parameter, or ``NULL`` if ``index`` is out of range.
        """
        return _pymdlsdk._IMaterial_definition_get_parameter_name(self, index)

    def get_parameter_index(self, name):
        r"""
        Returns the index position of a parameter.

        :type name: string
        :param name:     The name of the parameter.
        :rtype: int
        :return: The index of the parameter, or -1 if ``name`` is invalid.
        """
        return _pymdlsdk._IMaterial_definition_get_parameter_index(self, name)

    def get_parameter_types(self):
        r""" Returns the types of all parameters."""
        return _pymdlsdk._IMaterial_definition_get_parameter_types(self)

    def get_defaults(self):
        r"""
        Returns the defaults of all parameters.

        Notes: Not all parameters have defaults. Hence, the indices in the returned expression list
              do not necessarily coincide with the parameter indices of this definition. Therefore,
              defaults should be retrieved via the name of the parameter instead of its index.
        """
        return _pymdlsdk._IMaterial_definition_get_defaults(self)

    def get_enable_if_conditions(self):
        r"""
        Returns the enable_if conditions of all parameters.

        Notes: Not all parameters have a condition. Hence, the indices in the returned expression
              list do not necessarily coincide with the parameter indices of this definition.
              Therefore, conditions should be retrieved via the name of the parameter instead of
              its index.
        """
        return _pymdlsdk._IMaterial_definition_get_enable_if_conditions(self)

    def get_enable_if_users(self, index):
        r"""
        Returns the number of other parameters whose enable_if condition might depend on the
        argument of the given parameter.

        :type index: int
        :param index:    The index of the parameter.
        :rtype: int
        :return: The number of other parameters whose enable_if condition depends on this
                            parameter argument.
        """
        return _pymdlsdk._IMaterial_definition_get_enable_if_users(self, index)

    def get_enable_if_user(self, index, u_index):
        r"""
        Returns the index of a parameter whose enable_if condition might depend on the
        argument of the given parameter.

        :type index: int
        :param index:    The index of the parameter.
        :type u_index: int
        :param u_index:  The index of the enable_if user.
        :rtype: int
        :return: The index of a parameter whose enable_if condition depends on this
                            parameter argument, or ~0 if indexes are out of range.
        """
        return _pymdlsdk._IMaterial_definition_get_enable_if_user(self, index, u_index)

    def get_annotations(self):
        r"""
        Returns the annotations of the material definition itself, or ``NULL`` if there are no such
        annotations.
        """
        return _pymdlsdk._IMaterial_definition_get_annotations(self)

    def get_parameter_annotations(self):
        r"""
        Returns the annotations of all parameters.

        Notes: Not all parameters have annotations. Hence, the indices in the returned annotation
              list do not necessarily coincide with the parameter indices of this definition.
              Therefore, annotation blocks should be retrieved via the name of the parameter
              instead of its index.
        """
        return _pymdlsdk._IMaterial_definition_get_parameter_annotations(self)

    def get_thumbnail(self):
        r"""
        Returns the resolved file name of the thumbnail image for this material definition.

        The function first checks for a thumbnail annotation. If the annotation is provided,
        it uses the 'name' argument of the annotation and resolves that in the MDL search path.
        If the annotation is not provided or file resolution fails, it checks for a file
        module_name.material_name.png next to the MDL module.
        In case this cannot be found either ``NULL`` is returned.
        """
        return _pymdlsdk._IMaterial_definition_get_thumbnail(self)

    def is_valid(self, context):
        r"""
        Returns ``true`` if the definition is valid, ``false`` otherwise.
        A definition can become invalid if the module it has been defined in
        or another module imported by that module has been reloaded. In the first case,
        the definition can no longer be used. In the second case, the
        definition can be validated by reloading the module it has been
        defined in.
        :type context: :py:class:`IMdl_execution_context`
        :param context:  Execution context that can be queried for error messages
                            after the operation has finished. Can be ``NULL``.
        :rtype: boolean
        :return: - ``true``   The definition is valid.
                        - ``false``  The definition is invalid.
        """
        return _pymdlsdk._IMaterial_definition_is_valid(self, context)

    def get_body(self):
        r""" Returns the direct call expression that represents the body of the material."""
        return _pymdlsdk._IMaterial_definition_get_body(self)

    def get_temporary_count(self):
        r""" Returns the number of temporaries used by this material."""
        return _pymdlsdk._IMaterial_definition_get_temporary_count(self)

    def get_temporary(self, index):
        r"""
        Returns the expression of a temporary.

        :type index: int
        :param index:            The index of the temporary.
        :rtype: :py:class:`IExpression`
        :return: The expression of the temporary, or ``NULL`` if ``index`` is out of
                                    range.
        """
        return _pymdlsdk._IMaterial_definition_get_temporary(self, index)

    def get_temporary_name(self, index):
        r"""
        Returns the name of a temporary.

        Notes: Names of temporaries are not necessarily unique, e.g., due to inlining. Names are for
              informational purposes and should not be used to identify a particular temporary.

        See also: #mi::neuraylib::IMdl_configuration::set_expose_names_of_let_expressions()

        :type index: int
        :param index:            The index of the temporary.
        :rtype: string
        :return: The name of the temporary, or ``NULL`` if the temporary has no name
                                    or ``index`` is out of range.
        """
        return _pymdlsdk._IMaterial_definition_get_temporary_name(self, index)

    def create_material_instance_with_ret(self, arguments):
        r"""
        Creates a new material instance.

        :type arguments: :py:class:`IExpression_list`
        :param arguments:    The arguments of the created material instance.

                                Arguments for parameters without default are mandatory, otherwise
                                optional. The type of an argument must match the corresponding parameter
                                type. Any argument missing in ``arguments`` will be set to the default of
                                the corresponding parameter.

                                Note that the expressions in ``arguments`` are copied. This copy
                                operation is a deep copy, e.g., DB elements referenced in call
                                expressions are also copied.

                                ``NULL`` is a valid argument which is handled like an empty expression
                                list.
        :type errors: int, out, optional
        :param errors:  An optional pointer to an #mi::Sint32 to which an error code will be
                                written. The error codes have the following meaning:
                                -  0: Success.
                                - -1: An argument for a non-existing parameter was provided in
                                      ``arguments``.
                                - -2: The type of an argument in ``arguments`` does not have the correct
                                      type, see #get_parameter_types().
                                - -3: A parameter that has no default was not provided with an argument
                                      value.
                                - -4: The definition can not be instantiated because it is not exported.
                                - -5: A parameter type is uniform, but the corresponding argument has a
                                      varying return type.
                                - -6: An argument expression is not a constant nor a call.
                                - -8: One of the parameter types is uniform, but the corresponding
                                      argument or default is a call expression and the return type of
                                      the called function definition is effectively varying since the
                                      function definition itself is varying.
                                - -9: The material definition is invalid due to a module reload, see
                                      #is_valid() for diagnostics.
        :rtype: :py:class:`IMaterial_instance`
        :return: The created material instance, or ``NULL`` in case of errors.
        """
        return _pymdlsdk._IMaterial_definition_create_material_instance_with_ret(self, arguments)

    def create_material_instance(self, arguments):
        r"""
        Creates a new material instance.

        :type arguments: :py:class:`IExpression_list`
        :param arguments:    The arguments of the created material instance.

                                Arguments for parameters without default are mandatory, otherwise
                                optional. The type of an argument must match the corresponding parameter
                                type. Any argument missing in ``arguments`` will be set to the default of
                                the corresponding parameter.

                                Note that the expressions in ``arguments`` are copied. This copy
                                operation is a deep copy, e.g., DB elements referenced in call
                                expressions are also copied.

                                ``NULL`` is a valid argument which is handled like an empty expression
                                list.
        :param errors:  An optional pointer to an #mi::Sint32 to which an error code will be
                                written. The error codes have the following meaning:
                                -  0: Success.
                                - -1: An argument for a non-existing parameter was provided in
                                      ``arguments``.
                                - -2: The type of an argument in ``arguments`` does not have the correct
                                      type, see #get_parameter_types().
                                - -3: A parameter that has no default was not provided with an argument
                                      value.
                                - -4: The definition can not be instantiated because it is not exported.
                                - -5: A parameter type is uniform, but the corresponding argument has a
                                      varying return type.
                                - -6: An argument expression is not a constant nor a call.
                                - -8: One of the parameter types is uniform, but the corresponding
                                      argument or default is a call expression and the return type of
                                      the called function definition is effectively varying since the
                                      function definition itself is varying.
                                - -9: The material definition is invalid due to a module reload, see
                                      #is_valid() for diagnostics.
        :rtype: :py:class:`IMaterial_instance`
        :return: The created material instance, or ``NULL`` in case of errors.
        """
        return _pymdlsdk._IMaterial_definition_create_material_instance(self, arguments)

# Register _IMaterial_definition in _pymdlsdk:
_pymdlsdk._IMaterial_definition_swigregister(_IMaterial_definition)

class Interface_declare_IMaterial_instance(_IScene_element):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IMaterial_instance_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IMaterial_instance

# Register Interface_declare_IMaterial_instance in _pymdlsdk:
_pymdlsdk.Interface_declare_IMaterial_instance_swigregister(Interface_declare_IMaterial_instance)

def Interface_declare_IMaterial_instance_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IMaterial_instance_compare_iid(iid)

class _IMaterial_instance(Interface_declare_IMaterial_instance):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_material_definition(self):
        r"""
        Returns the DB name of the corresponding material definition.

        The type of the material definition is #mi::neuraylib::IMaterial_definition.

        Notes: The DB name of the material definition is different from its MDL name (see
              #get_mdl_material_definition()).
        """
        return _pymdlsdk._IMaterial_instance_get_material_definition(self)

    def get_mdl_material_definition(self):
        r"""
        Returns the MDL name of the corresponding material definition.

        Notes: The MDL name of the material definition is different from the name of the DB element
              (see #get_material_definition()).
        """
        return _pymdlsdk._IMaterial_instance_get_mdl_material_definition(self)

    def get_return_type(self):
        r""" Returns the return type of the corresponding material definition (the fixed material type)."""
        return _pymdlsdk._IMaterial_instance_get_return_type(self)

    def get_parameter_count(self):
        r""" Returns the number of parameters."""
        return _pymdlsdk._IMaterial_instance_get_parameter_count(self)

    def get_parameter_name(self, index):
        r"""
        Returns the name of the parameter at ``index``.

        :type index: int
        :param index:        The index of the parameter.
        :rtype: string
        :return: The name of the parameter, or ``NULL`` if ``index`` is out of range.
        """
        return _pymdlsdk._IMaterial_instance_get_parameter_name(self, index)

    def get_parameter_index(self, name):
        r"""
        Returns the index position of a parameter.

        :type name: string
        :param name:         The name of the parameter.
        :rtype: int
        :return: The index of the parameter, or -1 if ``name`` is invalid.
        """
        return _pymdlsdk._IMaterial_instance_get_parameter_index(self, name)

    def get_parameter_types(self):
        r""" Returns the types of all parameters."""
        return _pymdlsdk._IMaterial_instance_get_parameter_types(self)

    def get_arguments(self):
        r""" Returns all arguments."""
        return _pymdlsdk._IMaterial_instance_get_arguments(self)

    def set_arguments(self, arguments):
        r"""
        Sets multiple arguments.

        :type arguments: :py:class:`IExpression_list`
        :param arguments:    The arguments. Note that the expressions are copied. This copy operation
                                is a shallow copy, e.g., DB elements referenced in call expressions are
                                *not* copied.
        :rtype: int
        :return: 
                                -  0: Success.
                                - -1: Invalid parameters (``NULL`` pointer).
                                - -2: One of the parameters in ``arguments`` does not exist.
                                - -3: One of the argument types does not match the corresponding
                                      parameter type.
                                - -4: The material instance is immutable (because it appears in a
                                      default of a material definition).
                                - -5: One of the parameter types is uniform, but the corresponding
                                      argument type is varying.
                                - -6: One of the arguments is not a constant nor a call.
                                - -7: One of the arguments contains references to DB elements in a scope
                                      that is more private scope than the scope of this material
                                      instance.
                                - -8: One of the parameter types is uniform, but the corresponding
                                      argument is a call expression and the return type of the
                                      called function definition is effectively varying since the
                                      function definition itself is varying.
        """
        return _pymdlsdk._IMaterial_instance_set_arguments(self, arguments)

    def set_argument(self, *args):
        r"""
        *Overload 1:*
        Sets the argument at ``index``.

        :type index: int
        :param index:        The index of the argument.
        :type argument: :py:class:`IExpression`
        :param argument:     The argument. Note that the expression is copied. This copy operation
                                is a shallow copy, e.g., DB elements referenced in call expressions are
                                *not* copied.
        :rtype: int
        :return: 
                                -  0: Success.
                                - -1: Invalid parameters (``NULL`` pointer).
                                - -2: Parameter ``index`` does not exist.
                                - -3: The argument type does not match the parameter type.
                                - -4: The material instance is immutable (because it appears in a
                                      default of a material definition).
                                - -5: The parameter type is uniform, but the argument type is varying.
                                - -6: The argument expression is not a constant nor a call.
                                - -7: The argument contains references to DB elements in a scope that is
                                      more private scope than the scope of this material instance.
                                - -8: The parameter types is uniform, but the argument is a call
                                      expression and the return type of the called function definition
                                      is effectively varying since the function definition itself is
                                      varying.

        |

        *Overload 2:*
        Sets an argument identified by name.

        :type name: string
        :param name:         The name of the parameter.
        :type argument: :py:class:`IExpression`
        :param argument:     The argument. Note that the expression is copied. This copy operation
                                is a shallow copy, e.g., DB elements referenced in call expressions are
                                *not* copied.
        :rtype: int
        :return: 
                                -  0: Success.
                                - -1: Invalid parameters (``NULL`` pointer).
                                - -2: Parameter ``name`` does not exist.
                                - -3: The argument type does not match the parameter type.
                                - -4: The material instance is immutable (because it appears in a
                                      default of a material definition).
                                - -5: The parameter type is uniform, but the argument type is varying.
                                - -6: The argument expression is not a constant nor a call.
                                - -7: The argument contains references to DB elements in a scope that is
                                      more private scope than the scope of this material instance.
                                - -8: The parameter types is uniform, but the argument is a call
                                      expression and the return type of the called function definition
                                      is effectively varying since the function definition itself is
                                      varying.
        """
        return _pymdlsdk._IMaterial_instance_set_argument(self, *args)

    def is_default(self):
        r"""
        Indicates, if this material instance acts as a default argument of a material or
        function definition.

        Defaults are immutable, their arguments cannot be changed and they cannot be used
        in call expressions.

        :rtype: boolean
        :return: true, if this material instance is a default, false otherwise.
        """
        return _pymdlsdk._IMaterial_instance_is_default(self)

    def is_valid(self, context):
        r"""
        Returns ``true`` if this material instance and all its arguments point to valid
        material and function definitions, ``false`` otherwise.

        Material and function definitions can become invalid due to a module reload.

        See also: #mi::neuraylib::IModule::reload(), #mi::neuraylib::IMaterial_instance::repair()

        :type context: :py:class:`IMdl_execution_context`
        :param context:  Execution context that can be queried for error messages
                            after the operation has finished. Can be ``NULL``.
        :rtype: boolean
        :return: 
                 - ``true``:  The instance is valid.
                 - ``false``: The instance is invalid.
        """
        return _pymdlsdk._IMaterial_instance_is_valid(self, context)

    def repair(self, flags, context):
        r"""
        Attempts to repair an invalid material instance.

        :type flags: int
        :param flags:    Repair options, see #mi::neuraylib::Mdl_repair_options.
        :type context: :py:class:`IMdl_execution_context`
        :param context:  Execution context that can be queried for error messages
                            after the operation has finished. Can be ``NULL``.
        :rtype: int
        :return: 
                -   0:   Success.
                -  -1:   Repair failed. Check the ``context`` for details.
        """
        return _pymdlsdk._IMaterial_instance_repair(self, flags, context)
    DEFAULT_OPTIONS = _pymdlsdk._IMaterial_instance_DEFAULT_OPTIONS
    r""" Default compilation options (e.g., instance compilation)."""
    CLASS_COMPILATION = _pymdlsdk._IMaterial_instance_CLASS_COMPILATION
    r""" Selects class compilation instead of instance compilation."""
    COMPILATION_OPTIONS_FORCE_32_BIT = _pymdlsdk._IMaterial_instance_COMPILATION_OPTIONS_FORCE_32_BIT

    def create_compiled_material(self, flags, context=None):
        r"""
        Creates a compiled material.

        :type flags: int
        :param flags:          A bitmask of flags of type #Compilation_options.
        :type context: :py:class:`IMdl_execution_context`, inout, optional
        :param context: An optional pointer to an execution context which can be used to pass
                                  compilation options to the MDL compiler. The following options are
                                  supported for this operation:
                                  - #mi::Float32 "meters_per_scene_unit": The conversion ratio between
                                    meters and scene units for this material. Default: 1.0f.
                                  - #mi::Float32 "wavelength_min": The smallest supported wavelength.
                                    Default: 380.0f.
                                  - #mi::Float32 "wavelength_max": The largest supported wavelength.
                                    Default: 780.0f.
                                  .
                                  The following options are supported in class compilation mode:
                                  - ``bool`` "fold_ternary_on_df": Fold all ternary operators of *df
                                    types. Default: ``false``.
                                  - ``bool`` "fold_all_bool_parameters": Fold all bool parameters.
                                    Default: ``false``.
                                  - ``bool`` "fold_all_enum_parameters": Fold all enum parameters.
                                    Default: ``false``.
                                  - #mi::base::IInterface *"fold_parameters": A static or dynamic array
                                    of strings of the parameters to fold. The names of the parameters
                                    are those that would otherwise be reported in
                                    #mi::neuraylib::ICompiled_material::get_parameter_name().
                                    Default: ``NULL``
                                  - ``bool`` "fold_trivial_cutout_opacity": Fold the expression for
                                    geometry.cutout_opacity if it evaluates to a constant with value
                                    0.0f or 1.0f. Default: ``false``.
                                  - ``bool`` "fold_transparent_layers": Calls to the functions
                                    ``df::weighted_layer()``, ``df::fresnel_layer()``,
                                    ``df::custom_curve_layer()``, ``df::measured_curve_layer()``, and
                                    their equivalents with color weights, are replaced by their
                                    ``base`` argument, if the ``weight`` argument evaluates to a constant
                                    with value 0.0f, and the ``layer`` argument is one of
                                    ``df::diffuse_transmission_bsdf()``, ``df::specular_bsdf()``,
                                    ``df::simple_glossy_bsdf()``, or ``df::microfacet_*_bsdf()``, and
                                    the ``scatter_mode`` argument (if present) is either
                                    ``df::scatter_transmit`` or ``df::scatter_reflect_transmit``.
                                    In addition, the ``layer`` argument might be a combination of such
                                    BSDFs using the ternary operator.
                                  .
                                  During material compilation, messages like errors and warnings will
                                  be passed to the context for later evaluation by the caller. Possible
                                  error conditions:
                                  - Type mismatch, call of an unsuitable DB element, or call cycle in
                                    the graph of this material instance.
                                  - The thin-walled material instance has different transmission for
                                    surface and backface.
                                  - An argument type of the graph of this material instance is varying
                                    but the corresponding parameter type is uniform.
                                  - An element in the array for the context option
                                    "fold_parameters" does not have the type #mi::IString.
        :rtype: mi::neuraylib::ICompiled_material
        :return: The corresponding compiled material, or ``NULL`` in case of failure.
        """
        return _pymdlsdk._IMaterial_instance_create_compiled_material(self, flags, context)

# Register _IMaterial_instance in _pymdlsdk:
_pymdlsdk._IMaterial_instance_swigregister(_IMaterial_instance)

class Interface_declare_IMdl_configuration(object):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IMdl_configuration_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IMdl_configuration

# Register Interface_declare_IMdl_configuration in _pymdlsdk:
_pymdlsdk.Interface_declare_IMdl_configuration_swigregister(Interface_declare_IMdl_configuration)

def Interface_declare_IMdl_configuration_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IMdl_configuration_compare_iid(iid)

class _IMdl_configuration(Interface_declare_IMdl_configuration):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def set_logger(self, logger):
        r"""
        Sets the logger.

        If: IRAY_API { Sets the receiving logger, see also
        #mi::neuraylib::ILogging_configuration::set_receiving_logger().}Else:  { Installs a custom logger, and deinstalls the previously installed logger.
        By default, an internal logger is installed that prints all messages of severity
        #mi::base::details::MESSAGE_SEVERITY_INFO or higher to stderr.}

        :type logger: mi::base::ILogger
        :param logger:   The new logger that receives all log messages. Passing ``NULL`` is allowed
                            to reinstall the default logger.
        """
        return _pymdlsdk._IMdl_configuration_set_logger(self, logger)

    def get_logger(self):
        r"""
        Returns the used logger.

        :rtype: mi::base::ILogger
        :return: If: IRAY_API { Returns the forwarding logger. See
                  also #mi::neuraylib::ILogging_configuration::get_forwarding_logger(). }Else: The {
                  currently used logger ( either explicitly installed via #set_logger(), or
                  the default logger). Never returns ``NULL``. }
        """
        return _pymdlsdk._IMdl_configuration_get_logger(self)

    def add_mdl_path(self, path):
        r"""
        Adds a path to the list of paths to search for MDL modules.

        This search path is also used for resources referenced in MDL modules. By default, the list
        of MDL paths is empty.

        :type path: string
        :param path:                The path to be added.
        :rtype: int
        :return: 
                                       -  0: Success.
                                       - -1: Invalid parameters ( ``NULL`` pointer).
                                       - -2: Invalid path.
        """
        return _pymdlsdk._IMdl_configuration_add_mdl_path(self, path)

    def remove_mdl_path(self, path):
        r"""
        Removes a path from the list of paths to search for MDL modules.

        This search path is also used for resources referenced in MDL modules. By default, the list
        of MDL paths is empty.

        :type path: string
        :param path:                The path to be removed.
        :rtype: int
        :return: 
                                       -  0: Success.
                                       - -1: Invalid parameters ( ``NULL`` pointer).
                                       - -2: There is no such path in the path list.
        """
        return _pymdlsdk._IMdl_configuration_remove_mdl_path(self, path)

    def clear_mdl_paths(self):
        r"""
        Clears the list of paths to search for MDL modules.

        This search path is also used for resources referenced in MDL modules. By default, the list
        of MDL paths is empty.
        """
        return _pymdlsdk._IMdl_configuration_clear_mdl_paths(self)

    def get_mdl_paths_length(self):
        r"""
        Returns the number of paths to search for MDL modules.

        This search path is also used for resources referenced in MDL modules. By default, the list
        of MDL paths is empty.

        :rtype: int
        :return: The number of currently configured paths.
        """
        return _pymdlsdk._IMdl_configuration_get_mdl_paths_length(self)

    def get_mdl_path(self, index):
        r"""
        Returns the ``index`` -th path to search for MDL modules.

        This search path is also used for resources referenced in MDL modules. By default, the list
        of MDL paths is empty.

        :rtype: :py:class:`IString`
        :return: The ``index`` -th path, or ``NULL`` if ``index`` is out of bounds.
        """
        return _pymdlsdk._IMdl_configuration_get_mdl_path(self, index)

    def get_mdl_system_paths_length(self):
        r""" Returns the number of MDL system paths."""
        return _pymdlsdk._IMdl_configuration_get_mdl_system_paths_length(self)

    def get_mdl_system_path(self, index):
        r"""
        Returns the ``index`` -th path in the MDL system paths.

        The default MDL system path is
        - ``%%PROGRAMDATA%``\NVIDIA ``Corporation``\mdl (on Windows),
        - ``/opt/nvidia/mdl`` (on Linux), and
        - ``/Library/Application`` ``Support/NVIDIA`` ``Corporation/mdl`` (on Mac OS).

        The MDL system paths can be changed via the environment variable ``MDL_SYSTEM_PATH``. The
        environment variable can contain multiple paths which are separated by semicolons (on
        Windows) or colons (on Linux and Mac OS), respectively.

        :rtype: string
        :return: The ``index`` -th path, or ``NULL`` if ``index`` is out of bounds.
        """
        return _pymdlsdk._IMdl_configuration_get_mdl_system_path(self, index)

    def add_mdl_system_paths(self):
        r""" Adds the MDL system paths to the MDL search path."""
        return _pymdlsdk._IMdl_configuration_add_mdl_system_paths(self)

    def get_mdl_user_paths_length(self):
        r""" Returns the number of MDL user paths."""
        return _pymdlsdk._IMdl_configuration_get_mdl_user_paths_length(self)

    def get_mdl_user_path(self, index):
        r"""
        Returns the ``index`` -th path in the MDL user paths.

        The default MDL user path is
        - ``%%DOCUMENTS%``\mdl (on Windows),
        - ``$HOME/Documents/mdl`` (on Linux), and
        - ``$HOME/Documents/mdl`` (on Mac OS),
        where %DOCUMENTS% refers to the standard folder identified by ``FOLDERID_Documents`` from
        the Windows API (usually ``%%USERPROFILE%``\Documents).

        The MDL user paths can be changed via the environment variable ``MDL_USER_PATH``. The
        environment variable can contain multiple paths which are separated by semicolons (on
        Windows) or colons (on Linux and Mac OS), respectively.

        :rtype: string
        :return: The ``index`` -th path, or ``NULL`` if ``index`` is out of bounds.
        """
        return _pymdlsdk._IMdl_configuration_get_mdl_user_path(self, index)

    def add_mdl_user_paths(self):
        r""" Adds the MDL user paths to the MDL search path."""
        return _pymdlsdk._IMdl_configuration_add_mdl_user_paths(self)

    def add_resource_path(self, path):
        r"""
        Adds a path to the list of paths to search for resources, i.e., textures, light profiles,
        and BSDF measurements.

        Note that for MDL resources referenced in .``mdl`` files the MDL search paths are considered,
        not the resource search path. By default, the list of resource paths is empty.

        :type path: string
        :param path:                The path to be added.
        :rtype: int
        :return: 
                                       -  0: Success.
                                       - -1: Invalid parameters ( ``NULL`` pointer).
                                       - -2: Invalid path.
        """
        return _pymdlsdk._IMdl_configuration_add_resource_path(self, path)

    def remove_resource_path(self, path):
        r"""
        Removes a path from the list of paths to search for resources, i.e., textures, light
        profiles, and BSDF measurements.

        Note that for MDL resources referenced in .``mdl`` files the MDL search paths are considered,
        not the resource search path. By default, the list of resource paths is empty.

        :type path: string
        :param path:                The path to be removed.
        :rtype: int
        :return: 
                                       -  0: Success.
                                       - -1: Invalid parameters ( ``NULL`` pointer).
                                       - -2: There is no such path in the path list.
        """
        return _pymdlsdk._IMdl_configuration_remove_resource_path(self, path)

    def clear_resource_paths(self):
        r"""
        Clears the list of paths to search for resources, i.e., textures, light profiles,
        and BSDF measurements.

        Note that for MDL resources referenced in .``mdl`` files the MDL search paths are considered,
        not the resource search path. By default, the list of resource paths is empty.
        """
        return _pymdlsdk._IMdl_configuration_clear_resource_paths(self)

    def get_resource_paths_length(self):
        r"""
        Returns the number of paths to search for resources, i.e., textures, light profiles,
        and BSDF measurements.

        Note that for MDL resources referenced in .``mdl`` files the MDL search paths are considered,
        not the resource search path. By default, the list of resource paths is empty.

        :rtype: int
        :return: The number of currently configured paths.
        """
        return _pymdlsdk._IMdl_configuration_get_resource_paths_length(self)

    def get_resource_path(self, index):
        r"""
        Returns the ``index`` -th path to search for resources, i.e., textures, light profiles,
        and BSDF measurements.

        Note that for MDL resources referenced in .``mdl`` files the MDL search paths are considered,
        not the resource search path. By default, the list of resource paths is empty.

        :rtype: :py:class:`IString`
        :return: The ``index`` -th path, or ``NULL`` if ``index`` is out of bounds.
        """
        return _pymdlsdk._IMdl_configuration_get_resource_path(self, index)

    def set_implicit_cast_enabled(self, value):
        r"""
        Defines whether a cast operator is automatically inserted for compatible argument types.

        If set to ``true``, an appropriate cast operator is automatically inserted if arguments for
        instances of #mi::neuraylib::IFunction_call or #mi::neuraylib::IMaterial_instance have a
        different but compatible type. If set to ``false``, such an assignment fails and it is
        necessary to insert the cast operator explicitly. Default: ``true``.

        See also: #mi::neuraylib::IExpression_factory::create_cast().

        :type value: boolean
        :param value:    ``True`` to enable the feature, ``false`` otherwise.
        :rtype: int
        :return: 
                           -  0: Success.
                           - -1: The method cannot be called at this point of time.
        """
        return _pymdlsdk._IMdl_configuration_set_implicit_cast_enabled(self, value)

    def get_implicit_cast_enabled(self):
        r"""
        Indicates whether the SDK is supposed to automatically insert the cast operator for
        compatible types.

        See also: #set_implicit_cast_enabled()
        """
        return _pymdlsdk._IMdl_configuration_get_implicit_cast_enabled(self)

    def set_expose_names_of_let_expressions(self, value):
        r"""
        Defines whether an attempt is made to expose names of let expressions.

        If set to ``true``, the MDL compiler attempts to represent let expressions as temporaries,
        and makes the name of let expressions available as names of such temporaries. In order to
        do so, certain optimizations are disabled, in particular, constant folding. These names are
        only available on material and functions definitions, not on compiled materials, which are
        always highly optimized. Default: ``true``.

        Notes: Since some optimizations are essential for inner workings of the MDL compiler, there

        See also: #mi::neuraylib::IFunction_definition::get_temporary_name(),
             #mi::neuraylib::IMaterial_definition::get_temporary_name()
        """
        return _pymdlsdk._IMdl_configuration_set_expose_names_of_let_expressions(self, value)

    def get_expose_names_of_let_expressions(self):
        r"""
        Indicates whether an attempt is made to expose names of let expressions.

        See also: #set_expose_names_of_let_expressions()
        """
        return _pymdlsdk._IMdl_configuration_get_expose_names_of_let_expressions(self)

    def set_simple_glossy_bsdf_legacy_enabled(self, value):
        r"""
        Configures the behavior of ``df::simple_glossy_bsdf()`` in MDL modules
        of versions smaller than 1.3.

        Notes: If: IRAY_API { This setting can only be configured before The MDL SDKhas been
              started. }Else: This function has no effect in the MDL SDK and always returns -1. {
              }

        :type value: boolean
        :param value:    ``True`` to enable the feature, ``false`` otherwise.
        :rtype: int
        :return: 
                           -  0: Success.
                           - -1: The method cannot be called at this point of time.
        """
        return _pymdlsdk._IMdl_configuration_set_simple_glossy_bsdf_legacy_enabled(self, value)

    def get_simple_glossy_bsdf_legacy_enabled(self):
        r"""
        Returns ``true`` if the legacy behavior for bsdfs of type ``df::simple_glossy_bsdf()`` used
        in MDL modules with versions smaller that 1.3 is enabled, ``false`` otherwise.
        """
        return _pymdlsdk._IMdl_configuration_get_simple_glossy_bsdf_legacy_enabled(self)

    def get_entity_resolver(self):
        r"""
        Returns an instance of the built-in entity resolver.

        Notes: The returned instance contains a copy of the currently configured search paths,
              subsequent changes to the search paths are not reflected in this instance.
        """
        return _pymdlsdk._IMdl_configuration_get_entity_resolver(self)

    def set_entity_resolver(self, resolver):
        r"""
        Installs an external entity resolver.

        :type resolver: mi::neuraylib::IMdl_entity_resolver
        :param resolver:   The external entity resolver to be used instead of the built-in entity
                              resolver. Pass ``NULL`` to uninstall a previously installed external
                              entity resolver.

        Notes: MDL archive creation is not supported with an external entity resolver ( see
              #mi::neuraylib::IMdl_archive_api::create_archive()).
        """
        return _pymdlsdk._IMdl_configuration_set_entity_resolver(self, resolver)

    def set_materials_are_functions(self, value):
        r"""
        Defines whether materials are treated as functions.

        From an MDL language point of view ['MDLLS]', materials look quite similar to functions
        with the ``material`` struct as return type. However, in the MDL SDK APIseparate
        interfaces like #mi::neuraylib::IMaterial_definition and #mi::neuraylib::IMaterial_instance
        are used for materials, in contrast to #mi::neuraylib::IFunction_definition and
        #mi::neuraylib::IFunction_call for functions (although these interfaces are quite similar).
        This requires that code that acts in a similar way on both, functions and materials, needs
        to be written twice.

        If this feature is enabled, then materials are treated as functions, i.e., it is possible to
        use #mi::neuraylib::IFunction_definition instead of #mi::neuraylib::IMaterial_definition,
        and #mi::neuraylib::IFunction_call instead of #mi::neuraylib::IMaterial_instance. This allows
        to write code that acts on both, functions and materials, just once. The only exception is
        the method #mi::neuraylib::IMaterial_instance::create_compiled_material(), which still
        requires to use the #mi::neuraylib::IMaterial_instance interface.

        Enabling this feature comes with a few API changes that need to be takes into account. Code
        shared between different applications, i.e., in plugins, should be able to handle both
        settings.

        - **Values returned by #mi::neuraylib::IScene_element::get_element_type() (and derived
          interfaces)**



          The method mi::neuraylib::IScene_element::get_element_type() returns
          #mi::neuraylib::ELEMENT_TYPE_FUNCTION_DEFINITION instead of
          #mi::neuraylib::ELEMENT_TYPE_MATERIAL_DEFINITION. The value
          #mi::neuraylib::ELEMENT_TYPE_MATERIAL_DEFINITION is only returned by
          #mi::neuraylib::IMaterial_definition::get_element_type() (for backward compatibility),
          but no longer by its base class #mi::neuraylib::IScene_element.



          Similarly, the method mi::neuraylib::IScene_element::get_element_type() returns
          #mi::neuraylib::ELEMENT_TYPE_FUNCTION_CALL instead of
          #mi::neuraylib::ELEMENT_TYPE_MATERIAL_INSTANCE. The value
          #mi::neuraylib::ELEMENT_TYPE_MATERIAL_INSTANCE is only returned by
          #mi::neuraylib::IMaterial_instance::get_element_type() (for backward compatibility), but
          no longer by its base class #mi::neuraylib::IScene_element.



          As a consequence, #mi::neuraylib::Definition_wrapper::get_type() and
          #mi::neuraylib::Definition_wrapper::get_element_type() only return
          #mi::neuraylib::ELEMENT_TYPE_FUNCTION_DEFINITION. Similarly,
          #mi::neuraylib::Argument_editor::get_type() and
          #mi::neuraylib::Argument_editor::get_element_type() only return
          #mi::neuraylib::ELEMENT_TYPE_FUNCTION_CALL.
        .
        - **Interface queries to distinguish functions and materials**



          Interface queries like
          #mi::base::IInterface::get_interface<mi::neuraylib::IFunction_definition>() can no longer
          be used to distinguish functions and materials. Note that such queries might occur inside
          other template inline methods, e.g., they occur as part of
          #mi::neuraylib::ITransaction::access<mi::neuraylib::IFunction_definition>(). The
          recommended way to do this is using #mi::neuraylib::IFunction_definition::is_material().
          Similarly for #mi::base::IInterface::get_interface<mi::neuraylib::IFunction_call>() and
          #mi::neuraylib::IFunction_call::is_material().
        .
        - **Type names passed to #mi::neuraylib::ITransaction::list_elements()**



          The method #mi::neuraylib::ITransaction::list_elements() will not return any hits for
          type names ``"Material_definition"`` and ``"Material_instance"``. Use the type names
          ``"Function_definition"`` and ``"Function_call"`` instead, and, if necessary,
          #mi::neuraylib::IFunction_definition::is_material() and
          #mi::neuraylib::IFunction_call::is_material() to discriminate the results.

        This feature is disabled by default. It will be enabled by default in a future release.

        This can only be configured before the MDL SDKhas been started.

        See also: #get_materials_are_functions().
        """
        return _pymdlsdk._IMdl_configuration_set_materials_are_functions(self, value)

    def get_materials_are_functions(self):
        r"""
        Indicates whether materials are treated as functions.

        See also: #set_materials_are_functions().
        """
        return _pymdlsdk._IMdl_configuration_get_materials_are_functions(self)

    def set_encoded_names_enabled(self, value):
        r"""
        Defines whether encoded names are enabled.

        See 'mi_mdl_encoded_names' for details.

        This feature is enabled by default. Support for the disabled feature will be deprecated and
        removed in a future release.

        This can only be configured before the MDL SDKhas been started.

        Notes: This feature does not yet support module names containing parentheses or commas.

        If: IRAY_API { Notes: All hosts in a cluster need to agree on this setting. }

        If: IRAY_API { Notes: This setting needs to be the identical during export and import of
                           ``.mib`` files. }

        If: IRAY_API { Notes: Support for Iray Bridge requires that this feature is enabled. }

        See also: #get_encoded_names_enabled().
        """
        return _pymdlsdk._IMdl_configuration_set_encoded_names_enabled(self, value)

    def get_encoded_names_enabled(self):
        r"""
        Indicates whether encoded names are enabled.

        See also: #set_encoded_names_enabled().
        """
        return _pymdlsdk._IMdl_configuration_get_encoded_names_enabled(self)

# Register _IMdl_configuration in _pymdlsdk:
_pymdlsdk._IMdl_configuration_swigregister(_IMdl_configuration)

class Interface_declare_IMessage(object):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IMessage_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IMessage

# Register Interface_declare_IMessage in _pymdlsdk:
_pymdlsdk.Interface_declare_IMessage_swigregister(Interface_declare_IMessage)

def Interface_declare_IMessage_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IMessage_compare_iid(iid)

class _IMessage(Interface_declare_IMessage):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    MSG_COMILER_CORE = _pymdlsdk._IMessage_MSG_COMILER_CORE
    r""" MDL Core compiler message."""
    MSG_COMILER_BACKEND = _pymdlsdk._IMessage_MSG_COMILER_BACKEND
    r""" MDL Core compiler backend message."""
    MSG_COMPILER_DAG = _pymdlsdk._IMessage_MSG_COMPILER_DAG
    r""" MDL Core DAG generator message."""
    MSG_COMPILER_ARCHIVE_TOOL = _pymdlsdk._IMessage_MSG_COMPILER_ARCHIVE_TOOL
    r""" MDL Core archive tool message."""
    MSG_IMP_EXP = _pymdlsdk._IMessage_MSG_IMP_EXP
    r""" MDL import/exporter message."""
    MSG_INTEGRATION = _pymdlsdk._IMessage_MSG_INTEGRATION
    r""" MDL integration message."""
    MSG_UNCATEGORIZED = _pymdlsdk._IMessage_MSG_UNCATEGORIZED
    r""" Uncategorized messages do not have a code."""
    MSG_FORCE_32_BIT = _pymdlsdk._IMessage_MSG_FORCE_32_BIT

    def get_kind(self):
        r""" Returns the kind of message."""
        return _pymdlsdk._IMessage_get_kind(self)

    def get_severity(self):
        r""" Returns the severity of the message."""
        return _pymdlsdk._IMessage_get_severity(self)

    def get_string(self):
        r""" Returns the message string."""
        return _pymdlsdk._IMessage_get_string(self)

    def get_code(self):
        r""" Returns a unique identifier for the message."""
        return _pymdlsdk._IMessage_get_code(self)

    def get_notes_count(self):
        r"""
        Returns the number of notes associated with the message

        Notes can be used to describe an error message further or add additional details.
        """
        return _pymdlsdk._IMessage_get_notes_count(self)

    def get_note(self, index):
        r""" Returns the note at index or ``NULL``, if no such index exists."""
        return _pymdlsdk._IMessage_get_note(self, index)

# Register _IMessage in _pymdlsdk:
_pymdlsdk._IMessage_swigregister(_IMessage)

class Interface_declare_IMdl_execution_context(object):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IMdl_execution_context_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IMdl_execution_context

# Register Interface_declare_IMdl_execution_context in _pymdlsdk:
_pymdlsdk.Interface_declare_IMdl_execution_context_swigregister(Interface_declare_IMdl_execution_context)

def Interface_declare_IMdl_execution_context_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IMdl_execution_context_compare_iid(iid)

class _IMdl_execution_context(Interface_declare_IMdl_execution_context):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_messages_count(self):
        r""" Returns the number of messages."""
        return _pymdlsdk._IMdl_execution_context_get_messages_count(self)

    def get_error_messages_count(self):
        r""" Returns the number of error messages."""
        return _pymdlsdk._IMdl_execution_context_get_error_messages_count(self)

    def get_message(self, index):
        r""" Returns the message at index or ``NULL``, if no such index exists."""
        return _pymdlsdk._IMdl_execution_context_get_message(self, index)

    def get_error_message(self, index):
        r""" Returns the error message at index or ``NULL``, if no such index exists."""
        return _pymdlsdk._IMdl_execution_context_get_error_message(self, index)

    def clear_messages(self):
        r""" Clears all messages."""
        return _pymdlsdk._IMdl_execution_context_clear_messages(self)

    def add_message(self, kind, severity, code, message):
        r""" Adds a message."""
        return _pymdlsdk._IMdl_execution_context_add_message(self, kind, severity, code, message)

    def get_option_count(self):
        r""" Returns the number of supported options."""
        return _pymdlsdk._IMdl_execution_context_get_option_count(self)

    def get_option_name(self, index):
        r""" Returns the option name at index."""
        return _pymdlsdk._IMdl_execution_context_get_option_name(self, index)

    def get_option_type(self, name):
        r""" Returns the option type name at index."""
        return _pymdlsdk._IMdl_execution_context_get_option_type(self, name)

    def get_option(self, *args):
        r"""
        *Overload 1:*
        Returns a string option.

        :type name: string
        :param name:          The name of the option.
        :type value: string, out
        :param value:    The value of the option.
        :rtype: int
        :return: 
                                 -  0: Success.
                                 - -1: Invalid option name.
                                 - -2: The option type does not match the value type.

        |

        *Overload 2:*
        Returns an int option.

        :type name: string
        :param name:          The name of the option.
        :type value: int, out
        :param value:    The value of the option.
        :rtype: int
        :return: 
                                 -  0: Success.
                                 - -1: Invalid option name.
                                 - -2: The option type does not match the value type.

        |

        *Overload 3:*
        Returns a float option.

        :type name: string
        :param name:          The name of the option.
        :type value: float, out
        :param value:    The value of the option.
        :rtype: int
        :return: 
                                 -  0: Success.
                                 - -1: Invalid option name.
                                 - -2: The option type does not match the value type.

        |

        *Overload 4:*
        Returns a bool option.

        :type name: string
        :param name:          The name of the option.
        :type value: boolean, out
        :param value:    The value of the option.
        :rtype: int
        :return: 
                                 -  0: Success.
                                 - -1: Invalid option name.
                                 - -2: The option type does not match the value type.

        |

        *Overload 5:*
        Returns an interface option.

        :type name: string
        :param name:          The name of the option.
        :type value: mi::base::IInterface, out
        :param value:    The value of the option.
        :rtype: int
        :return: 
                                 -  0: Success.
                                 - -1: Invalid option name.
                                 - -2: The option type does not match the value type.
        """
        return _pymdlsdk._IMdl_execution_context_get_option(self, *args)

    def set_option(self, *args):
        r"""
        *Overload 1:*
        Sets a string option.

        :type name: string
        :param name:     The name of the option.
        :type value: string
        :param value:    The value of the option.
        :rtype: int
        :return: 
                            -  0: Success.
                            - -1: Invalid option name.
                            - -2: The option type does not match the value type.

        |

        *Overload 2:*
        Sets an int option.

        :type name: string
        :param name:     The name of the option.
        :type value: int
        :param value:    The value of the option.
        :rtype: int
        :return: 
                            -  0: Success.
                            - -1: Invalid option name.
                            - -2: The option type does not match the value type.

        |

        *Overload 3:*
        Sets a float option.

        :type name: string
        :param name:     The name of the option.
        :type value: float
        :param value:    The value of the option.
        :rtype: int
        :return: 
                            -  0: Success.
                            - -1: Invalid option name.
                            - -2: The option type does not match the value type.

        |

        *Overload 4:*
        Sets a bool option.

        :type name: string
        :param name:     The name of the option.
        :type value: boolean
        :param value:    The value of the option.
        :rtype: int
        :return: 
                            -  0: Success.
                            - -1: Invalid option name.
                            - -2: The option type does not match the value type.
                            - -3: The value is invalid in the context of the option.

        |

        *Overload 5:*
        Sets an interface option.

        :type name: string
        :param name:     The name of the option.
        :type value: mi::base::IInterface
        :param value:    The value of the option.
        :rtype: int
        :return: 
                            -  0: Success.
                            - -1: Invalid option name.
                            - -2: The option type does not match the value type.
                            - -3: The value is invalid in the context of the option.
        """
        return _pymdlsdk._IMdl_execution_context_set_option(self, *args)

# Register _IMdl_execution_context in _pymdlsdk:
_pymdlsdk._IMdl_execution_context_swigregister(_IMdl_execution_context)

class Interface_declare_IMdl_factory(object):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IMdl_factory_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IMdl_factory

# Register Interface_declare_IMdl_factory in _pymdlsdk:
_pymdlsdk.Interface_declare_IMdl_factory_swigregister(Interface_declare_IMdl_factory)

def Interface_declare_IMdl_factory_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IMdl_factory_compare_iid(iid)

class _IMdl_factory(Interface_declare_IMdl_factory):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def create_type_factory(self, transaction):
        r""" Returns an MDL type factory for the given transaction."""
        return _pymdlsdk._IMdl_factory_create_type_factory(self, transaction)

    def create_value_factory(self, transaction):
        r""" Returns an MDL value factory for the given transaction."""
        return _pymdlsdk._IMdl_factory_create_value_factory(self, transaction)

    def create_expression_factory(self, transaction):
        r""" Returns an MDL expression factory for the given transaction."""
        return _pymdlsdk._IMdl_factory_create_expression_factory(self, transaction)

    def create_execution_context(self):
        r""" Creates an execution context."""
        return _pymdlsdk._IMdl_factory_create_execution_context(self)

    def create_texture_with_ret(self, transaction, file_path, shape, gamma, shared):
        r"""
        Creates a value referencing a texture identified by an MDL file path.

        :type transaction: :py:class:`ITransaction`
        :param transaction:   The transaction to be used.
        :type file_path: string
        :param file_path:     The absolute MDL file path that identifies the texture. The MDL
                                 search paths are used to resolve the file path. See section 2.2 in
                                 ['MDLLS]' for details.
        :type shape: int
        :param shape:         The value that is returned by
                                 #mi::neuraylib::IType_texture::get_shape() on the type corresponding
                                 to the return value.
        :type gamma: float
        :param gamma:         The value that is returned by #mi::neuraylib::ITexture::get_gamma()
                                 on the DB element referenced by the return value.
        :type shared: boolean
        :param shared:        Indicates whether you want to re-use the DB elements for that texture
                                 if it has already been loaded, or if you want to create new DB elements
                                 in all cases. Note that sharing is based on the location where the
                                 texture is finally located and includes sharing with instances that
                                 have not explicitly been loaded via this method, e.g., textures in
                                 defaults.
        :type errors: int, optional
        :param errors:        An optional pointer to an #mi::Sint32 to which an error code will be
                                 written. The error codes have the following meaning:
                                 -  0: Success.
                                 - -1: Invalid parameters (``NULL`` pointer).
                                 - -2: The file path is not an absolute MDL file path.
                                 - -3: Failed to resolve the given file path, or no suitable image
                                       plugin available.
        :rtype: :py:class:`IValue_texture`
        :return: The value referencing the texture, or ``NULL`` in case of failure.
        """
        return _pymdlsdk._IMdl_factory_create_texture_with_ret(self, transaction, file_path, shape, gamma, shared)

    def create_texture(self, transaction, file_path, shape, gamma, shared):
        r"""
        Creates a value referencing a texture identified by an MDL file path.

        :type transaction: :py:class:`ITransaction`
        :param transaction:   The transaction to be used.
        :type file_path: string
        :param file_path:     The absolute MDL file path that identifies the texture. The MDL
                                 search paths are used to resolve the file path. See section 2.2 in
                                 ['MDLLS]' for details.
        :type shape: int
        :param shape:         The value that is returned by
                                 #mi::neuraylib::IType_texture::get_shape() on the type corresponding
                                 to the return value.
        :type gamma: float
        :param gamma:         The value that is returned by #mi::neuraylib::ITexture::get_gamma()
                                 on the DB element referenced by the return value.
        :type shared: boolean
        :param shared:        Indicates whether you want to re-use the DB elements for that texture
                                 if it has already been loaded, or if you want to create new DB elements
                                 in all cases. Note that sharing is based on the location where the
                                 texture is finally located and includes sharing with instances that
                                 have not explicitly been loaded via this method, e.g., textures in
                                 defaults.
        :param errors:        An optional pointer to an #mi::Sint32 to which an error code will be
                                 written. The error codes have the following meaning:
                                 -  0: Success.
                                 - -1: Invalid parameters (``NULL`` pointer).
                                 - -2: The file path is not an absolute MDL file path.
                                 - -3: Failed to resolve the given file path, or no suitable image
                                       plugin available.
        :rtype: :py:class:`IValue_texture`
        :return: The value referencing the texture, or ``NULL`` in case of failure.
        """
        return _pymdlsdk._IMdl_factory_create_texture(self, transaction, file_path, shape, gamma, shared)

    def create_light_profile_with_ret(self, transaction, file_path, shared):
        r"""
        Creates a value referencing a light profile identified by an MDL file path.

        :type transaction: :py:class:`ITransaction`
        :param transaction:   The transaction to be used.
        :type file_path: string
        :param file_path:     The absolute MDL file path that identifies the light profile. The MDL
                                 search paths are used to resolve the file path. See section 2.2 in
                                 ['MDLLS]' for details.
        :type shared: boolean
        :param shared:        Indicates whether you want to re-use the DB element for that light
                                 profile if it has already been loaded, or if you want to create a new
                                 DB element in all cases. Note that sharing is based on the location
                                 where the light profile is finally located and includes sharing with
                                 instances that have not explicitly been loaded via this method, e.g.,
                                 light profiles in defaults.
        :type errors: int, optional
        :param errors:        An optional pointer to an #mi::Sint32 to which an error code will be
                                 written. The error codes have the following meaning:
                                 -  0: Success.
                                 - -1: Invalid parameters (``NULL`` pointer).
                                 - -2: The file path is not an absolute MDL file path.
                                 - -3: Failed to resolve the given file path.
        :rtype: :py:class:`IValue_light_profile`
        :return: The value referencing the light profile, or ``NULL`` in case of failure.
        """
        return _pymdlsdk._IMdl_factory_create_light_profile_with_ret(self, transaction, file_path, shared)

    def create_light_profile(self, transaction, file_path, shared):
        r"""
        Creates a value referencing a light profile identified by an MDL file path.

        :type transaction: :py:class:`ITransaction`
        :param transaction:   The transaction to be used.
        :type file_path: string
        :param file_path:     The absolute MDL file path that identifies the light profile. The MDL
                                 search paths are used to resolve the file path. See section 2.2 in
                                 ['MDLLS]' for details.
        :type shared: boolean
        :param shared:        Indicates whether you want to re-use the DB element for that light
                                 profile if it has already been loaded, or if you want to create a new
                                 DB element in all cases. Note that sharing is based on the location
                                 where the light profile is finally located and includes sharing with
                                 instances that have not explicitly been loaded via this method, e.g.,
                                 light profiles in defaults.
        :param errors:        An optional pointer to an #mi::Sint32 to which an error code will be
                                 written. The error codes have the following meaning:
                                 -  0: Success.
                                 - -1: Invalid parameters (``NULL`` pointer).
                                 - -2: The file path is not an absolute MDL file path.
                                 - -3: Failed to resolve the given file path.
        :rtype: :py:class:`IValue_light_profile`
        :return: The value referencing the light profile, or ``NULL`` in case of failure.
        """
        return _pymdlsdk._IMdl_factory_create_light_profile(self, transaction, file_path, shared)

    def create_bsdf_measurement_with_ret(self, transaction, file_path, shared):
        r"""
        Creates a value referencing a BSDF measurement identified by an MDL file path.

        :type transaction: :py:class:`ITransaction`
        :param transaction:   The transaction to be used.
        :type file_path: string
        :param file_path:     The absolute MDL file path that identifies the BSDF measurement. The
                                 MDL search paths are used to resolve the file path. See section 2.2 in
                                 ['MDLLS]' for details.
        :type shared: boolean
        :param shared:        Indicates whether you want to re-use the DB element for that BSDF
                                 measurement if it has already been loaded, or if you want to create a
                                 new DB element in all cases. Note that sharing is based on the location
                                 where the BSDF measurement is finally located and includes sharing with
                                 instances that have not explicitly been loaded via this method, e.g.,
                                 BSDF measurements in defaults.
        :type errors: int, optional
        :param errors:        An optional pointer to an #mi::Sint32 to which an error code will be
                                 written. The error codes have the following meaning:
                                 -  0: Success.
                                 - -1: Invalid parameters (``NULL`` pointer).
                                 - -2: The file path is not an absolute MDL file path.
                                 - -3: Failed to resolve the given file path.
        :rtype: :py:class:`IValue_bsdf_measurement`
        :return: The value referencing the BSDF measurement, or ``NULL`` in case of
                                 failure.
        """
        return _pymdlsdk._IMdl_factory_create_bsdf_measurement_with_ret(self, transaction, file_path, shared)

    def create_bsdf_measurement(self, transaction, file_path, shared):
        r"""
        Creates a value referencing a BSDF measurement identified by an MDL file path.

        :type transaction: :py:class:`ITransaction`
        :param transaction:   The transaction to be used.
        :type file_path: string
        :param file_path:     The absolute MDL file path that identifies the BSDF measurement. The
                                 MDL search paths are used to resolve the file path. See section 2.2 in
                                 ['MDLLS]' for details.
        :type shared: boolean
        :param shared:        Indicates whether you want to re-use the DB element for that BSDF
                                 measurement if it has already been loaded, or if you want to create a
                                 new DB element in all cases. Note that sharing is based on the location
                                 where the BSDF measurement is finally located and includes sharing with
                                 instances that have not explicitly been loaded via this method, e.g.,
                                 BSDF measurements in defaults.
        :param errors:        An optional pointer to an #mi::Sint32 to which an error code will be
                                 written. The error codes have the following meaning:
                                 -  0: Success.
                                 - -1: Invalid parameters (``NULL`` pointer).
                                 - -2: The file path is not an absolute MDL file path.
                                 - -3: Failed to resolve the given file path.
        :rtype: :py:class:`IValue_bsdf_measurement`
        :return: The value referencing the BSDF measurement, or ``NULL`` in case of
                                 failure.
        """
        return _pymdlsdk._IMdl_factory_create_bsdf_measurement(self, transaction, file_path, shared)

    def create_module_builder(self, transaction, module_name, min_module_version, max_module_version, context):
        r"""
        Creates a module builder for a given module.

        :type transaction: :py:class:`ITransaction`
        :param transaction:          The transaction to be used.
        :type module_name: string
        :param module_name:          The DB name of the MDL module to build. If there is no such
                                        module, then an empty module with this name and
           ``min_module_version`` is created. Otherwise, the existing module
                                        is edited. Builtin modules or MDLE modules cannot be built or
                                        edited.
        :type min_module_version: int
        :param min_module_version:   The initial MDL version of the new module. Ignored if the
                                        module exists already.
        :type max_module_version: int
        :param max_module_version:   The maximal desired MDL version of the module. If higher than
                                        the current MDL version of the module, then the module builder
                                        will upgrade the MDL version as necessary to handle requests
                                        requiring newer features.
        :type context: :py:class:`IMdl_execution_context`
        :param context:              An execution context which can be queried for detailed error
                                        messages after the operation has finished. Can be ``NULL``.
        :rtype: mi::neuraylib::IMdl_module_builder
        :return: The module builder for the given module, or ``NULL`` in
                                        case of errors.
        """
        return _pymdlsdk._IMdl_factory_create_module_builder(self, transaction, module_name, min_module_version, max_module_version, context)

    def create_module_transformer(self, transaction, module_name, context):
        r"""
        Creates a module transformer for a given module.

        :type transaction: :py:class:`ITransaction`
        :param transaction:   The transaction to be used.
        :type module_name: string
        :param module_name:   The DB name of the MDL module to transform. Builtin modules cannot be
                                 transformed.
        :type context: :py:class:`IMdl_execution_context`
        :param context:       An execution context which can be queried for detailed error messages
                                 after the operation has finished. Can be ``NULL``.
        :rtype: mi::neuraylib::IMdl_module_transformer
        :return: The module transformer for the given module, or ``NULL`` in case of
                                 errors.
        """
        return _pymdlsdk._IMdl_factory_create_module_transformer(self, transaction, module_name, context)

    def get_db_module_name(self, mdl_name):
        r"""
        Returns the DB name for the MDL name of a module (or file path for MDLE modules).

        For example, given ``"::state"``, the method returns ``"mdl::state"``.

        Notes: This method does not check for existence of the corresponding DB element, nor does it
              check that the input is a valid module name.

        Usage of this method is strongly recommended instead of manually prepending ``"mdl"``,
              since (a) the mapping is more complicated than that, e.g., for MDLE modules, and (b)
              the mapping might change in the future.

        :type mdl_name: string
        :param mdl_name:      The MDL name of the module (non-MDLE and MDLE module), or the file path
                                 of an MDLE module.
        :rtype: :py:class:`IString`
        :return: The DB name of that module, or ``NULL`` if ``mdl_name`` is invalid.
        """
        return _pymdlsdk._IMdl_factory_get_db_module_name(self, mdl_name)

    def get_db_definition_name(self, mdl_name):
        r"""
        Returns the DB name for the MDL name of an material or function definition.

        For example, given ``"::state::normal()"``, the method returns ``"mdl::state::normal()"``.

        Notes: This method does not check for existence of the corresponding DB element, nor does it
              check that the input is a valid material or definition name.

        Usage of this method is strongly recommended instead of manually prepending ``"mdl"``,
              since (a) the mapping is more complicated than that, e.g., for MDLE modules, and (b)
              the mapping might change in the future.

        :type mdl_name: string
        :param mdl_name:      The MDL name of the material or function definition.
        :rtype: :py:class:`IString`
        :return: The DB name of that material or function definition, or ``NULL`` if
                                 ``mdl_name`` is invalid.
        """
        return _pymdlsdk._IMdl_factory_get_db_definition_name(self, mdl_name)

    def analyze_uniform(self, transaction, root_name, root_uniform, query_expr, query_result, error_path, context):
        r"""
         Analyzes whether an expression graph violates the uniform constraints.

         Notes: This method can be used to check already created graphs, but it can also be used to
               check whether a hypothetical connection would observe the uniform constraints: First,
               invoke the method with the root of the existing graph, ``root_uniform`` set to
        ``false`` (at least for materials), and ``query_expr`` set to the graph node to be
               replaced. If the call returns with ``query_result`` set to ``false`` (and no errors in
               the context), then any (valid) subgraph can be connected. Otherwise, invoke the
               method again with the root of the to-be-connected subgraph, ``root_uniform`` set to
        ``true``, and ``query_expr`` set to ``NULL``. If there are no errors, then the subgraph
               can be connected.

         Make sure that ``query_expr`` (if not ``NULL)`` can be reached from ``root_name``,
               otherwise ``query_result`` is always ``false``. In particular, arguments passed during
               call creation (or later for argument changes) are cloned, and the expression that is
               part of the graph is different from the one that was used to construct the graph
               (equal, but not identical).

         :type transaction: :py:class:`ITransaction`
         :param transaction:             The transaction to be used.
         :type root_name: string
         :param root_name:               DB name of the root node of the graph (material instance or
                                            function call).
         :type root_uniform: boolean
         :param root_uniform:            Indicates whether the root node should be uniform.
         :type query_expr: :py:class:`IExpression`
         :param query_expr:              A node of the call graph for which the uniform property is
                                            to be queried. This expression is *only* used to identify
                                            the corresponding node in the graph, i.e., it even makes
                                            sense to pass constant expressions (which by themselves are
                                            always uniform) to determine whether a to-be-connected call
                                            expression has to be uniform. Can be ``NULL``.
         :type query_result: boolean, out
         :param query_result:       Indicates whether ``query_expr`` needs to be uniform (or
                                            ``false`` if ``query_expr`` is ``NULL``, or in case of errors).
         :type error_path: :py:class:`IString`, out
         :param error_path:         A path to a node of the graph that violates the uniform
                                            constraints, or the empty string if there is no such node
                                            (or in case of errors). Such violations are also reported
                                            via ``context``. Can be ``NULL``.
         :type context: :py:class:`IMdl_execution_context`
         :param context:                 The execution context can be used to pass options and to
                                            retrieve error and/or warning messages. Can be ``NULL``.
        """
        return _pymdlsdk._IMdl_factory_analyze_uniform(self, transaction, root_name, root_uniform, query_expr, query_result, error_path, context)

    def decode_name(self, name):
        r"""
        Decodes a DB or MDL name.

        :type name: string
        :param name:   The encoded DB or MDL name to be decoded.
        :rtype: :py:class:`IString`
        :return: The decoded DB or MDL name, or ``NULL`` if ``name`` is ``NULL``. Returns the
                          input string if encoded names are disabled.

        Notes: This method should only be used for display purposes. Do *not* use the returned
              name to identify functions or materials since this representation is ambiguous. For
              modules, it is possible to re-encode their name without loss of information, see
              #encode_module_name(). This is *not* possible for names of function or material
              definitions.

        This method does not require the corresponding module to be loaded. The method does
              not check whether the given name is valid, nor whether it is defined in the
              corresponding module.
        """
        return _pymdlsdk._IMdl_factory_decode_name(self, name)

    def encode_module_name(self, name):
        r"""
        Encodes a DB or MDL module name.

        :type name: string
        :param name:    The decoded DB or MDL module name to be encoded.
        :rtype: :py:class:`IString`
        :return: The encoded DB or MDL module name, or ``NULL`` if ``name`` is ``NULL``. Returns
                           the input string if encoded names are disabled.

        Notes: This method does not require the corresponding module to be loaded. The method does
              not check whether the given name is valid.

        See also: #mi::neuraylib::IMdl_factory::encode_function_definition_name(),
             #mi::neuraylib::IMdl_factory::encode_type_name()
        """
        return _pymdlsdk._IMdl_factory_encode_module_name(self, name)

    def encode_function_definition_name(self, name, parameter_types):
        r"""
        Encodes a DB or MDL function or material definition name.

        :type name: string
        :param name:             The decoded DB or MDL name of a function or material definition
                                    *without* signature.
        :type parameter_types: :py:class:`IArray`
        :param parameter_types:  A static or dynamic array with elements of type #mi::IString
                                    representing decoded positional parameter type names. The value
                                    ``NULL`` can be used for functions or materials without parameters
                                    (treated like an empty array).
        :rtype: :py:class:`IString`
        :return: The encoded function or material definition name, or ``NULL`` if
                                    ``name`` or one of the array elements is ``NULL``. If encoded names
                                    are disabled, then the individual components of the name are joined
                                    by parentheses and commas without further encoding.

        Notes: This method does not require the corresponding module to be loaded. The method does
              not check whether the given name is valid, nor whether it is defined in the
              corresponding module.

        See also: #mi::neuraylib::IMdl_factory::encode_module_name(),
             #mi::neuraylib::IMdl_factory::encode_type_name()
        """
        return _pymdlsdk._IMdl_factory_encode_function_definition_name(self, name, parameter_types)

    def encode_type_name(self, name):
        r"""
        Encodes an MDL type name.

        :type name: string
        :param name:             The decoded MDL name of a type.
        :rtype: :py:class:`IString`
        :return: The encoded MDL name of the type, or ``NULL`` if ``name`` is ``NULL``.
                                    Returns the input string if encoded names are disabled

        Notes: This method does not require the corresponding module to be loaded. The method does
              not check whether the given name is valid, nor whether it is defined in the
              corresponding module.

        See also: #mi::neuraylib::IMdl_factory::encode_function_definition_name(),
             #mi::neuraylib::IMdl_factory::encode_module_name()
        """
        return _pymdlsdk._IMdl_factory_encode_type_name(self, name)

    def deprecated_create_variants(self, transaction, module_name, variant_data):
        return _pymdlsdk._IMdl_factory_deprecated_create_variants(self, transaction, module_name, variant_data)

    def deprecated_create_materials(self, *args):
        return _pymdlsdk._IMdl_factory_deprecated_create_materials(self, *args)

# Register _IMdl_factory in _pymdlsdk:
_pymdlsdk._IMdl_factory_swigregister(_IMdl_factory)

MDL_REPAIR_DEFAULT = _pymdlsdk.MDL_REPAIR_DEFAULT
r""" Default mode, do not alter any inputs."""
MDL_REMOVE_INVALID_ARGUMENTS = _pymdlsdk.MDL_REMOVE_INVALID_ARGUMENTS
r""" Remove an invalid call attached to an argument."""
MDL_REPAIR_INVALID_ARGUMENTS = _pymdlsdk.MDL_REPAIR_INVALID_ARGUMENTS
r""" Attempt to repair invalid calls attached to an argument."""
MDL_REPAIR_OPTIONS_FORCE_32_BIT = _pymdlsdk.MDL_REPAIR_OPTIONS_FORCE_32_BIT
class Interface_declare_IMdl_impexp_api(object):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IMdl_impexp_api_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IMdl_impexp_api

# Register Interface_declare_IMdl_impexp_api in _pymdlsdk:
_pymdlsdk.Interface_declare_IMdl_impexp_api_swigregister(Interface_declare_IMdl_impexp_api)

def Interface_declare_IMdl_impexp_api_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IMdl_impexp_api_compare_iid(iid)

class _IMdl_impexp_api(Interface_declare_IMdl_impexp_api):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def load_module(self, transaction, argument, context=None):
        r"""
        Loads an MDL module from disk (or a builtin module) into the database.

        The module is located on disk according to the module search paths
        (see #mi::neuraylib::IMdl_configuration::add_mdl_path()), loaded, and compiled.
        If successful, the method creates DB elements for the module and all
        its imported modules, as well as for all material and function definitions contained in
        these modules.

        The method can also be used for builtin modules for which the first step, locating the
        module on disk, is skipped.

        :type transaction: :py:class:`ITransaction`
        :param transaction:   The transaction to be used.
        :type argument: string
        :param argument:      The MDL name of the module (for non-MDLE modules), or an MDLE file
                                 path (absolute or relative to the current working directory).
        :type context: :py:class:`IMdl_execution_context`, optional
        :param context:       The execution context can be used to pass options to control the
                                 behavior of the MDL compiler. The following options are supported
                                 by this operation:
                                 - string "internal_space" = "coordinate_object"|"coordinate_world"
                                   (default = "coordinate_world")
                                 .
                                 During module loading, compiler messages
                                 like errors or warnings are stored in the context. Can be ``NULL``.
        :rtype: int
        :return: 
                                 -  1: Success (module exists already, loading from file was skipped).
                                 -  0: Success (module was actually loaded from file or is a builtin
                                       module).
                                 - -1: The MDL module name/MDLE file path ``argument`` is
                                       invalid or a ``NULL`` pointer.
                                 - -2: Failed to find or to compile the module ``argument``.
                                 - -3: The DB name for an imported module is already in use but is not
                                       an MDL module, or the DB name for a definition in this module is
                                       already in use.
                                 - -4: Initialization of an imported module failed.

        See also: #mi::neuraylib::IMdl_impexp_api::get_mdl_module_name()
        """
        return _pymdlsdk._IMdl_impexp_api_load_module(self, transaction, argument, context)

    def load_module_from_string(self, transaction, module_name, module_source, context=None):
        r"""
        Loads an MDL module from memory into the database.

        The provided module source is compiled. If successful, the method creates DB elements for
        the module and all its imported modules, as well as for all material and function
        definitions contained in these modules.

        :type transaction: :py:class:`ITransaction`
        :param transaction:   The transaction to be used.
        :type module_name: string
        :param module_name:   The MDL name of the module.
        :type module_source: string
        :param module_source: The MDL source code of the module.
        :type context: :py:class:`IMdl_execution_context`, optional
        :param context:       The execution context can be used to pass options to control the
                                 behavior of the MDL compiler. The following options are supported
                                 by this operation:
                                 - string "internal_space" = "coordinate_object"|"coordinate_world"
                                   (default = "coordinate_world")
                                 .
                                 During module loading, compiler messages
                                 like errors or warnings are stored in the context. Can be ``NULL``.
        :rtype: int
        :return: 
                                 -  1: Success (module exists already, creating from ``module_source``
                                       was skipped).
                                 -  0: Success (module was actually created from ``module_source)``.
                                 - -1: The module name ``module_name`` is invalid, or ``module_name`` or
                                       ``module_source`` is a ``NULL`` pointer.
                                 - -2: Shadows a file-based module or failed to compile the module
           ``module_name``.
                                 - -3: The DB name for an imported module is already in use but is not
                                       an MDL module, or the DB name for a definition in this module is
                                       already in use.
                                 - -4: Initialization of an imported module failed.

        See also: #mi::neuraylib::IMdl_impexp_api::get_mdl_module_name()
        """
        return _pymdlsdk._IMdl_impexp_api_load_module_from_string(self, transaction, module_name, module_source, context)

    def export_module(self, transaction, module_name, filename, context=None):
        r"""
        Exports an MDL module from the database to disk.

        The following options are supported:
        - ``"bundle_resources"`` of type bool: If ``true``, referenced resources are exported
          into the same directory as the module, even if they can be found via the module search
          path. Default: ``false``.

        :type transaction: :py:class:`ITransaction`
        :param transaction:       The transaction to be used.
        :type module_name: string
        :param module_name:       The DB name of the MDL module to export.
        :type filename: string
        :param filename:          The name of the file to be used for the export.
        :type context: :py:class:`IMdl_execution_context`, optional
        :param context:           The execution context can be used to pass options to control the
                                     behavior of the MDL compiler. During module loading, compiler
                                     messages like errors or warnings are stored in the context.
                                     Can be ``NULL``.
        :rtype: int
        :return: 
                                     -     0: Success.
                                     -    -1: Invalid parameters (``NULL`` pointer).
                                     -    -2: Failed to open ``filename`` for write operations.
                                     - -6002: There is no MDL module in the database of the given name.
                                     - -6003: The export failed for unknown reasons.
                                     - -6004: The MDL module can not be exported since it is a builtin
                                              module.
                                     - -6005: The MDL module can not be exported since ``filename`` does
                                              not result in a valid MDL identifier.
                                     - -6010: Incorrect type for a referenced resource.
                                     - -6013: The export of a file-based resource failed.
                                     - -6014: The export of a memory-based resource failed.
                                     - -6016: The export of an archive-based resource failed.
        """
        return _pymdlsdk._IMdl_impexp_api_export_module(self, transaction, module_name, filename, context)

    def export_module_to_string(self, transaction, module_name, exported_module, context=None):
        r"""
        Exports an MDL module from the database to string.

        :type transaction: :py:class:`ITransaction`
        :param transaction:       The transaction to be used.
        :type module_name: string
        :param module_name:       The DB name of the MDL module to export.
        :type exported_module: :py:class:`IString`
        :param exported_module:   The exported module source code is written to this string.
        :type context: :py:class:`IMdl_execution_context`, optional
        :param context:           The execution context can be used to pass options to control the
                                     behavior of the MDL compiler. During module loading, compiler
                                     messages like errors or warnings are stored in the context.
                                     Can be ``NULL``.
        :rtype: int
        :return: 
                                     -     0: Success.
                                     -    -1: Invalid parameters (``NULL`` pointer).
                                     - -6002: There is no MDL module in the database of the given name.
                                     - -6003: The export failed for unknown reasons.
                                     - -6004: The MDL module can not be exported since it is a builtin
                                              module.
                                     - -6006: The option ``bundle_resources`` is not supported for
                                              string-based exports.
                                     - -6010: Incorrect type for a referenced resource.
                                     - -6011: The export of file-based resources is not supported for
                                              string-based exports.
                                     - -6012: The export of memory-based resources is not supported for
                                              string-based exports.
                                     - -6013: The export of a file-based resource failed.
                                     - -6014: The export of a memory-based resource failed.
                                     - -6015: The export of archive-based resources is not supported for
                                              string-based exports.
                                     - -6016: The export of an archive-based resource failed.
        """
        return _pymdlsdk._IMdl_impexp_api_export_module_to_string(self, transaction, module_name, exported_module, context)

    def export_canvas(self, filename, canvas, quality=100, force_default_gamma=False):
        r"""
        Exports a canvas to a file on disk.

        If the image plugin that is selected for the export based on the ``filename`` parameter is
        not capable of handling the pixel type of ``canvas``, the canvas is internally converted into
        one of the pixel types supported by that image plugin for export. If the image plugin
        supports multiple pixel types for export, the "best" of them (w.r.t. the pixel type of the
        canvas) is chosen.

        The "best" pixel type is determined by attempting to apply the following conversions in the
        given order to the pixel type of the canvas:
        - use an equivalent pixel type (``"Color"`` instead of ``"Float32<4>"`` and vice versa,
          similar for ``"Rgb_fp"`` / ``"Float32<3>"`` and ``"Rgba"`` / ``"Sint32"``),
        - add an alpha channel (if not already present),
        - increase bits per channel (smaller increase preferred),
        - add additional channels (if possible),
        - decrease bits per channel (smaller decrease preferred), and
        - drop one or more channels.

        :type filename: string
        :param filename:              The file name of the resource to export the canvas to. The
                                         ending of the file name determines the image format, e.g.,
                                         ``".jpg"``. Note that support for a given image format requires
                                         an image plugin capable of handling that format.
        :type canvas: mi::neuraylib::ICanvas
        :param canvas:                The canvas to export.
        :type quality: int, optional
        :param quality:               The compression quality is an integer in the range from 0 to
                                         100, where 0 is the lowest quality, and 100 is the highest
                                         quality.
        :type force_default_gamma: boolean, optional
        :param force_default_gamma:   If enabled, adjusts the gamma value of the exported pixel data
                                         according to the pixel type chosen for export (1.0 for HDR
                                         pixel types, 2.2 for LDR pixel types).
        :rtype: int
        :return: 
                                        -  0: Success.
                                        - -1: Invalid file name.
                                        - -2: Invalid canvas.
                                        - -3: Invalid quality.
                                        - -4: Unspecified failure.
        """
        return _pymdlsdk._IMdl_impexp_api_export_canvas(self, filename, canvas, quality, force_default_gamma)

    def export_lightprofile(self, filename, lightprofile):
        r"""
        Exports a light profile to disk.

        :type filename: string
        :param filename:          The file name of the resource to export the light profile to.
        :type lightprofile: :py:class:`ILightprofile`
        :param lightprofile:      The light profile to export.
        :rtype: int
        :return: 
                                     -  0: Success.
                                     - -1: Invalid file name.
                                     - -2: Invalid light profile.
                                     - -4: Unspecified failure.
        """
        return _pymdlsdk._IMdl_impexp_api_export_lightprofile(self, filename, lightprofile)

    def export_bsdf_data(self, filename, reflection, transmission):
        r"""
        Exports BSDF data to a file on disk.

        :type filename: string
        :param filename:          The file name of the resource to export the BSDF measurement to.
        :type reflection: mi::neuraylib::IBsdf_isotropic_data
        :param reflection:        The BSDF data for reflection to export. Can be ``NULL``.
        :type transmission: mi::neuraylib::IBsdf_isotropic_data
        :param transmission:      The BSDF data for transmission to export. Can be ``NULL``.
        :rtype: int
        :return: 
                                     -  0: Success.
                                     - -1: Invalid file name.
                                     - -4: Unspecified failure.
        """
        return _pymdlsdk._IMdl_impexp_api_export_bsdf_data(self, filename, reflection, transmission)
    SEARCH_OPTION_USE_FIRST = _pymdlsdk._IMdl_impexp_api_SEARCH_OPTION_USE_FIRST
    r""" Derive module name from the first search path that matches."""
    SEARCH_OPTION_USE_SHORTEST = _pymdlsdk._IMdl_impexp_api_SEARCH_OPTION_USE_SHORTEST
    r""" Derive module name from the shortest search path that matches."""
    SEARCH_OPTION_USE_LONGEST = _pymdlsdk._IMdl_impexp_api_SEARCH_OPTION_USE_LONGEST
    r""" Derive module name from the longest search path that matches."""
    SEARCH_OPTION_FORCE_32_BIT = _pymdlsdk._IMdl_impexp_api_SEARCH_OPTION_FORCE_32_BIT

    def get_mdl_module_name(self, *args):
        r"""
        Returns the MDL name for an MDL module identified by its filename.

        The return value can be passed to #mi::neuraylib::IMdl_impexp_api::load_module() or
        #mi::neuraylib::IMdl_factory::get_db_module_name().

        Notes: This method does not support MDLE modules. This is also not necessary, since in case
              of MDLEs the filename can be directly passed to
              #mi::neuraylib::IMdl_impexp_api::load_module() or
              #mi::neuraylib::IMdl_factory::get_db_module_name().

        :type filename: string
        :param filename:   The filename of an MDL module (excluding MDLE modules).
        :type option: int, optional
        :param option:     Controls the algorithm's behavior if several overlapping search paths
                              contain the given filename.
        :rtype: :py:class:`IString`
        :return: The MDL name of the given module, or ``NULL`` in case of failures.
        """
        return _pymdlsdk._IMdl_impexp_api_get_mdl_module_name(self, *args)

    def uvtile_marker_to_string(self, marker, u, v):
        r"""
        Replaces an uv-tile marker by coordinates of a given uv-tile.

        :type marker: string
        :param marker:   String containing a valid uv-tile marker.
        :type u: int
        :param u:        The u coordinate of the uv-tile.
        :type v: int
        :param v:        The v coordinate of the uv-tile.
        :rtype: :py:class:`IString`
        :return: String with the uv-tile marker replaced by the coordinates of the uv-tile,
                            ``NULL`` in case of errors.
        """
        return _pymdlsdk._IMdl_impexp_api_uvtile_marker_to_string(self, marker, u, v)

    def uvtile_string_to_marker(self, str, marker):
        r"""
        Replaces the pattern describing the coordinates of a uv-tile by the given marker.

        :type str: string
        :param str:      String containing the coordinate pattern, e.g., "_u1_v1".
        :type marker: string
        :param marker:   The marker to replace the pattern with, e.g., "<UVTILE1>".
        :rtype: :py:class:`IString`
        :return: The string with the coordinate pattern replaced by the marker (if found), or
                            ``NULL`` case of errors.
        """
        return _pymdlsdk._IMdl_impexp_api_uvtile_string_to_marker(self, str, marker)

    def serialize_function_name(self, definition_name, argument_types, return_type, mdle_callback, context):
        r"""
        Serializes the name of a function or material definition.

        See also: 'mi_mdl_serialized_names'

        :type definition_name: string
        :param definition_name:   The DB name of the function or material definition.
        :type argument_types: :py:class:`IType_list`
        :param argument_types:    The arguments of the corresponding function call or material
                                     instance. Required for template-like functions, ignored (can be
                                     ``NULL)`` in all other cases.
        :type return_type: :py:class:`IType`
        :param return_type:       The arguments of the corresponding function call or material
                                     instance. Required for the cast operator, ignored (can be
                                     ``NULL)`` in all other cases.
        :type mdle_callback: :py:class:`IMdle_serialization_callback`
        :param mdle_callback:     A callback to map the filename of MDLE modules. Ignored for
                                     non-MDLE modules. Can be ``NULL`` (which is treated like a callback
                                     implementing the identity transformation).
        :type context: :py:class:`IMdl_execution_context`
        :param context:           The execution context can be used to pass options and to retrieve
                                     error and/or warning messages. Can be ``NULL``.
        :rtype: :py:class:`ISerialized_function_name`
        :return: The serialized function name, or ``NULL`` in case of errors, or if
                                     encoded names are disabled.
        """
        return _pymdlsdk._IMdl_impexp_api_serialize_function_name(self, definition_name, argument_types, return_type, mdle_callback, context)

    def deserialize_function_name(self, *args):
        r"""
        *Overload 1:*
        Deserializes the serialized name of a function or material definition (first overload)

        See also: 'mi_mdl_serialized_names'

        :type transaction: :py:class:`ITransaction`
        :param transaction:       The transaction to be used.
        :type function_name: string
        :param function_name:     The serialized name of a function or material definition.
        :type mdle_callback: :py:class:`IMdle_deserialization_callback`
        :param mdle_callback:     A callback to map the filename of MDLE modules. Ignored for
                                     non-MDLE modules. Can be ``NULL`` (which is treated like a callback
                                     implementing the identity transformation).
        :type context: :py:class:`IMdl_execution_context`
        :param context:           The execution context can be used to pass options and to retrieve
                                     error and/or warning messages. Can be ``NULL``.
        :rtype: :py:class:`IDeserialized_function_name`
        :return: The deserialized function name, or ``NULL`` in case of errors, or
                                     if encoded names are disabled.

        |

        *Overload 2:*
        Deserializes the serialized name of a function or material definition (second overload).

        If the corresponding module has not been loaded, it will be loaded as a side effect. The
        method also performs an overload resolution on the deserialized function or material
        definition (as in
        #mi::neuraylib::IModule::get_function_overloads(const char*,const IArray*)const).

        See also: 'mi_mdl_serialized_names'

        :type transaction: :py:class:`ITransaction`
        :param transaction:       The transaction to be used.
        :type module_name: string
        :param module_name:       The serialized name of a module.
        :type function_name_without_module_name: string
        :param function_name_without_module_name:    The serialized name of a function or material
                                                        definition without the module name (starts with
                                                        ``"::"``, as returned by
                    #mi::neuraylib::ISerialized_function_name::get_function_name_without_module_name()).
        :type mdle_callback: :py:class:`IMdle_deserialization_callback`
        :param mdle_callback:     A callback to map the filename of MDLE modules. Ignored for
                                     non-MDLE modules. Can be ``NULL`` (which is treated like a callback
                                     implementing the identity transformation).
        :type context: :py:class:`IMdl_execution_context`
        :param context:           The execution context can be used to pass options and to retrieve
                                     error and/or warning messages. Can be ``NULL``.
        :rtype: :py:class:`IDeserialized_function_name`
        :return: The deserialized function name, or ``NULL`` in case of errors, or
                                     if encoded names are disabled.
        """
        return _pymdlsdk._IMdl_impexp_api_deserialize_function_name(self, *args)

    def deserialize_module_name(self, module_name, mdle_callback, context):
        r"""
        Deserializes the serialized name of a module.

        If the corresponding module has not been loaded, it will be loaded as a side effect. The
        method also performs an overload resolution on the deserialized function or material
        definition (as in
        #mi::neuraylib::IModule::get_function_overloads(const char*,const IArray*)const).

        See also: 'mi_mdl_serialized_names'

        :type module_name: string
        :param module_name:       The serialized name of a module.
        :type mdle_callback: :py:class:`IMdle_deserialization_callback`
        :param mdle_callback:     A callback to map the filename of MDLE modules. Ignored for
                                     non-MDLE modules. Can be ``NULL`` (which is treated like a callback
                                     implementing the identity transformation).
        :type context: :py:class:`IMdl_execution_context`
        :param context:           The execution context can be used to pass options and to retrieve
                                     error and/or warning messages. Can be ``NULL``.
        :rtype: :py:class:`IDeserialized_module_name`
        :return: The deserialized module name, or ``NULL`` in case of errors, or
                                     if encoded names are disabled.
        """
        return _pymdlsdk._IMdl_impexp_api_deserialize_module_name(self, module_name, mdle_callback, context)

# Register _IMdl_impexp_api in _pymdlsdk:
_pymdlsdk._IMdl_impexp_api_swigregister(_IMdl_impexp_api)

class Interface_declare_ISerialized_function_name(object):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_ISerialized_function_name_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_ISerialized_function_name

# Register Interface_declare_ISerialized_function_name in _pymdlsdk:
_pymdlsdk.Interface_declare_ISerialized_function_name_swigregister(Interface_declare_ISerialized_function_name)

def Interface_declare_ISerialized_function_name_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_ISerialized_function_name_compare_iid(iid)

class _ISerialized_function_name(Interface_declare_ISerialized_function_name):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_function_name(self):
        r"""
        Returns the serialized function name.

        Useful for serialization schemes that support only a single string entity.

        Pass to the first overload of
        #mi::neuraylib::IMdl_impexp_api::deserialize_function_name() during deserialization.
        """
        return _pymdlsdk._ISerialized_function_name_get_function_name(self)

    def get_module_name(self):
        r"""
        Returns the serialized module name.

        Useful for serialization schemes that support two string entity entities.

        Pass to #mi::neuraylib::IMdl_impexp_api::deserialize_module_name() or the second overload
        of #mi::neuraylib::IMdl_impexp_api::deserialize_function_name() during deserialization.
        """
        return _pymdlsdk._ISerialized_function_name_get_module_name(self)

    def get_function_name_without_module_name(self):
        r"""
        Returns the serialized function name (without the module name).

        Useful for serialization schemes that support two string entity entities.

        Pass to the second overload
        of #mi::neuraylib::IMdl_impexp_api::deserialize_function_name() during deserialization.
        """
        return _pymdlsdk._ISerialized_function_name_get_function_name_without_module_name(self)

# Register _ISerialized_function_name in _pymdlsdk:
_pymdlsdk._ISerialized_function_name_swigregister(_ISerialized_function_name)

class Interface_declare_IDeserialized_function_name(object):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IDeserialized_function_name_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IDeserialized_function_name

# Register Interface_declare_IDeserialized_function_name in _pymdlsdk:
_pymdlsdk.Interface_declare_IDeserialized_function_name_swigregister(Interface_declare_IDeserialized_function_name)

def Interface_declare_IDeserialized_function_name_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IDeserialized_function_name_compare_iid(iid)

class _IDeserialized_function_name(Interface_declare_IDeserialized_function_name):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_db_name(self):
        r""" Returns the DB name of the function of material definition."""
        return _pymdlsdk._IDeserialized_function_name_get_db_name(self)

    def get_argument_types(self):
        r"""
        Returns the argument types of the serialized function call or material instance.

        The argument types are identical to the parameter types of the corresponding definition,
        unless it is one of the 'mi_neuray_mdl_template_like_function_definitions'. The remarks
        about the expression list for creating calls to the 'mi_neuray_mdl_cast_operator' apply
        correspondingly.
        """
        return _pymdlsdk._IDeserialized_function_name_get_argument_types(self)

# Register _IDeserialized_function_name in _pymdlsdk:
_pymdlsdk._IDeserialized_function_name_swigregister(_IDeserialized_function_name)

class Interface_declare_IDeserialized_module_name(object):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IDeserialized_module_name_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IDeserialized_module_name

# Register Interface_declare_IDeserialized_module_name in _pymdlsdk:
_pymdlsdk.Interface_declare_IDeserialized_module_name_swigregister(Interface_declare_IDeserialized_module_name)

def Interface_declare_IDeserialized_module_name_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IDeserialized_module_name_compare_iid(iid)

class _IDeserialized_module_name(Interface_declare_IDeserialized_module_name):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_db_name(self):
        r""" Returns the DB name of the module."""
        return _pymdlsdk._IDeserialized_module_name_get_db_name(self)

    def get_load_module_argument(self):
        r""" Returns a string suitable for #mi::neuraylib::IMdl_impexp_api::load_module()."""
        return _pymdlsdk._IDeserialized_module_name_get_load_module_argument(self)

# Register _IDeserialized_module_name in _pymdlsdk:
_pymdlsdk._IDeserialized_module_name_swigregister(_IDeserialized_module_name)

class Interface_declare_IMdle_serialization_callback(object):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IMdle_serialization_callback_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IMdle_serialization_callback

# Register Interface_declare_IMdle_serialization_callback in _pymdlsdk:
_pymdlsdk.Interface_declare_IMdle_serialization_callback_swigregister(Interface_declare_IMdle_serialization_callback)

def Interface_declare_IMdle_serialization_callback_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IMdle_serialization_callback_compare_iid(iid)

class _IMdle_serialization_callback(Interface_declare_IMdle_serialization_callback):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_serialized_filename(self, filename):
        r"""
        Returns a serialized filename for the given MDLE filename.

        The implemented mapping should be reversible, otherwise you will run into problems
        implementing the corresponding instance of #mi::neuraylib::IMdle_deserialization_callback.

        The callback might get involved several times with the same argument. You might want to
        cache results if the computation is expensive.

        :type filename: string
        :param filename:   The current filename of an MDLE module.
        :rtype: :py:class:`IString`
        :return: The "serialized filename" of that MDLE module. Technically, this can be
                              any string with ``".mdle"`` suffix, it does *not* need to refer to an
                              existing MDLE file on disk.
        """
        return _pymdlsdk._IMdle_serialization_callback_get_serialized_filename(self, filename)

# Register _IMdle_serialization_callback in _pymdlsdk:
_pymdlsdk._IMdle_serialization_callback_swigregister(_IMdle_serialization_callback)

class Interface_declare_IMdle_deserialization_callback(object):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IMdle_deserialization_callback_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IMdle_deserialization_callback

# Register Interface_declare_IMdle_deserialization_callback in _pymdlsdk:
_pymdlsdk.Interface_declare_IMdle_deserialization_callback_swigregister(Interface_declare_IMdle_deserialization_callback)

def Interface_declare_IMdle_deserialization_callback_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IMdle_deserialization_callback_compare_iid(iid)

class _IMdle_deserialization_callback(Interface_declare_IMdle_deserialization_callback):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_deserialized_filename(self, serialized_filename):
        r"""
        Returns a the filename of an MDLE module given its serialized filename.

        The callback might get involved several times with the same argument. You might want to
        cache results if the computation is expensive.

        :type serialized_filename: string
        :param serialized_filename:   The "serialized filename" of an MDLE module. This is the string
                                         that has been returned by
                                #mi::neuraylib::IMdle_serialization_callback::get_serialized_filename().
        :rtype: :py:class:`IString`
        :return: The actual filename of that MDLE module.
        """
        return _pymdlsdk._IMdle_deserialization_callback_get_deserialized_filename(self, serialized_filename)

# Register _IMdle_deserialization_callback in _pymdlsdk:
_pymdlsdk._IMdle_deserialization_callback_swigregister(_IMdle_deserialization_callback)

class Interface_declare_IModule(_IScene_element):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IModule_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IModule

# Register Interface_declare_IModule in _pymdlsdk:
_pymdlsdk.Interface_declare_IModule_swigregister(Interface_declare_IModule)

def Interface_declare_IModule_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IModule_compare_iid(iid)

class _IModule(Interface_declare_IModule):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_filename(self):
        r"""
        Returns the name of the MDL source file from which this module was created.

        :rtype: string
        :return: The full pathname of the source file from which this MDL module was created,
                            or ``NULL`` if no such file exists.
        """
        return _pymdlsdk._IModule_get_filename(self)

    def get_mdl_name(self):
        r"""
        Returns the MDL name of the module.

        Notes: The MDL name of the module is different from the name of the DB element.
              Use #mi::neuraylib::ITransaction::name_of() to obtain the name of the DB element.

        :rtype: string
        :return: The MDL name of the module.
        """
        return _pymdlsdk._IModule_get_mdl_name(self)

    def get_mdl_package_component_count(self):
        r""" Returns the number of package components in the MDL name."""
        return _pymdlsdk._IModule_get_mdl_package_component_count(self)

    def get_mdl_package_component_name(self, index):
        r"""
        Returns the name of a package component in the MDL name.

        :rtype: string
        :return: The ``index`` -th package component name, or ``NULL`` if ``index`` is out of
                            bounds.
        """
        return _pymdlsdk._IModule_get_mdl_package_component_name(self, index)

    def get_mdl_simple_name(self):
        r"""
        Returns the simple MDL name of the module.

        The simple name is the last component of the MDL name, i.e., without any packages and scope
        qualifiers.

        :rtype: string
        :return: The simple MDL name of the module.
        """
        return _pymdlsdk._IModule_get_mdl_simple_name(self)

    def get_mdl_version(self):
        r""" Returns the MDL version of this module."""
        return _pymdlsdk._IModule_get_mdl_version(self)

    def get_import_count(self):
        r""" Returns the number of modules imported by the module."""
        return _pymdlsdk._IModule_get_import_count(self)

    def get_import(self, index):
        r"""
        Returns the DB name of the imported module at ``index``.

        :type index: int
        :param index:    The index of the imported module.
        :rtype: string
        :return: The DB name of the imported module.
        """
        return _pymdlsdk._IModule_get_import(self, index)

    def get_types(self):
        r""" Returns the types exported by this module."""
        return _pymdlsdk._IModule_get_types(self)

    def get_constants(self):
        r""" Returns the constants exported by this module."""
        return _pymdlsdk._IModule_get_constants(self)

    def get_function_count(self):
        r""" Returns the number of function definitions exported by the module."""
        return _pymdlsdk._IModule_get_function_count(self)

    def get_function(self, index):
        r"""
        Returns the DB name of the function definition at ``index``.

        :type index: int
        :param index:    The index of the function definition.
        :rtype: string
        :return: The DB name of the function definition. The method may return ``NULL`` for
                            valid indices if the corresponding function definition has already been
                            removed from the DB.
        """
        return _pymdlsdk._IModule_get_function(self, index)

    def get_material_count(self):
        r""" Returns the number of material definitions exported by the module."""
        return _pymdlsdk._IModule_get_material_count(self)

    def get_material(self, index):
        r"""
        Returns the DB name of the material definition at ``index``.

        :type index: int
        :param index:    The index of the material definition.
        :rtype: string
        :return: The DB name of the material definition. The method may return ``NULL`` for
                            valid indices if the corresponding material definition has already been
                            removed from the DB.
        """
        return _pymdlsdk._IModule_get_material(self, index)

    def get_resources_count(self):
        r"""
        Returns the number of resources defined in the module.
        Resources defined in a module that is imported by this module are not included.
        """
        return _pymdlsdk._IModule_get_resources_count(self)

    def get_resource_type(self, index):
        r"""
        Returns the type of the resource at ``index``.

        :type index: int
        :param index:    The index of the resource.
        :rtype: :py:class:`IType_resource`
        :return: The type of the resource.
        """
        return _pymdlsdk._IModule_get_resource_type(self, index)

    def get_resource_mdl_file_path(self, index):
        r"""
        Returns the absolute MDL file path of the resource at ``index``.

        :type index: int
        :param index:    The index of the resource.
        :rtype: string
        :return: The absolute MDL file path of the resource.
        """
        return _pymdlsdk._IModule_get_resource_mdl_file_path(self, index)

    def get_resource_name(self, index):
        r"""
        Returns the database name of the resource at ``index``.

        :type index: int
        :param index:    The index of the resource.
        :rtype: string
        :return: The database name of the resource or ``NULL`` if
                            this resource could not be resolved.
        """
        return _pymdlsdk._IModule_get_resource_name(self, index)

    def get_annotation_definition_count(self):
        r""" Returns the number of annotations defined in the module."""
        return _pymdlsdk._IModule_get_annotation_definition_count(self)

    def get_annotation_definition(self, *args):
        r"""
        *Overload 1:*
        Returns the annotation definition at ``index``.

        :type index: int
        :param index:    The index of the annotation definition.
        :rtype: :py:class:`IAnnotation_definition`
        :return: The annotation definition or ``NULL`` if
                            ``index`` is out of range.

        |

        *Overload 2:*
        Returns the annotation definition of the given ``name``.

        :type name: string
        :param name:     The name of the annotation definition.
        :rtype: :py:class:`IAnnotation_definition`
        :return: The annotation definition or ``NULL`` if there is no such definition.
        """
        return _pymdlsdk._IModule_get_annotation_definition(self, *args)

    def get_annotations(self):
        r""" Returns the annotations of the module, or ``NULL`` if there are no such annotations."""
        return _pymdlsdk._IModule_get_annotations(self)

    def is_standard_module(self):
        r"""
        Indicates whether this module is a standard module.

        Examples for standard modules are ``"limits"``, ``"anno"``, ``"state"``, ``"math"``, ``"tex"``,
        ``"noise"``, and ``"df"``.
        """
        return _pymdlsdk._IModule_is_standard_module(self)

    def is_mdle_module(self):
        r""" Indicates whether this module results from an ``.mdle`` file."""
        return _pymdlsdk._IModule_is_mdle_module(self)

    def get_function_overloads(self, *args):
        r"""
        *Overload 1:*
        Returns overloads of a function or material definition.

        The method returns overloads of a function or material definition of this module, either
        all overloads or just the overloads matching a given set of arguments.

        :type name: string
        :param name:             The DB name of a function or material definition from this module
                                    *without* signature.
        :type arguments: :py:class:`IExpression_list`, optional
        :param arguments:        Optional arguments to select specific overload(s). If present, the
                                    method returns only the overloads of ``name`` whose signature
                                    matches the provided arguments, i.e., a call to
                                    #mi::neuraylib::IFunction_definition::create_function_call() or
                                    #mi::neuraylib::IMaterial_definition::create_material_instance()
                                    with these arguments would succeed.
        :rtype: :py:class:`IArray`
        :return: The DB names of overloads of the given function or material
                                    definition, or ``NULL`` if ``name`` is invalid.

        |

        *Overload 2:*
        Returns overloads of a function or material definition.

        The method returns the best-matching overloads of a function or material definition of this
        module, given a list of positional parameter types.

        Notes: This overload should only be used if no actual arguments are available. If arguments
              are available, consider using
              #get_function_overloads(const char*,const IExpression_list*)const instead.

        This method does not work for the function definitions with the following semantics:
              - #mi::neuraylib::IFunction_definition::DS_CAST,
              - #mi::neuraylib::IFunction_definition::DS_TERNARY,
              - #mi::neuraylib::IFunction_definition::DS_ARRAY_INDEX,
              - #mi::neuraylib::IFunction_definition::DS_INTRINSIC_DAG_ARRAY_CONSTRUCTOR,
              - #mi::neuraylib::IFunction_definition::DS_INTRINSIC_DAG_ARRAY_LENGTH. and
              - #mi::neuraylib::IFunction_definition::DS_INTRINSIC_DAG_FIELD_ACCESS.
              These are the 'mi_neuray_mdl_template_like_function_definitions' plus the field
              access function definitions.

        :type name: string
        :param name:             The DB name of a function or material definition from this module
                                    *without* signature.
        :type parameter_types: :py:class:`IArray`
        :param parameter_types:  A static or dynamic array with elements of type #mi::IString
                                    representing positional parameter type names as returned by
                                    #mi::neuraylib::IFunction_definition::get_mdl_parameter_type_name().
        :rtype: :py:class:`IArray`
        :return: The DB names of overloads of the given function or material
                                    definition, or ``NULL`` if ``name`` is invalid.
        """
        return _pymdlsdk._IModule_get_function_overloads(self, *args)

    def is_valid(self, context):
        r"""
        Returns true if all imports of the module are valid.

        :type context: :py:class:`IMdl_execution_context`
        :param context:     In case of failure, the execution context can be checked for error
                               messages. Can be ``NULL``.
        """
        return _pymdlsdk._IModule_is_valid(self, context)

    def reload(self, recursive, context):
        r"""
        Reload the module from disk.

        Notes: This function works for file-based modules, only.

        :type context: :py:class:`IMdl_execution_context`
        :param context:     In case of failure, the execution context can be checked for error
                               messages. Can be ``NULL``.
        :type recursive: boolean
        :param recursive:   If true, all imported file based modules are reloaded
                               prior to this one.
        :rtype: int
        :return: 
                          -     0: Success
                          -    -1: Reloading failed, check the context for details.
        """
        return _pymdlsdk._IModule_reload(self, recursive, context)

    def reload_from_string(self, module_source, recursive, context):
        r"""
        Reload the module from string.

        Notes: This function works for string/memory-based modules, only. Standard modules and
        the built-in If: MDL_SOURCE_RELEASE { module mdl::base }Else: modules  {``mdl::base`` and
        ``mdl::nvidia::distilling_support`` } cannot be reloaded.

        :type module_source: string
        :param module_source: The module source code.
        :type recursive: boolean
        :param recursive:     If true, all imported file based modules are reloaded
                                 prior to this one.
        :type context: :py:class:`IMdl_execution_context`
        :param context:       In case of failure, the execution context can be checked for error
                                 messages. Can be ``NULL``.
        :rtype: int
        :return: 
                          -     0: Success
                          -    -1: Reloading failed, check the context for details.
        """
        return _pymdlsdk._IModule_reload_from_string(self, module_source, recursive, context)

    def deprecated_get_function_overloads(self, name, param_sig):
        return _pymdlsdk._IModule_deprecated_get_function_overloads(self, name, param_sig)

# Register _IModule in _pymdlsdk:
_pymdlsdk._IModule_swigregister(_IModule)

class Interface_declare_INeuray(object):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_INeuray_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_INeuray

# Register Interface_declare_INeuray in _pymdlsdk:
_pymdlsdk.Interface_declare_INeuray_swigregister(Interface_declare_INeuray)

def Interface_declare_INeuray_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_INeuray_compare_iid(iid)

class _INeuray(Interface_declare_INeuray):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def get_interface_version(self):
        r"""
        Returns the interface version of the MDL SDK library.

        This number changes whenever the abstract interfaces of the MDL SDK APIchanges.
        """
        return _pymdlsdk._INeuray_get_interface_version(self)

    def get_version(self):
        r"""
        Returns the version of the MDL SDK library.

        This string contains the product version, build number, build date, and platform of the
        current library.
        """
        return _pymdlsdk._INeuray_get_version(self)

    def start(self, blocking=True):
        r"""
        Starts the operation of the MDL SDK library.

        All configuration which is marked to be done before the start of the library must be done
        before calling this function. When calling this function the MDL SDKwill start
        threads and start network operations etc. The MDL SDK librarymay not be ready for
        operation after the call returned if blocking mode is not used.

        If: IRAY_API {
        Notes: Starting the MDL SDK librarymultiple times, i.e., calling #shutdown() then calling
              #start() again, is not yet supported. This is true even if the first call to
              #start() fails.
        }

        :type blocking: boolean, optional
        :param blocking:If: MDL_SDK_API { Unused. The startup is always done in blocking mode.
                           }Else: Indicates whether the startup should be done in blocking mode. If {
                           ``true`` the method will not return before all initialization was done. If
                           ``false`` the method will return immediately and the startup is done in a
                           separate thread. The status of the startup sequence can be checked via
                           #get_status(). }
        :rtype: int
        :return: 
                               -  0: Success
                               - -1: Unspecified failure.
                               - -2: Authentication failure (challenge-response).
                               - -4: Provided license expired.
                               - -5: No professional GPU as required by the license in use was found.
                               - -6: Authentication failure (FLEXlm).
                               - -7: No NVIDIA VCA as required by the license in use was found.
        """
        return _pymdlsdk._INeuray_start(self, blocking)
    PRE_STARTING = _pymdlsdk._INeuray_PRE_STARTING
    r""" The library or the cluster has not yet been started."""
    STARTING = _pymdlsdk._INeuray_STARTING
    r""" The library or the cluster is starting."""
    STARTED = _pymdlsdk._INeuray_STARTED
    r""" The library or the cluster is ready for operation."""
    SHUTTINGDOWN = _pymdlsdk._INeuray_SHUTTINGDOWN
    r""" The library or the cluster is shutting down."""
    SHUTDOWN = _pymdlsdk._INeuray_SHUTDOWN
    r""" The library or the cluster has been shut down."""
    FAILURE = _pymdlsdk._INeuray_FAILURE
    r""" There was a failure during operation."""
    FORCE_32_BIT = _pymdlsdk._INeuray_FORCE_32_BIT

    def shutdown(self, blocking=True):
        r"""
        Shuts down the library.

        For proper shutdown this may only be called after all transactions have been committed and
        all rendering is finished.

        You also need to release all interface pointers related to functionality obtained after
        startup before calling this method. In case you use the #mi::base::Handle class (or another
        handle class), you need to make sure that all such handles have been reset or destroyed.

        If: IRAY_API {
        Notes: Starting the MDL SDK librarymultiple times, i.e., calling #shutdown() then calling
              #start() again, is not yet supported. This is true even if the first call to
              #start() fails.
        }

        :type blocking: boolean, optional
        :param blocking:If: MDL_SDK_API { Unused. The shutdown is always done in blocking mode.
                           }Else: Indicates whether the shutdown should be done in blocking mode. If {
                           ``true`` the method will not return before shutdown has completed.
                           If ``false`` the method will return immediately and the shutdown is done
                           in a separate thread. The status of the shutdown sequence can be checked
                           via #get_status(). }
        :rtype: int
        :return: 0, in case of success, -1 in case of failure
        """
        return _pymdlsdk._INeuray_shutdown(self, blocking)

    def _get_status(self):
        r"""
        Returns the status of the library.

        :rtype: int
        :return: The status
        """
        return _pymdlsdk._INeuray__get_status(self)

    def _get_api_component(self, uuid):
        r"""
        Returns an API component from the MDL SDK API.

        See also: 'mi_neuray_api_components' for a list of built-in API components.

        See also: #register_api_component(), #unregister_api_component()

        :type uuid: :py:class:`Uuid`
        :param uuid:        The UUID under which the API components was registered. For built-in
                               API components this is the interface ID of the corresponding interface.
        :rtype: mi::base::IInterface
        :return: A pointer to the API component or ``NULL`` if the API component is not
                               supported or currently not available.
        """
        return _pymdlsdk._INeuray__get_api_component(self, uuid)

    def register_api_component(self, uuid, api_component):
        r"""
        Registers an API component with the MDL SDK API

        API components are a way for plugins to provide access to their functionality. The
        registration makes the API component available for subsequent calls of #get_api_component().

        :type uuid: :py:class:`Uuid`
        :param uuid:            The ID of the API component to register, e.g., the interface ID of
                                   the corresponding interface.
        :type api_component: mi::base::IInterface
        :param api_component:   The API component to register.
        :rtype: int
        :return: 
                                   -  0: Success.
                                   - -1: Invalid parameters (``NULL`` pointer).
                                   - -2: There is already an API component registered under the
                                         ID ``uuid``.
        """
        return _pymdlsdk._INeuray_register_api_component(self, uuid, api_component)

    def unregister_api_component(self, uuid):
        r"""
        Unregisters an API component with the MDL SDK API

        The API component will no longer be accessible via #get_api_component().

        :type uuid: :py:class:`Uuid`
        :param uuid:        The ID of the API component to unregister.
        :rtype: int
        :return: 
                               -  0: Success.
                               - -1: There is no API component registered under the ID ``uuid``.
        """
        return _pymdlsdk._INeuray_unregister_api_component(self, uuid)

# Register _INeuray in _pymdlsdk:
_pymdlsdk._INeuray_swigregister(_INeuray)

class Interface_declare_IScope(object):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IScope_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IScope

# Register Interface_declare_IScope in _pymdlsdk:
_pymdlsdk.Interface_declare_IScope_swigregister(Interface_declare_IScope)

def Interface_declare_IScope_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IScope_compare_iid(iid)

class _IScope(Interface_declare_IScope):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def create_transaction(self):
        r"""
        Creates a new transaction associated with this scope.

        If: DICE_API { DiCE users should treat ``ITransaction`` as an opaque type. Instead, you should
        use #mi::neuraylib::IDice_transaction which is better suited for the needs of DiCE. To
        create such a DiCE transaction call the templated variant
        #mi::neuraylib::IScope::create_transaction<mi::neuraylib::IDice_transaction>(). }

        If: MDL_SDK_API { Notes: The MDL SDK currently supports only one transaction at a time. }

        :rtype: :py:class:`ITransaction`
        :return: A transaction associated with this scope.
        """
        return _pymdlsdk._IScope_create_transaction(self)

    def get_id(self):
        r"""
        Returns the ID of the scope.

        Can be used to retrieve the scope from the database later.

        :rtype: string
        :return: The ID of the scope.
        """
        return _pymdlsdk._IScope_get_id(self)

    def get_privacy_level(self):
        r"""
        Returns the privacy level of the scope.

        The global scope has privacy level 0, all other scopes have higher privacy levels. On each
        path from the global scope to any other scope in the scope tree the privacy levels are
        strictly increasing.

        :rtype: mi::Uint8
        :return: The privacy level of the scope.
        """
        return _pymdlsdk._IScope_get_privacy_level(self)

    def get_name(self):
        r"""
        Returns the name of the scope.

        :rtype: string
        :return: The name of the scope, or ``NULL`` if the scope has no name.
        """
        return _pymdlsdk._IScope_get_name(self)

    def get_parent(self):
        r"""
        Returns the parent scope.

        :rtype: :py:class:`IScope`
        :return: The parent scope or ``NULL`` if the scope is the global scope.
        """
        return _pymdlsdk._IScope_get_parent(self)

# Register _IScope in _pymdlsdk:
_pymdlsdk._IScope_swigregister(_IScope)

TEXTURE_NO_COMPRESSION = _pymdlsdk.TEXTURE_NO_COMPRESSION
r""" no compression"""
TEXTURE_MEDIUM_COMPRESSION = _pymdlsdk.TEXTURE_MEDIUM_COMPRESSION
r""" medium compression ratio"""
TEXTURE_HIGH_COMPRESSION = _pymdlsdk.TEXTURE_HIGH_COMPRESSION
r""" high compression ratio"""
TEXTURE_COMPRESSION_FORCE_32_BIT = _pymdlsdk.TEXTURE_COMPRESSION_FORCE_32_BIT
FILTER_BOX = _pymdlsdk.FILTER_BOX
r""" box filter"""
FILTER_TRIANGLE = _pymdlsdk.FILTER_TRIANGLE
r""" triangle filter"""
FILTER_GAUSS = _pymdlsdk.FILTER_GAUSS
r""" Gaussian filter"""
FILTER_CMITCHELL = _pymdlsdk.FILTER_CMITCHELL
r""" clipped Mitchell filter"""
FILTER_CLANCZOS = _pymdlsdk.FILTER_CLANCZOS
r""" clipped Lanczos filter"""
FILTER_FAST = _pymdlsdk.FILTER_FAST
r""" a fast filter, could be GPU anti-aliasing, or any"""
FILTER_FORCE_32_BIT = _pymdlsdk.FILTER_FORCE_32_BIT
class Interface_declare_ITexture(_IScene_element):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_ITexture_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_ITexture

# Register Interface_declare_ITexture in _pymdlsdk:
_pymdlsdk.Interface_declare_ITexture_swigregister(Interface_declare_ITexture)

def Interface_declare_ITexture_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_ITexture_compare_iid(iid)

class _ITexture(Interface_declare_ITexture):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def set_image(self, name):
        r"""
        Sets the referenced image.

        :rtype: int
        :return: 
                      -  0: Success.
                      - -1: Invalid parameters (``NULL`` pointer).
                      - -2: There is no element with that name.
                      - -3: The element can not be referenced because it is in a more private scope
                            than the texture.
                      - -4: The element is not an image.
        """
        return _pymdlsdk._ITexture_set_image(self, name)

    def get_image(self):
        r"""
        Returns the referenced image.

        :rtype: string
        :return: The referenced image, or ``NULL`` if no image is referenced.
        """
        return _pymdlsdk._ITexture_get_image(self)

    def set_gamma(self, gamma):
        r"""
        Sets the gamma value of this texture.

        The gamma value of the texture is an override for the gamma value of the underlying
        image. The special value 0.0 means that the override is not set.

        This override value is also used when MDL source code is to be generated:
        - a value of 1.0 is converted to ``"::tex::gamma_linear"``,
        - a value of 2.2 is converted to ``"::tex::gamma_srgb"``, and
        - all other values are converted to ``"::tex::gamma_default"``.
        Therefore, if you want to avoid ``"::tex::gamma_default"`` in generated MDL source code, it
        makes sense to replicate the gamma value of the underlying image here (instead of not using
        the override).

        See also: #get_gamma(), #get_effective_gamma()
        """
        return _pymdlsdk._ITexture_set_gamma(self, gamma)

    def get_gamma(self):
        r"""
        Returns the gamma value of this texture.

        See also: #set_gamma(), #get_effective_gamma()
        """
        return _pymdlsdk._ITexture_get_gamma(self)

    def get_effective_gamma(self, uvtile_id=0):
        r"""
        Returns the effective gamma value.

        :type uvtile_id: int, optional
        :param uvtile_id:   The uv-tile id of the texture the gamma value is requested for when no
                               override is set.

        Returns the gamma value of this texture, unless no override is set. In this case the
        gamma value of the underlying image at the given uvtile index is returned. If no such image
        exists, 0.0 is returned.

        See also: #set_gamma(), #get_gamma()
        """
        return _pymdlsdk._ITexture_get_effective_gamma(self, uvtile_id)

    def set_compression(self, compression):
        r"""
        Sets the texture compression method.

        Notes: This setting does not affect the referenced image itself, it only affects image data
              that has been processed by the render modes. For example, in order to save GPU memory
              processed image data can be compressed before being uploaded to the GPU.

        See also: #mi::neuraylib::Texture_compression
        """
        return _pymdlsdk._ITexture_set_compression(self, compression)

    def get_compression(self):
        r"""
        Returns the texture compression method.

        Notes: This setting does not affect the referenced image itself, it only affects image data
              that has been processed by the render modes. For example, in order to save GPU memory
              processed image data can be compressed before being uploaded to the GPU.

        See also: #mi::neuraylib::Texture_compression
        """
        return _pymdlsdk._ITexture_get_compression(self)

    def set_volume(self, name):
        r"""
        Sets the referenced volume.

        :rtype: int
        :return: 
                      -  0: Success.
                      - -1: Invalid parameters (``NULL`` pointer).
                      - -2: There is no element with that name.
                      - -3: The element can not be referenced because it is in a more private scope
                            than the texture.
                      - -4: The element is not a volume.
        """
        return _pymdlsdk._ITexture_set_volume(self, name)

    def get_volume(self):
        r"""
        Returns the referenced volume data.

        :rtype: string
        :return: The referenced volume, or ``NULL`` if no volume is referenced.
        """
        return _pymdlsdk._ITexture_get_volume(self)

# Register _ITexture in _pymdlsdk:
_pymdlsdk._ITexture_swigregister(_ITexture)

class Interface_declare_IBsdf_measurement(_IScene_element):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_IBsdf_measurement_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_IBsdf_measurement

# Register Interface_declare_IBsdf_measurement in _pymdlsdk:
_pymdlsdk.Interface_declare_IBsdf_measurement_swigregister(Interface_declare_IBsdf_measurement)

def Interface_declare_IBsdf_measurement_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_IBsdf_measurement_compare_iid(iid)

class _IBsdf_measurement(Interface_declare_IBsdf_measurement):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def reset_file(self, filename):
        r"""
        Sets the BSDF measurement to a file identified by ``filename``.

        :rtype: int
        :return: 
                              -  0: Success.
                              - -1: Invalid parameters (``NULL`` pointer).
                              - -2: Failure to resolve the given filename, e.g., the file does not
                                    exist.
                              - -3: Invalid file format or invalid filename extension (only ``.mbsdf`` is
                                    supported).
        """
        return _pymdlsdk._IBsdf_measurement_reset_file(self, filename)

    def reset_reader(self, reader):
        r"""
        Sets the BSDF measurement to the data provided by a reader.

        :type reader: mi::neuraylib::IReader
        :param reader:      The reader that provides the data for the BSDF measurement in ``.mbsdf``
                               format.
        :rtype: int
        :return: 
                               -  0: Success.
                               - -1: Invalid parameters (``NULL`` pointer).
                               - -3: Invalid file format.
        """
        return _pymdlsdk._IBsdf_measurement_reset_reader(self, reader)

    def get_filename(self):
        r"""
        Returns the resolved file name of the file containing the BSDF measurement.

        The method returns ``NULL`` if there is no file associated with the BSDF measurement, e.g.,
        after default construction, calls to #set_reflection() or #set_transmission(), or failures
        to resolves the file name passed to #reset_file().

        See also: #get_original_filename()
        """
        return _pymdlsdk._IBsdf_measurement_get_filename(self)

    def get_original_filename(self):
        r"""
        Returns the unresolved file name as passed to #reset_file().

        The method returns ``NULL`` after default construction or calls to #set_reflection() or
        #set_transmission().

        See also: #get_filename()
        """
        return _pymdlsdk._IBsdf_measurement_get_original_filename(self)

    def set_reflection(self, bsdf_data):
        r"""
        Sets the BSDF data for the reflection.

        :type bsdf_data: mi::neuraylib::IBsdf_isotropic_data
        :param bsdf_data:   The BSDF data to be used by this BSDF measurement. The value ``NULL``
                               can be used to remove the BSDF data for reflection.
        :rtype: int
        :return: 
                               -  0: Success.
                               - -2: The resolution or type of ``bsdf_data`` is invalid.
        """
        return _pymdlsdk._IBsdf_measurement_set_reflection(self, bsdf_data)

    def get_reflection(self):
        r"""
        Returns the BSDF data for the reflection.

        Note that it is not possible to manipulate the BSDF data.

        :rtype: mi::base::IInterface
        :return: The BSDF data for reflection, or ``NULL`` if there is none.
        """
        return _pymdlsdk._IBsdf_measurement_get_reflection(self)

    def set_transmission(self, bsdf_data):
        r"""
        Sets the BSDF data for transmission.

        :type bsdf_data: mi::neuraylib::IBsdf_isotropic_data
        :param bsdf_data:   The BSDF data to be used by this BSDF measurement. The value ``NULL``
                               can be used to remove the BSDF data for transmission.
        :rtype: int
        :return: 
                               -  0: Success.
                               - -2: The resolution or type of ``bsdf_data`` is invalid.
        """
        return _pymdlsdk._IBsdf_measurement_set_transmission(self, bsdf_data)

    def get_transmission(self):
        r"""
        Returns the BSDF data for transmission.

        Note that it is not possible to manipulate the BSDF data.

        :rtype: mi::base::IInterface
        :return: The BSDF data for transmission, or ``NULL`` if there is none.
        """
        return _pymdlsdk._IBsdf_measurement_get_transmission(self)

# Register _IBsdf_measurement in _pymdlsdk:
_pymdlsdk._IBsdf_measurement_swigregister(_IBsdf_measurement)

LIGHTPROFILE_CLOCKWISE = _pymdlsdk.LIGHTPROFILE_CLOCKWISE
r""" Clockwise order, contrary to the IES standard for these (incorrect) type B files."""
LIGHTPROFILE_COUNTER_CLOCKWISE = _pymdlsdk.LIGHTPROFILE_COUNTER_CLOCKWISE
r""" Counter-clockwise, standard-conforming order (default)."""
LIGHTPROFILE_ROTATE_TYPE_B = _pymdlsdk.LIGHTPROFILE_ROTATE_TYPE_B
r""" For 3dsmax"""
LIGHTPROFILE_ROTATE_TYPE_C_90_270 = _pymdlsdk.LIGHTPROFILE_ROTATE_TYPE_C_90_270
r""" For 3dsmax"""
LIGHTPROFILE_FLAGS_FORCE_32_BIT = _pymdlsdk.LIGHTPROFILE_FLAGS_FORCE_32_BIT
LIGHTPROFILE_HERMITE_BASE_1 = _pymdlsdk.LIGHTPROFILE_HERMITE_BASE_1
r""" Degree 1 = linear interpolation"""
LIGHTPROFILE_HERMITE_BASE_3 = _pymdlsdk.LIGHTPROFILE_HERMITE_BASE_3
r""" Degree 3 = cubic interpolation"""
LIGHTPROFILE_DEGREE_FORCE_32_BIT = _pymdlsdk.LIGHTPROFILE_DEGREE_FORCE_32_BIT
class Interface_declare_ILightprofile(_IScene_element):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_ILightprofile_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_ILightprofile

# Register Interface_declare_ILightprofile in _pymdlsdk:
_pymdlsdk.Interface_declare_ILightprofile_swigregister(Interface_declare_ILightprofile)

def Interface_declare_ILightprofile_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_ILightprofile_compare_iid(iid)

class _ILightprofile(Interface_declare_ILightprofile):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def reset_file(self, *args):
        r"""
        Sets the light profile to a file identified by ``filename``.

        :type filename: string
        :param filename:           The new file containing the light profile data.
        :type resolution_phi: int, optional
        :param resolution_phi:     The desired resolution of the equidistant grid in phi-direction.


                                      The special value 0 leaves the choice of a suitable resolution to
                                      the implementation. Currently, the implementation behaves as
                                      follows: If the angles in phi-direction are already equidistant,
                                      the resolution in the file itself (after unfolding of symmetries)
                                      is kept unchanged. If the angles in phi-direction are not
                                      equidistant, a suitable resolution that maintains the angles given
                                      in the file is chosen. If that fails, a fixed resolution is
                                      chosen.
        :type resolution_theta: int, optional
        :param resolution_theta:   The desired resolution of the equidistant grid in theta-direction.


                                      The special value 0 leaves the choice of a suitable resolution to
                                      the implementation. Currently, the implementation behaves as
                                      follows: If the angles in theta-direction are already equidistant,
                                      the resolution in the file itself (after unfolding of symmetries)
                                      is kept unchanged. If the angles in theta-direction are not
                                      equidistant, a suitable resolution that maintains the angles given
                                      in the file is chosen. If that fails, a fixed resolution is
                                      chosen.
        :type degree: int, optional
        :param degree:             The interpolation method to use.
        :type flags: int, optional
        :param flags:              Flags to be used when interpreting the file data,
                                      see #mi::neuraylib::Lightprofile_flags for details.
        :rtype: int
        :return: 
                                      -  0: Success.
                                      - -1: Invalid parameters (``NULL`` pointer).
                                      - -2: Failure to resolve the given filename, e.g., the file does
                                            not exist.
                                      - -3: ``degree`` or ``flags`` is invalid (exactly one of
                                            #mi::neuraylib::LIGHTPROFILE_CLOCKWISE or
                                            #mi::neuraylib::LIGHTPROFILE_COUNTER_CLOCKWISE must be set).
                                      - -4: File format error.
                                      - -5: ``resolution_phi`` or ``resolution_theta`` is invalid (must
                                            not be 1).
        """
        return _pymdlsdk._ILightprofile_reset_file(self, *args)

    def reset_reader(self, *args):
        r"""
        Sets the light profile to the data provided by a reader.

        :type reader: mi::neuraylib::IReader
        :param reader:             The reader that provides the data for the BSDF measurement in
                                      ``.ies`` format.
        :type resolution_phi: int, optional
        :param resolution_phi:     The desired resolution of the equidistant grid in phi-direction.


                                      The special value 0 leaves the choice of a suitable resolution to
                                      the implementation. Currently, the implementation behaves as
                                      follows: If the angles in phi-direction are already equidistant,
                                      the resolution in the file itself (after unfolding of symmetries)
                                      is kept unchanged. If the angles in phi-direction are not
                                      equidistant, a suitable resolution that maintains the angles given
                                      in the file is chosen. If that fails, a fixed resolution is
                                      chosen.
        :type resolution_theta: int, optional
        :param resolution_theta:   The desired resolution of the equidistant grid in theta-direction.


                                      The special value 0 leaves the choice of a suitable resolution to
                                      the implementation. Currently, the implementation behaves as
                                      follows: If the angles in theta-direction are already equidistant,
                                      the resolution in the file itself (after unfolding of symmetries)
                                      is kept unchanged. If the angles in theta-direction are not
                                      equidistant, a suitable resolution that maintains the angles given
                                      in the file is chosen. If that fails, a fixed resolution is
                                      chosen.
        :type degree: int, optional
        :param degree:             The interpolation method to use.
        :type flags: int, optional
        :param flags:              Flags to be used when interpreting the data,
                                      see #mi::neuraylib::Lightprofile_flags for details.
        :rtype: int
        :return: 
                                      -  0: Success.
                                      - -1: Invalid parameters (``NULL`` pointer).
                                      - -3: ``degree`` or ``flags`` is invalid (exactly one of
                                            #mi::neuraylib::LIGHTPROFILE_CLOCKWISE or
                                            #mi::neuraylib::LIGHTPROFILE_COUNTER_CLOCKWISE must be set).
                                      - -4: File format error.
                                      - -5: ``resolution_phi`` or ``resolution_theta`` is invalid (must
                                            not be 1).
        """
        return _pymdlsdk._ILightprofile_reset_reader(self, *args)

    def get_filename(self):
        r"""
        Returns the resolved file name of the file containing the light profile.

        The method returns ``NULL`` if there is no file associated with the light profile, e.g.,
        after default construction or failures to resolve the file name passed to #reset_file().

        See also: #get_original_filename()
        """
        return _pymdlsdk._ILightprofile_get_filename(self)

    def get_original_filename(self):
        r"""
        Returns the unresolved file name as passed to #reset_file().

        The method returns ``NULL`` after default construction.

        See also: #get_filename()
        """
        return _pymdlsdk._ILightprofile_get_original_filename(self)

    def get_resolution_phi(self):
        r""" Returns the resolution of the grid in phi-direction, or 0 after default construction."""
        return _pymdlsdk._ILightprofile_get_resolution_phi(self)

    def get_resolution_theta(self):
        r""" Returns the resolution of the grid in theta-direction, or 0 after default construction."""
        return _pymdlsdk._ILightprofile_get_resolution_theta(self)

    def get_degree(self):
        r"""
        Returns the interpolation degree that was used to interpolate the grid data, or
        #mi::neuraylib::LIGHTPROFILE_HERMITE_BASE_1 after default construction.
        """
        return _pymdlsdk._ILightprofile_get_degree(self)

    def get_flags(self):
        r"""
        Returns flags that were used to interpret the light profile data in the file, or
        #mi::neuraylib::LIGHTPROFILE_COUNTER_CLOCKWISE after default construction.

        See also: #mi::neuraylib::Lightprofile_flags.
        """
        return _pymdlsdk._ILightprofile_get_flags(self)

    def get_phi(self, index):
        r"""
        Returns the ``index`` -th phi value.

        Note that the grid is an equidistant grid, i.e., the distance between subsequent phi values
        is always the same. If ``index`` is out of bounds or after default construction, 0 is
        returned.
        """
        return _pymdlsdk._ILightprofile_get_phi(self, index)

    def get_theta(self, index):
        r"""
        Returns the ``index`` -th theta value.

        Note that the grid is an equidistant grid, i.e., the distance between subsequent theta
        values is always the same. If ``index`` is out of bounds or after default construction, 0 is
        returned.
        """
        return _pymdlsdk._ILightprofile_get_theta(self, index)

    def get_data(self, *args):
        r"""
        *Overload 1:*
        Returns the normalized data of the entire grid.

        :rtype: float
        :return: A pointer to the normalized data for all vertices of the grid. The data values are
                      stored as array in column-major order (where all elements of a column have the
                      same phi value). Returns ``NULL`` after default construction.

        See also: #get_candela_multiplier()

        |

        *Overload 2:*
        Returns the normalized data for a grid vertex.

        :type index_phi: int
        :param index_phi:     Index in phi-direction of the vertex.
        :type index_theta: int
        :param index_theta:   Index in theta-direction of the vertex.
        :rtype: float
        :return: The normalized data for the grid point, or 0 in case of errors or after
                                 default construction.

        See also: #get_candela_multiplier(), #sample()
        """
        return _pymdlsdk._ILightprofile_get_data(self, *args)

    def get_candela_multiplier(self):
        r"""
        Returns the normalization factor.

        All data is normalized such that the maximum is 1.0. The values returned by methods like
        #get_data() need to be multiplied by this normalization factor to retrieve the true value.
        Returns 0 after default construction.
        """
        return _pymdlsdk._ILightprofile_get_candela_multiplier(self)

    def sample(self, phi, theta, candela):
        r"""
        Samples the light profile.

        The method computes a bi-linear interpolation of the light profile at (phi,theta) according
        to the resolution.

        :type phi: float
        :param phi:       First dimension of sample point.
        :type theta: float
        :param theta:     Second dimension of sample point.
        :type candela: boolean
        :param candela:   If ``false``, normalized values are returned, otherwise true values.
                             See #get_candela_multiplier().
        :rtype: float
        :return: The computed sample value, or 0 in case of errors or after default
                             construction.

        See also: #get_data()
        """
        return _pymdlsdk._ILightprofile_sample(self, phi, theta, candela)

# Register _ILightprofile in _pymdlsdk:
_pymdlsdk._ILightprofile_swigregister(_ILightprofile)

class Interface_declare_ITransaction(object):
    r"""
    Mixin class template for deriving new interface declarations.

    #mi::base::Interface_declare is a mixin class template that allows you to derive
    new interface classes easily. It provides you with implementations for the interface ID
    handling and support for the #mi::base::IInterface::get_interface method used
    by the corresponding mixin class template #mi::base::Interface_implement.

    It derives from the interface ``I``, which is by default #mi::base::IInterface.
    Each interface needs an interface ID (represented as a universally unique identifier
    (UUID)), which is defined here as 11 template parameter constants.

      Title: Include File:
        #include <mi/base/interface_declare.h>
    """

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    @staticmethod
    def compare_iid(iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.Interface_declare_ITransaction_compare_iid(iid)
    __swig_destroy__ = _pymdlsdk.delete_Interface_declare_ITransaction

# Register Interface_declare_ITransaction in _pymdlsdk:
_pymdlsdk.Interface_declare_ITransaction_swigregister(Interface_declare_ITransaction)

def Interface_declare_ITransaction_compare_iid(iid):
    r"""
    Compares the interface ID ``iid`` against the interface ID of this interface and of its
    ancestors.

    :rtype: boolean
    :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
        its ancestors, and ``false`` otherwise.
    """
    return _pymdlsdk.Interface_declare_ITransaction_compare_iid(iid)

class _ITransaction(Interface_declare_ITransaction):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr

    def commit(self):
        r"""
        Commits the transaction.

        Note that a commit() implicitly closes the transaction.
        A closed transaction does not allow any future operations and needs to be released.

        :rtype: int
        :return: 
                                -  0: Success.
                                - -1: Unspecified failure.
                                - -3: The transaction is not open.
        """
        return _pymdlsdk._ITransaction_commit(self)

    def abort(self):
        r"""
        If not: MDL_SDK_API {
        Aborts the transaction.

        Note that an abort() implicitly closes the transaction.
        A closed transaction does not allow any future operations and needs to be released.
        }Else:  { This operation is not supported.
        }
        """
        return _pymdlsdk._ITransaction_abort(self)

    def is_open(self):
        r"""
        Indicates whether the transaction is open.

        :rtype: boolean
        :return: ``true`` if the transaction is still open, or ``false`` if the transaction is
                      closed, i.e., it has been committed or aborted.
        """
        return _pymdlsdk._ITransaction_is_open(self)

    def create(self, type_name, argc=0, argv=0):
        r"""
        Creates an object of the type ``type_name``.

        Objects created with this method are typically If: IRAY_API { 'mi_neuray_types',
        'mi_neuray_scene_element' and 'mi_neuray_functors'. It is also possible to create
        instances of user-defined classes. }Else:  { and
        'mi_neuray_scene_element'. } Note that most types can also be created via the API
        component #mi::neuraylib::IFactory which does not require the context of a transaction.

        This method can not be used to create MDL definitions, material instances, or
        function calls. To create instances of
        #mi::neuraylib::IMaterial_instance and #mi::neuraylib::IFunction_call, use the
        methods #mi::neuraylib::IMaterial_definition::create_material_instance() or
        #mi::neuraylib::IFunction_definition::create_function_call(), respectively.

        The created object will be initialized in a manner dependent upon the passed type
        name. Each class has its own policy on initialization. So, one should not make any
        assumptions on the values of the various class members.

        :type type_name: string
        :param type_name:    The type name of the object to create. See 'mi_neuray_types' for
                                possible type names. In addition, 'mi_neuray_scene_element'
                            If: IRAY_API { and 'mi_neuray_functors' } can be created by
                            passing the name of the requested interfaces without namespace
                            qualifiers and the leading ``"I"``, e.g., ``"Image"`` for
                            #mi::neuraylib::IImage. If: IRAY_API { Names of user-defined classes are
                            also valid arguments. } Note that you can not create instances of
                            #mi::neuraylib::IAttribute_set or #mi::neuraylib::IScene_element, only
                            instances of the derived interfaces If: IRAY_API { (see also
                            #mi::neuraylib::IAttribute_container) } .
        :type argc: int, optional
        :param argc:         The number of elements in ``argv``. Passed to the constructor of factory
                                of the object to create.
        :type argv: mi::base::IInterface, optional
        :param argv:         The array of arguments passed to the constructor. Passed to the
                                constructor of factory of the object to create.
        :rtype: mi::base::IInterface
        :return: A pointer to the created object, or ``NULL`` if ``type_name`` is invalid
                                (``NULL`` pointer) or not a valid type name.
        """
        return _pymdlsdk._ITransaction_create(self, type_name, argc, argv)
    LOCAL_SCOPE = _pymdlsdk._ITransaction_LOCAL_SCOPE
    r"""
    Symbolic privacy level for the privacy level of the scope of this transaction.

    This symbolic constant can be passed to #store() and #copy() to indicate the privacy level
    of the scope of this transaction. It has the same affect as passing the result of
    #mi::neuraylib::IScope::get_privacy_level(), but is more convenient.
    """

    def store(self, *args):
        r"""
        Stores the element ``db_element`` in the database under the name ``name`` and with the privacy
        level ``privacy``.

        After a successful store operation the passed interface pointer must no longer be used,
        except for releasing it. This is due to the fact that after a #store() the database
        retains ownership of the stored data. You can obtain the stored version from the database
        using the #access() or #edit() methods.

        Notes: **Overwriting vs editing of existing DB elements**

              While it is possible to overwrite existing DB elements, for performance reasons it is
              often better to edit the already existing DB element instead. Editing a DB element
              allows the DB to keep track of the type of changes which might help render modes to
              update their data structures more efficiently. When overwriting an existing DB element
              such information is not available and pessimistic assumptions have to be made which
              may result in lower performance.

        :type db_element: mi::base::IInterface
        :param db_element: The #mi::base::IInterface to store.
        :type name: string
        :param name:       The name under which to store ``db_element``. If there exists already a DB
                              element with that name then it will be overwritten If: IRAY_API { (but see
                          also return code -9 below) } .
        :type privacy: mi::Uint8, optional
        :param privacy:    The privacy level under which to store ``db_element`` (in the range from 0
                              to the privacy level of the scope of this transaction). In addition, the
                              constant #LOCAL_SCOPE can be used as a shortcut to indicate the privacy
                              level of the scope of this transaction without supplying the actual value
                              itself.
        :rtype: int
        :return: 
                   -  0: Success.
                   - -1: Unspecified failure.
                   - -2: Invalid parameters (``NULL`` pointer).
                   - -3: The transaction is not open.
                   - -4: ``db_element`` is not a DB element.
                   - -5: Invalid privacy level.
                   - -6: ``db_element`` has already been stored previously.
                   - -7: The element is to be stored in a transaction different from the one that was
                         used to create it.
                   - -8: The element is a user-defined class that has not been If: IRAY_API {
                     registered (see #mi::neuraylib::IExtension_api::register_class()). }Else:  {              registered. }

               - -9: There is already an element of name ``name`` and overwriting elements of that
                     type is not supported. This applies to elements of type
                     #mi::neuraylib::IModule, #mi::neuraylib::IMaterial_definition, and
                     #mi::neuraylib::IFunction_definition.
                     It also applies to elements of type #mi::neuraylib::IFunction_call
                     and #mi::neuraylib::IMaterial_instance that are used as defaults
                     in an #mi::neuraylib::IMaterial_definition or
                     #mi::neuraylib::IFunction_definition.
        """
        return _pymdlsdk._ITransaction_store(self, *args)

    def _access(self, name):
        r"""
        Retrieves an element from the database.

        The database searches for the most recent version of the named DB element visible for the
        current transaction. That version will be returned.

        :type name: string
        :param name:   The name of the element to retrieve.
        :rtype: mi::base::IInterface
        :return: The requested element from the database, or ``NULL`` if ``name`` is invalid, no
                          DB element with that name exists, or the transaction is already closed.
        """
        return _pymdlsdk._ITransaction__access(self, name)

    def _edit(self, name):
        r"""
        Retrieves an element from the database and returns it ready for editing.

        The database searches for the most recent version of the named DB element visible for the
        current transaction. It will then make a copy of that version and return the copy. The
        edited DB element will be committed to the database automatically, when the obtained
        interface is released. It is neither necessary nor possible to store the edited element
        manually in the database using the #store() method.

        :type name: string
        :param name:   The name of the element to retrieve.
        :rtype: mi::base::IInterface
        :return: The requested element from the database, or ``NULL`` if ``name`` is invalid, no
                          DB element with that name exists, or the transaction is already closed.
        """
        return _pymdlsdk._ITransaction__edit(self, name)

    def copy(self, source, target, privacy=0):
        r"""
        Creates a copy of a database element.

        Note that DB elements of type #mi::neuraylib::IModule, #mi::neuraylib::IMaterial_definition,
        and #mi::neuraylib::IFunction_definition can not be copied.

        :type source: string
        :param source:    The name of the element to be copied.
        :type target: string
        :param target:    The desired name of the copy.
        :type privacy: mi::Uint8, optional
        :param privacy:   The desired privacy level of the copy (in the range from
                             0 to the privacy level of the scope of this transaction). In addition, the
                             constant #LOCAL_SCOPE can be used as a shortcut to indicate the privacy
                             level of the scope of this transaction without supplying the actual value
                             itself.
        :rtype: int
        :return: 
                             -  0: Success.
                             - -2: Invalid parameters (``NULL`` pointer).
                             - -3: The transaction is not open.
                             - -4: There is no DB element named ``source`` visible in this transaction.
                             - -5: Invalid privacy level.
                             - -6: DB elements of this type cannot be copied.
                             - -9: There is already an element of name ``name`` and overwriting elements
                                   of that type is not supported. This applies to elements of type
                                   #mi::neuraylib::IModule, #mi::neuraylib::IMaterial_definition, and
                                   #mi::neuraylib::IFunction_definition.
                                   It also applies to elements of type #mi::neuraylib::IFunction_call
                                   and #mi::neuraylib::IMaterial_instance that are used as defaults
                                   in an #mi::neuraylib::IMaterial_definition or
                                   #mi::neuraylib::IFunction_definition.
        """
        return _pymdlsdk._ITransaction_copy(self, source, target, privacy)

    def remove(self, name, only_localized=False):
        r"""
        Removes the element with the name ``name`` from the database.

        Note that the element continues to be stored in the database as long as it is referenced by
        other elements. If it is no longer referenced, and the last transaction were it was
        referenced has been committed, it will be lazily removed by the garbage collection of the
        DB. There is no guarantee when this will happen.

        This implies that a #remove() call might actually remove an element that was stored later
        under the same name. This can potentially lead to invalid tag accesses. Those cases can be
        avoided by using #mi::neuraylib::IDatabase::garbage_collection() after a transaction was
        committed and before starting the next one to force garbage collection of all possible
        elements.

        :type name: string
        :param name:           The name of the element in the database to remove.
        :type only_localized: boolean, optional
        :param only_localized: If: MDL_SDK_API { Unused. }Else: If  {``true``, the element is only removed
                              if it exists in the scope of the transaction; parent scopes are not
                              considered. }
        :rtype: int
        :return: 
                                  -  0: Success.
                                  - -1: There is no DB element named ``name`` visible in this
                                        transaction (``only_localize`` is ``false)`` or there is no
                                        DB element named ``name`` in the scope of this transaction
                                        (``only_localized`` is ``true)``.
                                  - -2: Invalid parameters (``NULL`` pointer).
                                  - -3: The transaction is not open.
        """
        return _pymdlsdk._ITransaction_remove(self, name, only_localized)

    def name_of(self, db_element):
        r"""
        Returns the name of a database element.

        :type db_element: mi::base::IInterface
        :param db_element:   The DB element.
        :rtype: string
        :return: The name of the DB element, or ``NULL`` if ``db_element`` is invalid
                                (``NULL`` pointer), the object is not in the database, or the
                                transaction is already closed.
        """
        return _pymdlsdk._ITransaction_name_of(self, db_element)

    def get_time_stamp(self, *args):
        r"""
        *Overload 1:*
        Returns the time stamp describing the current "time".

        Notes: The time stamp is not related to time in the classical meaning. It rather relates to
              the current transaction and the number of database changes since the start of the
              transaction.

        The time stamp is only meaningful for the current MDL SDKinstance. It
              should not be put into external storage and re-used for different or later
              MDL SDKinstances.

        The return value of this method is only valid until the next call of this method
              (or one of its overloads) on this instance.

        See also: has_changed_since_time_stamp(), #get_time_stamp(const char*)const

        |

        *Overload 2:*
        Returns the time stamp of the last change of a database element.

        Notes: The time stamp is not related to time in the classical meaning. It rather relates to
              the transaction and the number of database changes since the start of the transaction
              when the database element was changed last.

        The time stamp is only meaningful for the current MDL SDKinstance. It
              should not be put into external storage and re-used for different or later
              MDL SDKinstances.

        The return value of this method is only valid until the next call of this method
              (or one of its overloads) on this instance.

        See also: has_changed_since_time_stamp(), #get_time_stamp()
        """
        return _pymdlsdk._ITransaction_get_time_stamp(self, *args)

    def has_changed_since_time_stamp(self, element, time_stamp):
        r"""
        Checks whether an element has been stored or changed in the database since a given time
        stamp.

        Notes: ``time_stamp`` should not stem from another concurrent transaction. Such changes will
              never be visible in this transaction, but the method might still return ``true``
              depending on the start order of the two transactions.

        In case of multiple overlapping transactions the returned answer may not list
              all changes due to the isolation of the transactions. If accurate results are
              required, transactions changing elements should be committed before transactions
              querying the journal for such changes are started.

        See also: #get_time_stamp(), #get_time_stamp(const char*)const

        :type element: string
        :param element:     The name of the element.
        :type time_stamp: string
        :param time_stamp:  The time stamp obtained from #get_time_stamp() or
                               #get_time_stamp(const char*)const.
        :rtype: boolean
        :return: ``true`` if the element has been stored or changed since the time stamp
                               (or if ``element`` or ``time_stamp`` is invalid, or there is no element
                               with that name), ``false`` otherwise.
        """
        return _pymdlsdk._ITransaction_has_changed_since_time_stamp(self, element, time_stamp)

    def get_id(self):
        r"""
        Returns the ID of this transaction.

        The transaction ID is of most use when debugging an application as the value returned allows
        one to correlate log messages and admin HTTP server output with the API actions.

        :rtype: string
        :return: The ID of the transaction.
        """
        return _pymdlsdk._ITransaction_get_id(self)

    def get_scope(self):
        r""" Returns the scope of this transaction."""
        return _pymdlsdk._ITransaction_get_scope(self)

    def list_elements(self, root_element, name_pattern=None, type_names=None):
        r"""
        Returns scene elements of a subgraph originating at a given scene element.

        The method iterates over all elements of a subgraph originating at the given scene element
        and returns their names. Optionally, the results can be filtered by a regular expression
        for the element names and a list for type names.

        Note that the runtime of the method depends on the number of elements in the subgraph. It
        might be expensive to call this method for large subgraphs.

        The returned scene elements are in such an order that all elements referenced by a given
        element are listed before that element ("before" in the sense of "using smaller array
        indices").

        :type root_element: string
        :param root_element:   The root of the subgraph to traverse.
        :type name_pattern: string, optional
        :param name_pattern:   An extended regular expression that acts as filter on the names of
                                  returned scene elements (see ['OGBS7])'. The regular expression
                                  is matched to *any* *part* of the scene element name, not just to
                                  the *entire* scene element name. The value ``NULL`` is handled as
                                  ``".*"``.
        :type type_names: :py:class:`IArray`, optional
        :param type_names:     A list of type names that acts as filter on the names of returned
                                  scene elements. Only scene elements with a matching type name pass
                                  the filter. The value ``NULL`` lets all scene elements pass the filter
                                  irrespective of their type name.
        :rtype: :py:class:`IArray`
        :return: A list of name of scene elements in the subgraph matching the given
                                  regular expression and type name filter, or ``NULL`` in case of
                                  an invalid root element name or an invalid regular expression.
        """
        return _pymdlsdk._ITransaction_list_elements(self, root_element, name_pattern, type_names)

    def get_privacy_level(self, name):
        r"""
        Returns the privacy level of the element with the name ``name``.

        :type name: string
        :param name:          The name of the element.
        :rtype: int
        :return: 
                                 - >= 0: Success. The privacy level of the element (in the range 0-255).
                                 -   -2: Invalid parameters (``NULL`` pointer).
                                 -   -3: The transaction is not open.
                                 -   -4: There is no DB element named ``name`` visible in this
                                         transaction.
        """
        return _pymdlsdk._ITransaction_get_privacy_level(self, name)

# Register _ITransaction in _pymdlsdk:
_pymdlsdk._ITransaction_swigregister(_ITransaction)

class IAttribute_set(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IAttribute_set_swiginit(self, _pymdlsdk.new_IAttribute_set(*args))
    __swig_destroy__ = _pymdlsdk.delete_IAttribute_set

    def __deref__(self):
        return _pymdlsdk.IAttribute_set___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IAttribute_set___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IAttribute_set_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IAttribute_set___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IAttribute_set___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IAttribute_set_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IAttribute_set_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IAttribute_set__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def create_attribute(self, name, type):
        r"""
        Creates a new attribute ``name`` of the type ``type``.

        :type name: string
        :param name:         The name of the attribute. The name must not contain ``"["``, ``"]"``, or
                                ``"``."
        :type type: string
        :param type:         The type of the attribute. See 'mi_neuray_types' for a list of
                                supported attribute types.
        :rtype: :py:class:`IData`
        :return: A pointer to the created attribute, or ``NULL`` in case of failure.
                                Reasons for failure are:
                                - ``name`` or ``type`` is invalid,
                                - there is already an attribute with the name ``name``, or
                                - ``name`` is the name of a reserved attribute and ``type`` does not match
                                  the required type(s) of such an attribute.
        """
        return _pymdlsdk.IAttribute_set_create_attribute(self, name, type)

    def destroy_attribute(self, name):
        r"""
        Destroys the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute to destroy.
        :rtype: boolean
        :return: Returns ``true`` if the attribute has been successfully destroyed, and
                                ``false`` otherwise (there is no attribute with the name ``name)``.
        """
        return _pymdlsdk.IAttribute_set_destroy_attribute(self, name)

    def access_attribute(self, name):
        r"""
        Returns a const pointer to the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also access parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: :py:class:`IData`
        :return: A pointer to the attribute, or ``NULL`` if there is no attribute with
                                the name ``name``.
        """
        return _pymdlsdk.IAttribute_set_access_attribute(self, name)

    def edit_attribute(self, name):
        r"""
        Returns a mutable pointer to the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also access parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: :py:class:`IData`
        :return: A pointer to the attribute, or ``NULL`` if there is no attribute with
                                the name ``name``.
        """
        return _pymdlsdk.IAttribute_set_edit_attribute(self, name)

    def is_attribute(self, name):
        r"""
        Indicates existence of an attribute.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also checks for parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: boolean
        :return: ``true`` if the attribute set contains this attribute (and the attribute
                                contains the requested array element or struct member),
                                ``false`` otherwise
        """
        return _pymdlsdk.IAttribute_set_is_attribute(self, name)

    def get_attribute_type_name(self, name):
        r"""
        Returns the type of an attribute.

        See 'mi_neuray_types' for a list of supported attribute types.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also query parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: string
        :return: The type name of the attribute (or part thereof), or ``NULL`` if there
                                is no attribute with the name ``name``.

        Notes: The return value of this method is only valid until the next call of this method
              or any non-const methods on this instance.
        """
        return _pymdlsdk.IAttribute_set_get_attribute_type_name(self, name)

    def set_attribute_propagation(self, name, value):
        r"""
        Sets the propagation type of the attribute ``name``.

        :rtype: int
        :return: 
                                -  0: Success.
                                - -1: Invalid parameters (``NULL`` pointer or invalid enum value).
                                - -2: There is no attribute with name ``name``.
        """
        return _pymdlsdk.IAttribute_set_set_attribute_propagation(self, name, value)

    def get_attribute_propagation(self, name):
        r"""
        Returns the propagation type of the attribute ``name``.

        Notes: This method always returns #PROPAGATION_STANDARD in case of errors.
        """
        return _pymdlsdk.IAttribute_set_get_attribute_propagation(self, name)

    def enumerate_attributes(self, index):
        r"""
        Returns the name of the attribute indicated by ``index``.

        :type index: int
        :param index:        The index of the attribute.
        :rtype: string
        :return: The name of the attribute indicated by ``index``, or ``NULL`` if ``index``
                                is out of bounds.
        """
        return _pymdlsdk.IAttribute_set_enumerate_attributes(self, index)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IAttribute_set_compare_iid(self, iid)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IAttribute_set__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IAttribute_set__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IAttribute_set_get_iid(self)

# Register IAttribute_set in _pymdlsdk:
_pymdlsdk.IAttribute_set_swigregister(IAttribute_set)

def IAttribute_set_IID():
    return _pymdlsdk.IAttribute_set_IID()

def IAttribute_set__get_interface(iface):
    return _pymdlsdk.IAttribute_set__get_interface(iface)

class IBsdf_measurement(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IBsdf_measurement_swiginit(self, _pymdlsdk.new_IBsdf_measurement(*args))
    __swig_destroy__ = _pymdlsdk.delete_IBsdf_measurement

    def __deref__(self):
        return _pymdlsdk.IBsdf_measurement___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IBsdf_measurement___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IBsdf_measurement_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IBsdf_measurement___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IBsdf_measurement___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IBsdf_measurement_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IBsdf_measurement_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IBsdf_measurement__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def reset_file(self, filename):
        r"""
        Sets the BSDF measurement to a file identified by ``filename``.

        :rtype: int
        :return: 
                              -  0: Success.
                              - -1: Invalid parameters (``NULL`` pointer).
                              - -2: Failure to resolve the given filename, e.g., the file does not
                                    exist.
                              - -3: Invalid file format or invalid filename extension (only ``.mbsdf`` is
                                    supported).
        """
        return _pymdlsdk.IBsdf_measurement_reset_file(self, filename)

    def reset_reader(self, reader):
        r"""
        Sets the BSDF measurement to the data provided by a reader.

        :type reader: mi::neuraylib::IReader
        :param reader:      The reader that provides the data for the BSDF measurement in ``.mbsdf``
                               format.
        :rtype: int
        :return: 
                               -  0: Success.
                               - -1: Invalid parameters (``NULL`` pointer).
                               - -3: Invalid file format.
        """
        return _pymdlsdk.IBsdf_measurement_reset_reader(self, reader)

    def get_filename(self):
        r"""
        Returns the resolved file name of the file containing the BSDF measurement.

        The method returns ``NULL`` if there is no file associated with the BSDF measurement, e.g.,
        after default construction, calls to #set_reflection() or #set_transmission(), or failures
        to resolves the file name passed to #reset_file().

        See also: #get_original_filename()
        """
        return _pymdlsdk.IBsdf_measurement_get_filename(self)

    def get_original_filename(self):
        r"""
        Returns the unresolved file name as passed to #reset_file().

        The method returns ``NULL`` after default construction or calls to #set_reflection() or
        #set_transmission().

        See also: #get_filename()
        """
        return _pymdlsdk.IBsdf_measurement_get_original_filename(self)

    def set_reflection(self, bsdf_data):
        r"""
        Sets the BSDF data for the reflection.

        :type bsdf_data: mi::neuraylib::IBsdf_isotropic_data
        :param bsdf_data:   The BSDF data to be used by this BSDF measurement. The value ``NULL``
                               can be used to remove the BSDF data for reflection.
        :rtype: int
        :return: 
                               -  0: Success.
                               - -2: The resolution or type of ``bsdf_data`` is invalid.
        """
        return _pymdlsdk.IBsdf_measurement_set_reflection(self, bsdf_data)

    def get_reflection(self):
        r"""
        Returns the BSDF data for the reflection.

        Note that it is not possible to manipulate the BSDF data.

        :rtype: mi::base::IInterface
        :return: The BSDF data for reflection, or ``NULL`` if there is none.
        """
        return _pymdlsdk.IBsdf_measurement_get_reflection(self)

    def set_transmission(self, bsdf_data):
        r"""
        Sets the BSDF data for transmission.

        :type bsdf_data: mi::neuraylib::IBsdf_isotropic_data
        :param bsdf_data:   The BSDF data to be used by this BSDF measurement. The value ``NULL``
                               can be used to remove the BSDF data for transmission.
        :rtype: int
        :return: 
                               -  0: Success.
                               - -2: The resolution or type of ``bsdf_data`` is invalid.
        """
        return _pymdlsdk.IBsdf_measurement_set_transmission(self, bsdf_data)

    def get_transmission(self):
        r"""
        Returns the BSDF data for transmission.

        Note that it is not possible to manipulate the BSDF data.

        :rtype: mi::base::IInterface
        :return: The BSDF data for transmission, or ``NULL`` if there is none.
        """
        return _pymdlsdk.IBsdf_measurement_get_transmission(self)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IBsdf_measurement_compare_iid(self, iid)

    def get_element_type(self):
        r""" Indicates the actual scene element represented by interfaces derived from this interface."""
        return _pymdlsdk.IBsdf_measurement_get_element_type(self)

    def create_attribute(self, name, type):
        r"""
        Creates a new attribute ``name`` of the type ``type``.

        :type name: string
        :param name:         The name of the attribute. The name must not contain ``"["``, ``"]"``, or
                                ``"``."
        :type type: string
        :param type:         The type of the attribute. See 'mi_neuray_types' for a list of
                                supported attribute types.
        :rtype: :py:class:`IData`
        :return: A pointer to the created attribute, or ``NULL`` in case of failure.
                                Reasons for failure are:
                                - ``name`` or ``type`` is invalid,
                                - there is already an attribute with the name ``name``, or
                                - ``name`` is the name of a reserved attribute and ``type`` does not match
                                  the required type(s) of such an attribute.
        """
        return _pymdlsdk.IBsdf_measurement_create_attribute(self, name, type)

    def destroy_attribute(self, name):
        r"""
        Destroys the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute to destroy.
        :rtype: boolean
        :return: Returns ``true`` if the attribute has been successfully destroyed, and
                                ``false`` otherwise (there is no attribute with the name ``name)``.
        """
        return _pymdlsdk.IBsdf_measurement_destroy_attribute(self, name)

    def access_attribute(self, name):
        r"""
        Returns a const pointer to the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also access parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: :py:class:`IData`
        :return: A pointer to the attribute, or ``NULL`` if there is no attribute with
                                the name ``name``.
        """
        return _pymdlsdk.IBsdf_measurement_access_attribute(self, name)

    def edit_attribute(self, name):
        r"""
        Returns a mutable pointer to the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also access parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: :py:class:`IData`
        :return: A pointer to the attribute, or ``NULL`` if there is no attribute with
                                the name ``name``.
        """
        return _pymdlsdk.IBsdf_measurement_edit_attribute(self, name)

    def is_attribute(self, name):
        r"""
        Indicates existence of an attribute.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also checks for parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: boolean
        :return: ``true`` if the attribute set contains this attribute (and the attribute
                                contains the requested array element or struct member),
                                ``false`` otherwise
        """
        return _pymdlsdk.IBsdf_measurement_is_attribute(self, name)

    def get_attribute_type_name(self, name):
        r"""
        Returns the type of an attribute.

        See 'mi_neuray_types' for a list of supported attribute types.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also query parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: string
        :return: The type name of the attribute (or part thereof), or ``NULL`` if there
                                is no attribute with the name ``name``.

        Notes: The return value of this method is only valid until the next call of this method
              or any non-const methods on this instance.
        """
        return _pymdlsdk.IBsdf_measurement_get_attribute_type_name(self, name)

    def set_attribute_propagation(self, name, value):
        r"""
        Sets the propagation type of the attribute ``name``.

        :rtype: int
        :return: 
                                -  0: Success.
                                - -1: Invalid parameters (``NULL`` pointer or invalid enum value).
                                - -2: There is no attribute with name ``name``.
        """
        return _pymdlsdk.IBsdf_measurement_set_attribute_propagation(self, name, value)

    def get_attribute_propagation(self, name):
        r"""
        Returns the propagation type of the attribute ``name``.

        Notes: This method always returns #PROPAGATION_STANDARD in case of errors.
        """
        return _pymdlsdk.IBsdf_measurement_get_attribute_propagation(self, name)

    def enumerate_attributes(self, index):
        r"""
        Returns the name of the attribute indicated by ``index``.

        :type index: int
        :param index:        The index of the attribute.
        :rtype: string
        :return: The name of the attribute indicated by ``index``, or ``NULL`` if ``index``
                                is out of bounds.
        """
        return _pymdlsdk.IBsdf_measurement_enumerate_attributes(self, index)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IBsdf_measurement__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IBsdf_measurement__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IBsdf_measurement_get_iid(self)

# Register IBsdf_measurement in _pymdlsdk:
_pymdlsdk.IBsdf_measurement_swigregister(IBsdf_measurement)

def IBsdf_measurement_IID():
    return _pymdlsdk.IBsdf_measurement_IID()

def IBsdf_measurement__get_interface(iface):
    return _pymdlsdk.IBsdf_measurement__get_interface(iface)

class IDatabase(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IDatabase_swiginit(self, _pymdlsdk.new_IDatabase(*args))
    __swig_destroy__ = _pymdlsdk.delete_IDatabase

    def __deref__(self):
        return _pymdlsdk.IDatabase___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IDatabase___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IDatabase_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IDatabase___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IDatabase___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IDatabase_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IDatabase_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IDatabase__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_global_scope(self):
        r"""
        Returns the global scope which is the root of a tree of scopes

        :rtype: :py:class:`IScope`
        :return: The global scope which is guaranteed to exist after startup of the
                     system.
        """
        return _pymdlsdk.IDatabase_get_global_scope(self)

    def create_scope(self, parent, privacy_level=0, temp=False):
        r"""
        If not: MDL_SDK_API {
        Creates a new optionally temporary scope at the given privacy level with the
        given parent scope ID.

        Notes: A scope continues to exist if the pointer returned by this method is released. Use
              #remove_scope() to remove a scope.

        :type parent: :py:class:`IScope`
        :param parent:         The parent scope for this scope. If the value is ``NULL`` the created
                                  scope will be a child of the global scope.
        :type privacy_level: mi::Uint8, optional
        :param privacy_level:  The privacy level of the scope. This must be higher than the
                                  privacy level of the parent scope. The privacy level of the global
                                  scope is 0 (and the global scope is the only scope with privacy level
                                  0). The default value of 0 indicates the privacy level of the parent
                                  scope plus 1.
        :type temp: boolean, optional
        :param temp:           A bool indicating if the scope is temporary. If the scope is
                                  temporary, then when the host that created the scope is removed
                                  from the cluster the scope and all data contained in the scope
                                  will be removed. If the scope is not temporary, the default,
                                  then when the creating host is removed from the cluster the
                                  scope and all contained data will remain in the database.
        :rtype: :py:class:`IScope`
        :return: The created scope or ``NULL`` if something went wrong.
        }Else:  { This operation is not supported.
        }
        """
        return _pymdlsdk.IDatabase_create_scope(self, parent, privacy_level, temp)

    def get_scope(self, id):
        r"""
        Looks up and returns a scope with a given ID.

        :type id: string
        :param id:             The ID of the scope as returned by #mi::neuraylib::IScope::get_id().
        :rtype: :py:class:`IScope`
        :return: The found scope or ``NULL`` if no such scope exists.
        """
        return _pymdlsdk.IDatabase_get_scope(self, id)

    def remove_scope(self, id):
        r"""
        If not: MDL_SDK_API {
        Removes a scope with the specified ID.

        Note that scopes are reference counted. The actual removal will not happen before all
        elements referencing the scope have been released, e.g., child scopes, transactions,
        database elements, including handles to the scope itself.

        It is not possible to remove the global scope.

        :type id: string
        :param id:             The ID of the scope as returned by #mi::neuraylib::IScope::get_id().
        :rtype: int
        :return: 0, in case of success, -1 in case of failure.
        }Else:  { This operation is not supported.
        }
        """
        return _pymdlsdk.IDatabase_remove_scope(self, id)

    def lock(self, lock_id):
        r"""
        If not: MDL_SDK_API {
        Acquires a DB lock.

        The method blocks until the requested lock has been obtained. Recursively locking the
        same lock from within the same thread on the same host is supported.

        If the host holding a lock leaves the cluster, the lock is automatically released.

        :type lock_id: int
        :param lock_id:   The lock to acquire.

        Notes: The locking mechanism is kind of a co-operative locking mechanism: The lock does not
              prevent other threads from accessing or editing the DB. It only prevents other threads
              from obtaining the same lock.

        DB locks are not restricted to threads on a single host, they apply to all threads on
              all hosts in the cluster.

        DB locks are an expensive operation and should only be used when absolutely necessary.
        }Else:  { This operation is not supported.
        }
        """
        return _pymdlsdk.IDatabase_lock(self, lock_id)

    def unlock(self, lock_id):
        r"""
        If not: MDL_SDK_API {
        Releases a previously obtained DB lock.

        If the lock has been locked several times from within the same thread on the same host,
        it simply decrements the lock count. If the lock count reaches zero, the lock is released.

        :type lock_id: int
        :param lock_id:   The lock to release.
        :rtype: int
        :return: 0, in case of success, -1 in case of failure, i.e, the lock is not held
                             by this thread on this host
        }Else:  { This operation is not supported.
        }
        """
        return _pymdlsdk.IDatabase_unlock(self, lock_id)

    def create_or_get_named_scope(self, name, parent=None, privacy_level=0):
        r"""
        If not: MDL_SDK_API {
        Creates or retrieves a new named scope at the given privacy level with the given parent
        scope ID.

        :type name: string
        :param name:           A name which can be used to lookup the scope.
                                  If a scope with the same name exists already then it will be returned
                                  if the parent and privacy level are identical. Otherwise
                                  creating the scope will fail.
        :type parent: :py:class:`IScope`, optional
        :param parent:         The parent scope for this scope. If the value is ``NULL`` the created
                                  scope will be a child of the global scope.
        :type privacy_level: mi::Uint8, optional
        :param privacy_level:  The privacy level of the scope. This must be higher than the
                                  privacy level of the parent scope. The privacy level of the global
                                  scope is 0 (and the global scope is the only scope with privacy level
                                  0). The default value of 0 indicates the privacy level of the parent
                                  scope plus 1.
        :rtype: :py:class:`IScope`
        :return: The created scope or ``NULL`` if something went wrong.
        }Else:  { This operation is not supported.
        }
        """
        return _pymdlsdk.IDatabase_create_or_get_named_scope(self, name, parent, privacy_level)

    def get_named_scope(self, name):
        r"""
        If not: MDL_SDK_API {
        Looks up and returns a scope with a given name.

        :type name: string
        :param name:           The name of the scope
        :rtype: :py:class:`IScope`
        :return: The found scope or ``NULL`` if no such scope exists.
        }Else:  { This operation is not supported.
        }
        """
        return _pymdlsdk.IDatabase_get_named_scope(self, name)

    def garbage_collection(self, *args):
        r"""
        Triggers a synchronous garbage collection run.

        The method sweeps through the entire database and removes all database elements which have
        been marked for removal and are no longer referenced. Note that it is not possible to remove
        database elements if there are open transactions in which such an element is still
        referenced.

        To mark an element for removal use If not: DICE_API { #mi::neuraylib::ITransaction::remove().
        }Else: #mi::neuraylib::IDice_transaction::remove() or {
        #mi::neuraylib::IDice_transaction::store_for_reference_counting(). }

        :type priority: int, optional
        :param priority:   The intended priority of the synchronous garbage collection run.
                          If: MDL_SDK_API { The MDL SDK does not support different priorities, and
                          the synchronous garbage collection always runs at highest priority.
                          }
        """
        return _pymdlsdk.IDatabase_garbage_collection(self, *args)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IDatabase_compare_iid(self, iid)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IDatabase__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IDatabase__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IDatabase_get_iid(self)

# Register IDatabase in _pymdlsdk:
_pymdlsdk.IDatabase_swigregister(IDatabase)

def IDatabase_IID():
    return _pymdlsdk.IDatabase_IID()

def IDatabase__get_interface(iface):
    return _pymdlsdk.IDatabase__get_interface(iface)

class IDeserialized_function_name(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IDeserialized_function_name_swiginit(self, _pymdlsdk.new_IDeserialized_function_name(*args))
    __swig_destroy__ = _pymdlsdk.delete_IDeserialized_function_name

    def __deref__(self):
        return _pymdlsdk.IDeserialized_function_name___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IDeserialized_function_name___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IDeserialized_function_name_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IDeserialized_function_name___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IDeserialized_function_name___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IDeserialized_function_name_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IDeserialized_function_name_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IDeserialized_function_name__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_db_name(self):
        r""" Returns the DB name of the function of material definition."""
        return _pymdlsdk.IDeserialized_function_name_get_db_name(self)

    def get_argument_types(self):
        r"""
        Returns the argument types of the serialized function call or material instance.

        The argument types are identical to the parameter types of the corresponding definition,
        unless it is one of the 'mi_neuray_mdl_template_like_function_definitions'. The remarks
        about the expression list for creating calls to the 'mi_neuray_mdl_cast_operator' apply
        correspondingly.
        """
        return _pymdlsdk.IDeserialized_function_name_get_argument_types(self)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IDeserialized_function_name_compare_iid(self, iid)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IDeserialized_function_name__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IDeserialized_function_name__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IDeserialized_function_name_get_iid(self)

# Register IDeserialized_function_name in _pymdlsdk:
_pymdlsdk.IDeserialized_function_name_swigregister(IDeserialized_function_name)

def IDeserialized_function_name_IID():
    return _pymdlsdk.IDeserialized_function_name_IID()

def IDeserialized_function_name__get_interface(iface):
    return _pymdlsdk.IDeserialized_function_name__get_interface(iface)

class IDeserialized_module_name(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IDeserialized_module_name_swiginit(self, _pymdlsdk.new_IDeserialized_module_name(*args))
    __swig_destroy__ = _pymdlsdk.delete_IDeserialized_module_name

    def __deref__(self):
        return _pymdlsdk.IDeserialized_module_name___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IDeserialized_module_name___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IDeserialized_module_name_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IDeserialized_module_name___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IDeserialized_module_name___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IDeserialized_module_name_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IDeserialized_module_name_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IDeserialized_module_name__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_db_name(self):
        r""" Returns the DB name of the module."""
        return _pymdlsdk.IDeserialized_module_name_get_db_name(self)

    def get_load_module_argument(self):
        r""" Returns a string suitable for #mi::neuraylib::IMdl_impexp_api::load_module()."""
        return _pymdlsdk.IDeserialized_module_name_get_load_module_argument(self)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IDeserialized_module_name_compare_iid(self, iid)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IDeserialized_module_name__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IDeserialized_module_name__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IDeserialized_module_name_get_iid(self)

# Register IDeserialized_module_name in _pymdlsdk:
_pymdlsdk.IDeserialized_module_name_swigregister(IDeserialized_module_name)

def IDeserialized_module_name_IID():
    return _pymdlsdk.IDeserialized_module_name_IID()

def IDeserialized_module_name__get_interface(iface):
    return _pymdlsdk.IDeserialized_module_name__get_interface(iface)

class IMdl_configuration(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IMdl_configuration_swiginit(self, _pymdlsdk.new_IMdl_configuration(*args))
    __swig_destroy__ = _pymdlsdk.delete_IMdl_configuration

    def __deref__(self):
        return _pymdlsdk.IMdl_configuration___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IMdl_configuration___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IMdl_configuration_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IMdl_configuration___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IMdl_configuration___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IMdl_configuration_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IMdl_configuration_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IMdl_configuration__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def set_logger(self, logger):
        r"""
        Sets the logger.

        If: IRAY_API { Sets the receiving logger, see also
        #mi::neuraylib::ILogging_configuration::set_receiving_logger().}Else:  { Installs a custom logger, and deinstalls the previously installed logger.
        By default, an internal logger is installed that prints all messages of severity
        #mi::base::details::MESSAGE_SEVERITY_INFO or higher to stderr.}

        :type logger: mi::base::ILogger
        :param logger:   The new logger that receives all log messages. Passing ``NULL`` is allowed
                            to reinstall the default logger.
        """
        return _pymdlsdk.IMdl_configuration_set_logger(self, logger)

    def get_logger(self):
        r"""
        Returns the used logger.

        :rtype: mi::base::ILogger
        :return: If: IRAY_API { Returns the forwarding logger. See
                  also #mi::neuraylib::ILogging_configuration::get_forwarding_logger(). }Else: The {
                  currently used logger ( either explicitly installed via #set_logger(), or
                  the default logger). Never returns ``NULL``. }
        """
        return _pymdlsdk.IMdl_configuration_get_logger(self)

    def add_mdl_path(self, path):
        r"""
        Adds a path to the list of paths to search for MDL modules.

        This search path is also used for resources referenced in MDL modules. By default, the list
        of MDL paths is empty.

        :type path: string
        :param path:                The path to be added.
        :rtype: int
        :return: 
                                       -  0: Success.
                                       - -1: Invalid parameters ( ``NULL`` pointer).
                                       - -2: Invalid path.
        """
        return _pymdlsdk.IMdl_configuration_add_mdl_path(self, path)

    def remove_mdl_path(self, path):
        r"""
        Removes a path from the list of paths to search for MDL modules.

        This search path is also used for resources referenced in MDL modules. By default, the list
        of MDL paths is empty.

        :type path: string
        :param path:                The path to be removed.
        :rtype: int
        :return: 
                                       -  0: Success.
                                       - -1: Invalid parameters ( ``NULL`` pointer).
                                       - -2: There is no such path in the path list.
        """
        return _pymdlsdk.IMdl_configuration_remove_mdl_path(self, path)

    def clear_mdl_paths(self):
        r"""
        Clears the list of paths to search for MDL modules.

        This search path is also used for resources referenced in MDL modules. By default, the list
        of MDL paths is empty.
        """
        return _pymdlsdk.IMdl_configuration_clear_mdl_paths(self)

    def get_mdl_paths_length(self):
        r"""
        Returns the number of paths to search for MDL modules.

        This search path is also used for resources referenced in MDL modules. By default, the list
        of MDL paths is empty.

        :rtype: int
        :return: The number of currently configured paths.
        """
        return _pymdlsdk.IMdl_configuration_get_mdl_paths_length(self)

    def get_mdl_path(self, index):
        r"""
        Returns the ``index`` -th path to search for MDL modules.

        This search path is also used for resources referenced in MDL modules. By default, the list
        of MDL paths is empty.

        :rtype: :py:class:`IString`
        :return: The ``index`` -th path, or ``NULL`` if ``index`` is out of bounds.
        """
        return _pymdlsdk.IMdl_configuration_get_mdl_path(self, index)

    def get_mdl_system_paths_length(self):
        r""" Returns the number of MDL system paths."""
        return _pymdlsdk.IMdl_configuration_get_mdl_system_paths_length(self)

    def get_mdl_system_path(self, index):
        r"""
        Returns the ``index`` -th path in the MDL system paths.

        The default MDL system path is
        - ``%%PROGRAMDATA%``\NVIDIA ``Corporation``\mdl (on Windows),
        - ``/opt/nvidia/mdl`` (on Linux), and
        - ``/Library/Application`` ``Support/NVIDIA`` ``Corporation/mdl`` (on Mac OS).

        The MDL system paths can be changed via the environment variable ``MDL_SYSTEM_PATH``. The
        environment variable can contain multiple paths which are separated by semicolons (on
        Windows) or colons (on Linux and Mac OS), respectively.

        :rtype: string
        :return: The ``index`` -th path, or ``NULL`` if ``index`` is out of bounds.
        """
        return _pymdlsdk.IMdl_configuration_get_mdl_system_path(self, index)

    def add_mdl_system_paths(self):
        r""" Adds the MDL system paths to the MDL search path."""
        return _pymdlsdk.IMdl_configuration_add_mdl_system_paths(self)

    def get_mdl_user_paths_length(self):
        r""" Returns the number of MDL user paths."""
        return _pymdlsdk.IMdl_configuration_get_mdl_user_paths_length(self)

    def get_mdl_user_path(self, index):
        r"""
        Returns the ``index`` -th path in the MDL user paths.

        The default MDL user path is
        - ``%%DOCUMENTS%``\mdl (on Windows),
        - ``$HOME/Documents/mdl`` (on Linux), and
        - ``$HOME/Documents/mdl`` (on Mac OS),
        where %DOCUMENTS% refers to the standard folder identified by ``FOLDERID_Documents`` from
        the Windows API (usually ``%%USERPROFILE%``\Documents).

        The MDL user paths can be changed via the environment variable ``MDL_USER_PATH``. The
        environment variable can contain multiple paths which are separated by semicolons (on
        Windows) or colons (on Linux and Mac OS), respectively.

        :rtype: string
        :return: The ``index`` -th path, or ``NULL`` if ``index`` is out of bounds.
        """
        return _pymdlsdk.IMdl_configuration_get_mdl_user_path(self, index)

    def add_mdl_user_paths(self):
        r""" Adds the MDL user paths to the MDL search path."""
        return _pymdlsdk.IMdl_configuration_add_mdl_user_paths(self)

    def add_resource_path(self, path):
        r"""
        Adds a path to the list of paths to search for resources, i.e., textures, light profiles,
        and BSDF measurements.

        Note that for MDL resources referenced in .``mdl`` files the MDL search paths are considered,
        not the resource search path. By default, the list of resource paths is empty.

        :type path: string
        :param path:                The path to be added.
        :rtype: int
        :return: 
                                       -  0: Success.
                                       - -1: Invalid parameters ( ``NULL`` pointer).
                                       - -2: Invalid path.
        """
        return _pymdlsdk.IMdl_configuration_add_resource_path(self, path)

    def remove_resource_path(self, path):
        r"""
        Removes a path from the list of paths to search for resources, i.e., textures, light
        profiles, and BSDF measurements.

        Note that for MDL resources referenced in .``mdl`` files the MDL search paths are considered,
        not the resource search path. By default, the list of resource paths is empty.

        :type path: string
        :param path:                The path to be removed.
        :rtype: int
        :return: 
                                       -  0: Success.
                                       - -1: Invalid parameters ( ``NULL`` pointer).
                                       - -2: There is no such path in the path list.
        """
        return _pymdlsdk.IMdl_configuration_remove_resource_path(self, path)

    def clear_resource_paths(self):
        r"""
        Clears the list of paths to search for resources, i.e., textures, light profiles,
        and BSDF measurements.

        Note that for MDL resources referenced in .``mdl`` files the MDL search paths are considered,
        not the resource search path. By default, the list of resource paths is empty.
        """
        return _pymdlsdk.IMdl_configuration_clear_resource_paths(self)

    def get_resource_paths_length(self):
        r"""
        Returns the number of paths to search for resources, i.e., textures, light profiles,
        and BSDF measurements.

        Note that for MDL resources referenced in .``mdl`` files the MDL search paths are considered,
        not the resource search path. By default, the list of resource paths is empty.

        :rtype: int
        :return: The number of currently configured paths.
        """
        return _pymdlsdk.IMdl_configuration_get_resource_paths_length(self)

    def get_resource_path(self, index):
        r"""
        Returns the ``index`` -th path to search for resources, i.e., textures, light profiles,
        and BSDF measurements.

        Note that for MDL resources referenced in .``mdl`` files the MDL search paths are considered,
        not the resource search path. By default, the list of resource paths is empty.

        :rtype: :py:class:`IString`
        :return: The ``index`` -th path, or ``NULL`` if ``index`` is out of bounds.
        """
        return _pymdlsdk.IMdl_configuration_get_resource_path(self, index)

    def set_implicit_cast_enabled(self, value):
        r"""
        Defines whether a cast operator is automatically inserted for compatible argument types.

        If set to ``true``, an appropriate cast operator is automatically inserted if arguments for
        instances of #mi::neuraylib::IFunction_call or #mi::neuraylib::IMaterial_instance have a
        different but compatible type. If set to ``false``, such an assignment fails and it is
        necessary to insert the cast operator explicitly. Default: ``true``.

        See also: #mi::neuraylib::IExpression_factory::create_cast().

        :type value: boolean
        :param value:    ``True`` to enable the feature, ``false`` otherwise.
        :rtype: int
        :return: 
                           -  0: Success.
                           - -1: The method cannot be called at this point of time.
        """
        return _pymdlsdk.IMdl_configuration_set_implicit_cast_enabled(self, value)

    def get_implicit_cast_enabled(self):
        r"""
        Indicates whether the SDK is supposed to automatically insert the cast operator for
        compatible types.

        See also: #set_implicit_cast_enabled()
        """
        return _pymdlsdk.IMdl_configuration_get_implicit_cast_enabled(self)

    def set_expose_names_of_let_expressions(self, value):
        r"""
        Defines whether an attempt is made to expose names of let expressions.

        If set to ``true``, the MDL compiler attempts to represent let expressions as temporaries,
        and makes the name of let expressions available as names of such temporaries. In order to
        do so, certain optimizations are disabled, in particular, constant folding. These names are
        only available on material and functions definitions, not on compiled materials, which are
        always highly optimized. Default: ``true``.

        Notes: Since some optimizations are essential for inner workings of the MDL compiler, there

        See also: #mi::neuraylib::IFunction_definition::get_temporary_name(),
             #mi::neuraylib::IMaterial_definition::get_temporary_name()
        """
        return _pymdlsdk.IMdl_configuration_set_expose_names_of_let_expressions(self, value)

    def get_expose_names_of_let_expressions(self):
        r"""
        Indicates whether an attempt is made to expose names of let expressions.

        See also: #set_expose_names_of_let_expressions()
        """
        return _pymdlsdk.IMdl_configuration_get_expose_names_of_let_expressions(self)

    def set_simple_glossy_bsdf_legacy_enabled(self, value):
        r"""
        Configures the behavior of ``df::simple_glossy_bsdf()`` in MDL modules
        of versions smaller than 1.3.

        Notes: If: IRAY_API { This setting can only be configured before The MDL SDKhas been
              started. }Else: This function has no effect in the MDL SDK and always returns -1. {
              }

        :type value: boolean
        :param value:    ``True`` to enable the feature, ``false`` otherwise.
        :rtype: int
        :return: 
                           -  0: Success.
                           - -1: The method cannot be called at this point of time.
        """
        return _pymdlsdk.IMdl_configuration_set_simple_glossy_bsdf_legacy_enabled(self, value)

    def get_simple_glossy_bsdf_legacy_enabled(self):
        r"""
        Returns ``true`` if the legacy behavior for bsdfs of type ``df::simple_glossy_bsdf()`` used
        in MDL modules with versions smaller that 1.3 is enabled, ``false`` otherwise.
        """
        return _pymdlsdk.IMdl_configuration_get_simple_glossy_bsdf_legacy_enabled(self)

    def get_entity_resolver(self):
        r"""
        Returns an instance of the built-in entity resolver.

        Notes: The returned instance contains a copy of the currently configured search paths,
              subsequent changes to the search paths are not reflected in this instance.
        """
        return _pymdlsdk.IMdl_configuration_get_entity_resolver(self)

    def set_entity_resolver(self, resolver):
        r"""
        Installs an external entity resolver.

        :type resolver: mi::neuraylib::IMdl_entity_resolver
        :param resolver:   The external entity resolver to be used instead of the built-in entity
                              resolver. Pass ``NULL`` to uninstall a previously installed external
                              entity resolver.

        Notes: MDL archive creation is not supported with an external entity resolver ( see
              #mi::neuraylib::IMdl_archive_api::create_archive()).
        """
        return _pymdlsdk.IMdl_configuration_set_entity_resolver(self, resolver)

    def set_materials_are_functions(self, value):
        r"""
        Defines whether materials are treated as functions.

        From an MDL language point of view ['MDLLS]', materials look quite similar to functions
        with the ``material`` struct as return type. However, in the MDL SDK APIseparate
        interfaces like #mi::neuraylib::IMaterial_definition and #mi::neuraylib::IMaterial_instance
        are used for materials, in contrast to #mi::neuraylib::IFunction_definition and
        #mi::neuraylib::IFunction_call for functions (although these interfaces are quite similar).
        This requires that code that acts in a similar way on both, functions and materials, needs
        to be written twice.

        If this feature is enabled, then materials are treated as functions, i.e., it is possible to
        use #mi::neuraylib::IFunction_definition instead of #mi::neuraylib::IMaterial_definition,
        and #mi::neuraylib::IFunction_call instead of #mi::neuraylib::IMaterial_instance. This allows
        to write code that acts on both, functions and materials, just once. The only exception is
        the method #mi::neuraylib::IMaterial_instance::create_compiled_material(), which still
        requires to use the #mi::neuraylib::IMaterial_instance interface.

        Enabling this feature comes with a few API changes that need to be takes into account. Code
        shared between different applications, i.e., in plugins, should be able to handle both
        settings.

        - **Values returned by #mi::neuraylib::IScene_element::get_element_type() (and derived
          interfaces)**



          The method mi::neuraylib::IScene_element::get_element_type() returns
          #mi::neuraylib::ELEMENT_TYPE_FUNCTION_DEFINITION instead of
          #mi::neuraylib::ELEMENT_TYPE_MATERIAL_DEFINITION. The value
          #mi::neuraylib::ELEMENT_TYPE_MATERIAL_DEFINITION is only returned by
          #mi::neuraylib::IMaterial_definition::get_element_type() (for backward compatibility),
          but no longer by its base class #mi::neuraylib::IScene_element.



          Similarly, the method mi::neuraylib::IScene_element::get_element_type() returns
          #mi::neuraylib::ELEMENT_TYPE_FUNCTION_CALL instead of
          #mi::neuraylib::ELEMENT_TYPE_MATERIAL_INSTANCE. The value
          #mi::neuraylib::ELEMENT_TYPE_MATERIAL_INSTANCE is only returned by
          #mi::neuraylib::IMaterial_instance::get_element_type() (for backward compatibility), but
          no longer by its base class #mi::neuraylib::IScene_element.



          As a consequence, #mi::neuraylib::Definition_wrapper::get_type() and
          #mi::neuraylib::Definition_wrapper::get_element_type() only return
          #mi::neuraylib::ELEMENT_TYPE_FUNCTION_DEFINITION. Similarly,
          #mi::neuraylib::Argument_editor::get_type() and
          #mi::neuraylib::Argument_editor::get_element_type() only return
          #mi::neuraylib::ELEMENT_TYPE_FUNCTION_CALL.
        .
        - **Interface queries to distinguish functions and materials**



          Interface queries like
          #mi::base::IInterface::get_interface<mi::neuraylib::IFunction_definition>() can no longer
          be used to distinguish functions and materials. Note that such queries might occur inside
          other template inline methods, e.g., they occur as part of
          #mi::neuraylib::ITransaction::access<mi::neuraylib::IFunction_definition>(). The
          recommended way to do this is using #mi::neuraylib::IFunction_definition::is_material().
          Similarly for #mi::base::IInterface::get_interface<mi::neuraylib::IFunction_call>() and
          #mi::neuraylib::IFunction_call::is_material().
        .
        - **Type names passed to #mi::neuraylib::ITransaction::list_elements()**



          The method #mi::neuraylib::ITransaction::list_elements() will not return any hits for
          type names ``"Material_definition"`` and ``"Material_instance"``. Use the type names
          ``"Function_definition"`` and ``"Function_call"`` instead, and, if necessary,
          #mi::neuraylib::IFunction_definition::is_material() and
          #mi::neuraylib::IFunction_call::is_material() to discriminate the results.

        This feature is disabled by default. It will be enabled by default in a future release.

        This can only be configured before the MDL SDKhas been started.

        See also: #get_materials_are_functions().
        """
        return _pymdlsdk.IMdl_configuration_set_materials_are_functions(self, value)

    def get_materials_are_functions(self):
        r"""
        Indicates whether materials are treated as functions.

        See also: #set_materials_are_functions().
        """
        return _pymdlsdk.IMdl_configuration_get_materials_are_functions(self)

    def set_encoded_names_enabled(self, value):
        r"""
        Defines whether encoded names are enabled.

        See 'mi_mdl_encoded_names' for details.

        This feature is enabled by default. Support for the disabled feature will be deprecated and
        removed in a future release.

        This can only be configured before the MDL SDKhas been started.

        Notes: This feature does not yet support module names containing parentheses or commas.

        If: IRAY_API { Notes: All hosts in a cluster need to agree on this setting. }

        If: IRAY_API { Notes: This setting needs to be the identical during export and import of
                           ``.mib`` files. }

        If: IRAY_API { Notes: Support for Iray Bridge requires that this feature is enabled. }

        See also: #get_encoded_names_enabled().
        """
        return _pymdlsdk.IMdl_configuration_set_encoded_names_enabled(self, value)

    def get_encoded_names_enabled(self):
        r"""
        Indicates whether encoded names are enabled.

        See also: #set_encoded_names_enabled().
        """
        return _pymdlsdk.IMdl_configuration_get_encoded_names_enabled(self)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IMdl_configuration_compare_iid(self, iid)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IMdl_configuration__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IMdl_configuration__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IMdl_configuration_get_iid(self)

# Register IMdl_configuration in _pymdlsdk:
_pymdlsdk.IMdl_configuration_swigregister(IMdl_configuration)

def IMdl_configuration_IID():
    return _pymdlsdk.IMdl_configuration_IID()

def IMdl_configuration__get_interface(iface):
    return _pymdlsdk.IMdl_configuration__get_interface(iface)

class IMdl_execution_context(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IMdl_execution_context_swiginit(self, _pymdlsdk.new_IMdl_execution_context(*args))
    __swig_destroy__ = _pymdlsdk.delete_IMdl_execution_context

    def __deref__(self):
        return _pymdlsdk.IMdl_execution_context___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IMdl_execution_context___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IMdl_execution_context_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IMdl_execution_context___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IMdl_execution_context___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IMdl_execution_context_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IMdl_execution_context_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IMdl_execution_context__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_messages_count(self):
        r""" Returns the number of messages."""
        return _pymdlsdk.IMdl_execution_context_get_messages_count(self)

    def get_error_messages_count(self):
        r""" Returns the number of error messages."""
        return _pymdlsdk.IMdl_execution_context_get_error_messages_count(self)

    def get_message(self, index):
        r""" Returns the message at index or ``NULL``, if no such index exists."""
        return _pymdlsdk.IMdl_execution_context_get_message(self, index)

    def get_error_message(self, index):
        r""" Returns the error message at index or ``NULL``, if no such index exists."""
        return _pymdlsdk.IMdl_execution_context_get_error_message(self, index)

    def clear_messages(self):
        r""" Clears all messages."""
        return _pymdlsdk.IMdl_execution_context_clear_messages(self)

    def add_message(self, kind, severity, code, message):
        r""" Adds a message."""
        return _pymdlsdk.IMdl_execution_context_add_message(self, kind, severity, code, message)

    def get_option_count(self):
        r""" Returns the number of supported options."""
        return _pymdlsdk.IMdl_execution_context_get_option_count(self)

    def get_option_name(self, index):
        r""" Returns the option name at index."""
        return _pymdlsdk.IMdl_execution_context_get_option_name(self, index)

    def get_option_type(self, name):
        r""" Returns the option type name at index."""
        return _pymdlsdk.IMdl_execution_context_get_option_type(self, name)

    def get_option(self, *args):
        r"""
        *Overload 1:*
        Returns a string option.

        :type name: string
        :param name:          The name of the option.
        :type value: string, out
        :param value:    The value of the option.
        :rtype: int
        :return: 
                                 -  0: Success.
                                 - -1: Invalid option name.
                                 - -2: The option type does not match the value type.

        |

        *Overload 2:*
        Returns an int option.

        :type name: string
        :param name:          The name of the option.
        :type value: int, out
        :param value:    The value of the option.
        :rtype: int
        :return: 
                                 -  0: Success.
                                 - -1: Invalid option name.
                                 - -2: The option type does not match the value type.

        |

        *Overload 3:*
        Returns a float option.

        :type name: string
        :param name:          The name of the option.
        :type value: float, out
        :param value:    The value of the option.
        :rtype: int
        :return: 
                                 -  0: Success.
                                 - -1: Invalid option name.
                                 - -2: The option type does not match the value type.

        |

        *Overload 4:*
        Returns a bool option.

        :type name: string
        :param name:          The name of the option.
        :type value: boolean, out
        :param value:    The value of the option.
        :rtype: int
        :return: 
                                 -  0: Success.
                                 - -1: Invalid option name.
                                 - -2: The option type does not match the value type.

        |

        *Overload 5:*
        Returns an interface option.

        :type name: string
        :param name:          The name of the option.
        :type value: mi::base::IInterface, out
        :param value:    The value of the option.
        :rtype: int
        :return: 
                                 -  0: Success.
                                 - -1: Invalid option name.
                                 - -2: The option type does not match the value type.
        """
        return _pymdlsdk.IMdl_execution_context_get_option(self, *args)

    def set_option(self, *args):
        r"""
        *Overload 1:*
        Sets a string option.

        :type name: string
        :param name:     The name of the option.
        :type value: string
        :param value:    The value of the option.
        :rtype: int
        :return: 
                            -  0: Success.
                            - -1: Invalid option name.
                            - -2: The option type does not match the value type.

        |

        *Overload 2:*
        Sets an int option.

        :type name: string
        :param name:     The name of the option.
        :type value: int
        :param value:    The value of the option.
        :rtype: int
        :return: 
                            -  0: Success.
                            - -1: Invalid option name.
                            - -2: The option type does not match the value type.

        |

        *Overload 3:*
        Sets a float option.

        :type name: string
        :param name:     The name of the option.
        :type value: float
        :param value:    The value of the option.
        :rtype: int
        :return: 
                            -  0: Success.
                            - -1: Invalid option name.
                            - -2: The option type does not match the value type.

        |

        *Overload 4:*
        Sets a bool option.

        :type name: string
        :param name:     The name of the option.
        :type value: boolean
        :param value:    The value of the option.
        :rtype: int
        :return: 
                            -  0: Success.
                            - -1: Invalid option name.
                            - -2: The option type does not match the value type.
                            - -3: The value is invalid in the context of the option.

        |

        *Overload 5:*
        Sets an interface option.

        :type name: string
        :param name:     The name of the option.
        :type value: mi::base::IInterface
        :param value:    The value of the option.
        :rtype: int
        :return: 
                            -  0: Success.
                            - -1: Invalid option name.
                            - -2: The option type does not match the value type.
                            - -3: The value is invalid in the context of the option.
        """
        return _pymdlsdk.IMdl_execution_context_set_option(self, *args)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IMdl_execution_context_compare_iid(self, iid)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IMdl_execution_context__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IMdl_execution_context__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IMdl_execution_context_get_iid(self)

# Register IMdl_execution_context in _pymdlsdk:
_pymdlsdk.IMdl_execution_context_swigregister(IMdl_execution_context)

def IMdl_execution_context_IID():
    return _pymdlsdk.IMdl_execution_context_IID()

def IMdl_execution_context__get_interface(iface):
    return _pymdlsdk.IMdl_execution_context__get_interface(iface)

class IMdle_deserialization_callback(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IMdle_deserialization_callback_swiginit(self, _pymdlsdk.new_IMdle_deserialization_callback(*args))
    __swig_destroy__ = _pymdlsdk.delete_IMdle_deserialization_callback

    def __deref__(self):
        return _pymdlsdk.IMdle_deserialization_callback___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IMdle_deserialization_callback___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IMdle_deserialization_callback_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IMdle_deserialization_callback___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IMdle_deserialization_callback___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IMdle_deserialization_callback_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IMdle_deserialization_callback_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IMdle_deserialization_callback__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_deserialized_filename(self, serialized_filename):
        r"""
        Returns a the filename of an MDLE module given its serialized filename.

        The callback might get involved several times with the same argument. You might want to
        cache results if the computation is expensive.

        :type serialized_filename: string
        :param serialized_filename:   The "serialized filename" of an MDLE module. This is the string
                                         that has been returned by
                                #mi::neuraylib::IMdle_serialization_callback::get_serialized_filename().
        :rtype: :py:class:`IString`
        :return: The actual filename of that MDLE module.
        """
        return _pymdlsdk.IMdle_deserialization_callback_get_deserialized_filename(self, serialized_filename)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IMdle_deserialization_callback_compare_iid(self, iid)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IMdle_deserialization_callback__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IMdle_deserialization_callback__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IMdle_deserialization_callback_get_iid(self)

# Register IMdle_deserialization_callback in _pymdlsdk:
_pymdlsdk.IMdle_deserialization_callback_swigregister(IMdle_deserialization_callback)

def IMdle_deserialization_callback_IID():
    return _pymdlsdk.IMdle_deserialization_callback_IID()

def IMdle_deserialization_callback__get_interface(iface):
    return _pymdlsdk.IMdle_deserialization_callback__get_interface(iface)

class IMdle_serialization_callback(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IMdle_serialization_callback_swiginit(self, _pymdlsdk.new_IMdle_serialization_callback(*args))
    __swig_destroy__ = _pymdlsdk.delete_IMdle_serialization_callback

    def __deref__(self):
        return _pymdlsdk.IMdle_serialization_callback___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IMdle_serialization_callback___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IMdle_serialization_callback_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IMdle_serialization_callback___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IMdle_serialization_callback___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IMdle_serialization_callback_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IMdle_serialization_callback_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IMdle_serialization_callback__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_serialized_filename(self, filename):
        r"""
        Returns a serialized filename for the given MDLE filename.

        The implemented mapping should be reversible, otherwise you will run into problems
        implementing the corresponding instance of #mi::neuraylib::IMdle_deserialization_callback.

        The callback might get involved several times with the same argument. You might want to
        cache results if the computation is expensive.

        :type filename: string
        :param filename:   The current filename of an MDLE module.
        :rtype: :py:class:`IString`
        :return: The "serialized filename" of that MDLE module. Technically, this can be
                              any string with ``".mdle"`` suffix, it does *not* need to refer to an
                              existing MDLE file on disk.
        """
        return _pymdlsdk.IMdle_serialization_callback_get_serialized_filename(self, filename)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IMdle_serialization_callback_compare_iid(self, iid)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IMdle_serialization_callback__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IMdle_serialization_callback__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IMdle_serialization_callback_get_iid(self)

# Register IMdle_serialization_callback in _pymdlsdk:
_pymdlsdk.IMdle_serialization_callback_swigregister(IMdle_serialization_callback)

def IMdle_serialization_callback_IID():
    return _pymdlsdk.IMdle_serialization_callback_IID()

def IMdle_serialization_callback__get_interface(iface):
    return _pymdlsdk.IMdle_serialization_callback__get_interface(iface)

class IMdl_factory(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IMdl_factory_swiginit(self, _pymdlsdk.new_IMdl_factory(*args))
    __swig_destroy__ = _pymdlsdk.delete_IMdl_factory

    def __deref__(self):
        return _pymdlsdk.IMdl_factory___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IMdl_factory___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IMdl_factory_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IMdl_factory___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IMdl_factory___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IMdl_factory_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IMdl_factory_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IMdl_factory__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def create_type_factory(self, transaction):
        r""" Returns an MDL type factory for the given transaction."""
        return _pymdlsdk.IMdl_factory_create_type_factory(self, transaction)

    def create_value_factory(self, transaction):
        r""" Returns an MDL value factory for the given transaction."""
        return _pymdlsdk.IMdl_factory_create_value_factory(self, transaction)

    def create_expression_factory(self, transaction):
        r""" Returns an MDL expression factory for the given transaction."""
        return _pymdlsdk.IMdl_factory_create_expression_factory(self, transaction)

    def create_execution_context(self):
        r""" Creates an execution context."""
        return _pymdlsdk.IMdl_factory_create_execution_context(self)

    def create_texture_with_ret(self, transaction, file_path, shape, gamma, shared):
        r"""
        Creates a value referencing a texture identified by an MDL file path.

        :type transaction: :py:class:`ITransaction`
        :param transaction:   The transaction to be used.
        :type file_path: string
        :param file_path:     The absolute MDL file path that identifies the texture. The MDL
                                 search paths are used to resolve the file path. See section 2.2 in
                                 ['MDLLS]' for details.
        :type shape: int
        :param shape:         The value that is returned by
                                 #mi::neuraylib::IType_texture::get_shape() on the type corresponding
                                 to the return value.
        :type gamma: float
        :param gamma:         The value that is returned by #mi::neuraylib::ITexture::get_gamma()
                                 on the DB element referenced by the return value.
        :type shared: boolean
        :param shared:        Indicates whether you want to re-use the DB elements for that texture
                                 if it has already been loaded, or if you want to create new DB elements
                                 in all cases. Note that sharing is based on the location where the
                                 texture is finally located and includes sharing with instances that
                                 have not explicitly been loaded via this method, e.g., textures in
                                 defaults.
        :type errors: int, optional
        :param errors:        An optional pointer to an #mi::Sint32 to which an error code will be
                                 written. The error codes have the following meaning:
                                 -  0: Success.
                                 - -1: Invalid parameters (``NULL`` pointer).
                                 - -2: The file path is not an absolute MDL file path.
                                 - -3: Failed to resolve the given file path, or no suitable image
                                       plugin available.
        :rtype: :py:class:`IValue_texture`
        :return: The value referencing the texture, or ``NULL`` in case of failure.
        """
        return _pymdlsdk.IMdl_factory_create_texture_with_ret(self, transaction, file_path, shape, gamma, shared)

    def create_texture(self, transaction, file_path, shape, gamma, shared):
        r"""
        Creates a value referencing a texture identified by an MDL file path.

        :type transaction: :py:class:`ITransaction`
        :param transaction:   The transaction to be used.
        :type file_path: string
        :param file_path:     The absolute MDL file path that identifies the texture. The MDL
                                 search paths are used to resolve the file path. See section 2.2 in
                                 ['MDLLS]' for details.
        :type shape: int
        :param shape:         The value that is returned by
                                 #mi::neuraylib::IType_texture::get_shape() on the type corresponding
                                 to the return value.
        :type gamma: float
        :param gamma:         The value that is returned by #mi::neuraylib::ITexture::get_gamma()
                                 on the DB element referenced by the return value.
        :type shared: boolean
        :param shared:        Indicates whether you want to re-use the DB elements for that texture
                                 if it has already been loaded, or if you want to create new DB elements
                                 in all cases. Note that sharing is based on the location where the
                                 texture is finally located and includes sharing with instances that
                                 have not explicitly been loaded via this method, e.g., textures in
                                 defaults.
        :param errors:        An optional pointer to an #mi::Sint32 to which an error code will be
                                 written. The error codes have the following meaning:
                                 -  0: Success.
                                 - -1: Invalid parameters (``NULL`` pointer).
                                 - -2: The file path is not an absolute MDL file path.
                                 - -3: Failed to resolve the given file path, or no suitable image
                                       plugin available.
        :rtype: :py:class:`IValue_texture`
        :return: The value referencing the texture, or ``NULL`` in case of failure.
        """
        return _pymdlsdk.IMdl_factory_create_texture(self, transaction, file_path, shape, gamma, shared)

    def create_light_profile_with_ret(self, transaction, file_path, shared):
        r"""
        Creates a value referencing a light profile identified by an MDL file path.

        :type transaction: :py:class:`ITransaction`
        :param transaction:   The transaction to be used.
        :type file_path: string
        :param file_path:     The absolute MDL file path that identifies the light profile. The MDL
                                 search paths are used to resolve the file path. See section 2.2 in
                                 ['MDLLS]' for details.
        :type shared: boolean
        :param shared:        Indicates whether you want to re-use the DB element for that light
                                 profile if it has already been loaded, or if you want to create a new
                                 DB element in all cases. Note that sharing is based on the location
                                 where the light profile is finally located and includes sharing with
                                 instances that have not explicitly been loaded via this method, e.g.,
                                 light profiles in defaults.
        :type errors: int, optional
        :param errors:        An optional pointer to an #mi::Sint32 to which an error code will be
                                 written. The error codes have the following meaning:
                                 -  0: Success.
                                 - -1: Invalid parameters (``NULL`` pointer).
                                 - -2: The file path is not an absolute MDL file path.
                                 - -3: Failed to resolve the given file path.
        :rtype: :py:class:`IValue_light_profile`
        :return: The value referencing the light profile, or ``NULL`` in case of failure.
        """
        return _pymdlsdk.IMdl_factory_create_light_profile_with_ret(self, transaction, file_path, shared)

    def create_light_profile(self, transaction, file_path, shared):
        r"""
        Creates a value referencing a light profile identified by an MDL file path.

        :type transaction: :py:class:`ITransaction`
        :param transaction:   The transaction to be used.
        :type file_path: string
        :param file_path:     The absolute MDL file path that identifies the light profile. The MDL
                                 search paths are used to resolve the file path. See section 2.2 in
                                 ['MDLLS]' for details.
        :type shared: boolean
        :param shared:        Indicates whether you want to re-use the DB element for that light
                                 profile if it has already been loaded, or if you want to create a new
                                 DB element in all cases. Note that sharing is based on the location
                                 where the light profile is finally located and includes sharing with
                                 instances that have not explicitly been loaded via this method, e.g.,
                                 light profiles in defaults.
        :param errors:        An optional pointer to an #mi::Sint32 to which an error code will be
                                 written. The error codes have the following meaning:
                                 -  0: Success.
                                 - -1: Invalid parameters (``NULL`` pointer).
                                 - -2: The file path is not an absolute MDL file path.
                                 - -3: Failed to resolve the given file path.
        :rtype: :py:class:`IValue_light_profile`
        :return: The value referencing the light profile, or ``NULL`` in case of failure.
        """
        return _pymdlsdk.IMdl_factory_create_light_profile(self, transaction, file_path, shared)

    def create_bsdf_measurement_with_ret(self, transaction, file_path, shared):
        r"""
        Creates a value referencing a BSDF measurement identified by an MDL file path.

        :type transaction: :py:class:`ITransaction`
        :param transaction:   The transaction to be used.
        :type file_path: string
        :param file_path:     The absolute MDL file path that identifies the BSDF measurement. The
                                 MDL search paths are used to resolve the file path. See section 2.2 in
                                 ['MDLLS]' for details.
        :type shared: boolean
        :param shared:        Indicates whether you want to re-use the DB element for that BSDF
                                 measurement if it has already been loaded, or if you want to create a
                                 new DB element in all cases. Note that sharing is based on the location
                                 where the BSDF measurement is finally located and includes sharing with
                                 instances that have not explicitly been loaded via this method, e.g.,
                                 BSDF measurements in defaults.
        :type errors: int, optional
        :param errors:        An optional pointer to an #mi::Sint32 to which an error code will be
                                 written. The error codes have the following meaning:
                                 -  0: Success.
                                 - -1: Invalid parameters (``NULL`` pointer).
                                 - -2: The file path is not an absolute MDL file path.
                                 - -3: Failed to resolve the given file path.
        :rtype: :py:class:`IValue_bsdf_measurement`
        :return: The value referencing the BSDF measurement, or ``NULL`` in case of
                                 failure.
        """
        return _pymdlsdk.IMdl_factory_create_bsdf_measurement_with_ret(self, transaction, file_path, shared)

    def create_bsdf_measurement(self, transaction, file_path, shared):
        r"""
        Creates a value referencing a BSDF measurement identified by an MDL file path.

        :type transaction: :py:class:`ITransaction`
        :param transaction:   The transaction to be used.
        :type file_path: string
        :param file_path:     The absolute MDL file path that identifies the BSDF measurement. The
                                 MDL search paths are used to resolve the file path. See section 2.2 in
                                 ['MDLLS]' for details.
        :type shared: boolean
        :param shared:        Indicates whether you want to re-use the DB element for that BSDF
                                 measurement if it has already been loaded, or if you want to create a
                                 new DB element in all cases. Note that sharing is based on the location
                                 where the BSDF measurement is finally located and includes sharing with
                                 instances that have not explicitly been loaded via this method, e.g.,
                                 BSDF measurements in defaults.
        :param errors:        An optional pointer to an #mi::Sint32 to which an error code will be
                                 written. The error codes have the following meaning:
                                 -  0: Success.
                                 - -1: Invalid parameters (``NULL`` pointer).
                                 - -2: The file path is not an absolute MDL file path.
                                 - -3: Failed to resolve the given file path.
        :rtype: :py:class:`IValue_bsdf_measurement`
        :return: The value referencing the BSDF measurement, or ``NULL`` in case of
                                 failure.
        """
        return _pymdlsdk.IMdl_factory_create_bsdf_measurement(self, transaction, file_path, shared)

    def create_module_builder(self, transaction, module_name, min_module_version, max_module_version, context):
        r"""
        Creates a module builder for a given module.

        :type transaction: :py:class:`ITransaction`
        :param transaction:          The transaction to be used.
        :type module_name: string
        :param module_name:          The DB name of the MDL module to build. If there is no such
                                        module, then an empty module with this name and
           ``min_module_version`` is created. Otherwise, the existing module
                                        is edited. Builtin modules or MDLE modules cannot be built or
                                        edited.
        :type min_module_version: int
        :param min_module_version:   The initial MDL version of the new module. Ignored if the
                                        module exists already.
        :type max_module_version: int
        :param max_module_version:   The maximal desired MDL version of the module. If higher than
                                        the current MDL version of the module, then the module builder
                                        will upgrade the MDL version as necessary to handle requests
                                        requiring newer features.
        :type context: :py:class:`IMdl_execution_context`
        :param context:              An execution context which can be queried for detailed error
                                        messages after the operation has finished. Can be ``NULL``.
        :rtype: mi::neuraylib::IMdl_module_builder
        :return: The module builder for the given module, or ``NULL`` in
                                        case of errors.
        """
        return _pymdlsdk.IMdl_factory_create_module_builder(self, transaction, module_name, min_module_version, max_module_version, context)

    def create_module_transformer(self, transaction, module_name, context):
        r"""
        Creates a module transformer for a given module.

        :type transaction: :py:class:`ITransaction`
        :param transaction:   The transaction to be used.
        :type module_name: string
        :param module_name:   The DB name of the MDL module to transform. Builtin modules cannot be
                                 transformed.
        :type context: :py:class:`IMdl_execution_context`
        :param context:       An execution context which can be queried for detailed error messages
                                 after the operation has finished. Can be ``NULL``.
        :rtype: mi::neuraylib::IMdl_module_transformer
        :return: The module transformer for the given module, or ``NULL`` in case of
                                 errors.
        """
        return _pymdlsdk.IMdl_factory_create_module_transformer(self, transaction, module_name, context)

    def get_db_module_name(self, mdl_name):
        r"""
        Returns the DB name for the MDL name of a module (or file path for MDLE modules).

        For example, given ``"::state"``, the method returns ``"mdl::state"``.

        Notes: This method does not check for existence of the corresponding DB element, nor does it
              check that the input is a valid module name.

        Usage of this method is strongly recommended instead of manually prepending ``"mdl"``,
              since (a) the mapping is more complicated than that, e.g., for MDLE modules, and (b)
              the mapping might change in the future.

        :type mdl_name: string
        :param mdl_name:      The MDL name of the module (non-MDLE and MDLE module), or the file path
                                 of an MDLE module.
        :rtype: :py:class:`IString`
        :return: The DB name of that module, or ``NULL`` if ``mdl_name`` is invalid.
        """
        return _pymdlsdk.IMdl_factory_get_db_module_name(self, mdl_name)

    def get_db_definition_name(self, mdl_name):
        r"""
        Returns the DB name for the MDL name of an material or function definition.

        For example, given ``"::state::normal()"``, the method returns ``"mdl::state::normal()"``.

        Notes: This method does not check for existence of the corresponding DB element, nor does it
              check that the input is a valid material or definition name.

        Usage of this method is strongly recommended instead of manually prepending ``"mdl"``,
              since (a) the mapping is more complicated than that, e.g., for MDLE modules, and (b)
              the mapping might change in the future.

        :type mdl_name: string
        :param mdl_name:      The MDL name of the material or function definition.
        :rtype: :py:class:`IString`
        :return: The DB name of that material or function definition, or ``NULL`` if
                                 ``mdl_name`` is invalid.
        """
        return _pymdlsdk.IMdl_factory_get_db_definition_name(self, mdl_name)

    def analyze_uniform(self, transaction, root_name, root_uniform, query_expr, query_result, error_path, context):
        r"""
         Analyzes whether an expression graph violates the uniform constraints.

         Notes: This method can be used to check already created graphs, but it can also be used to
               check whether a hypothetical connection would observe the uniform constraints: First,
               invoke the method with the root of the existing graph, ``root_uniform`` set to
        ``false`` (at least for materials), and ``query_expr`` set to the graph node to be
               replaced. If the call returns with ``query_result`` set to ``false`` (and no errors in
               the context), then any (valid) subgraph can be connected. Otherwise, invoke the
               method again with the root of the to-be-connected subgraph, ``root_uniform`` set to
        ``true``, and ``query_expr`` set to ``NULL``. If there are no errors, then the subgraph
               can be connected.

         Make sure that ``query_expr`` (if not ``NULL)`` can be reached from ``root_name``,
               otherwise ``query_result`` is always ``false``. In particular, arguments passed during
               call creation (or later for argument changes) are cloned, and the expression that is
               part of the graph is different from the one that was used to construct the graph
               (equal, but not identical).

         :type transaction: :py:class:`ITransaction`
         :param transaction:             The transaction to be used.
         :type root_name: string
         :param root_name:               DB name of the root node of the graph (material instance or
                                            function call).
         :type root_uniform: boolean
         :param root_uniform:            Indicates whether the root node should be uniform.
         :type query_expr: :py:class:`IExpression`
         :param query_expr:              A node of the call graph for which the uniform property is
                                            to be queried. This expression is *only* used to identify
                                            the corresponding node in the graph, i.e., it even makes
                                            sense to pass constant expressions (which by themselves are
                                            always uniform) to determine whether a to-be-connected call
                                            expression has to be uniform. Can be ``NULL``.
         :type query_result: boolean, out
         :param query_result:       Indicates whether ``query_expr`` needs to be uniform (or
                                            ``false`` if ``query_expr`` is ``NULL``, or in case of errors).
         :type error_path: :py:class:`IString`, out
         :param error_path:         A path to a node of the graph that violates the uniform
                                            constraints, or the empty string if there is no such node
                                            (or in case of errors). Such violations are also reported
                                            via ``context``. Can be ``NULL``.
         :type context: :py:class:`IMdl_execution_context`
         :param context:                 The execution context can be used to pass options and to
                                            retrieve error and/or warning messages. Can be ``NULL``.
        """
        return _pymdlsdk.IMdl_factory_analyze_uniform(self, transaction, root_name, root_uniform, query_expr, query_result, error_path, context)

    def decode_name(self, name):
        r"""
        Decodes a DB or MDL name.

        :type name: string
        :param name:   The encoded DB or MDL name to be decoded.
        :rtype: :py:class:`IString`
        :return: The decoded DB or MDL name, or ``NULL`` if ``name`` is ``NULL``. Returns the
                          input string if encoded names are disabled.

        Notes: This method should only be used for display purposes. Do *not* use the returned
              name to identify functions or materials since this representation is ambiguous. For
              modules, it is possible to re-encode their name without loss of information, see
              #encode_module_name(). This is *not* possible for names of function or material
              definitions.

        This method does not require the corresponding module to be loaded. The method does
              not check whether the given name is valid, nor whether it is defined in the
              corresponding module.
        """
        return _pymdlsdk.IMdl_factory_decode_name(self, name)

    def encode_module_name(self, name):
        r"""
        Encodes a DB or MDL module name.

        :type name: string
        :param name:    The decoded DB or MDL module name to be encoded.
        :rtype: :py:class:`IString`
        :return: The encoded DB or MDL module name, or ``NULL`` if ``name`` is ``NULL``. Returns
                           the input string if encoded names are disabled.

        Notes: This method does not require the corresponding module to be loaded. The method does
              not check whether the given name is valid.

        See also: #mi::neuraylib::IMdl_factory::encode_function_definition_name(),
             #mi::neuraylib::IMdl_factory::encode_type_name()
        """
        return _pymdlsdk.IMdl_factory_encode_module_name(self, name)

    def encode_function_definition_name(self, name, parameter_types):
        r"""
        Encodes a DB or MDL function or material definition name.

        :type name: string
        :param name:             The decoded DB or MDL name of a function or material definition
                                    *without* signature.
        :type parameter_types: :py:class:`IArray`
        :param parameter_types:  A static or dynamic array with elements of type #mi::IString
                                    representing decoded positional parameter type names. The value
                                    ``NULL`` can be used for functions or materials without parameters
                                    (treated like an empty array).
        :rtype: :py:class:`IString`
        :return: The encoded function or material definition name, or ``NULL`` if
                                    ``name`` or one of the array elements is ``NULL``. If encoded names
                                    are disabled, then the individual components of the name are joined
                                    by parentheses and commas without further encoding.

        Notes: This method does not require the corresponding module to be loaded. The method does
              not check whether the given name is valid, nor whether it is defined in the
              corresponding module.

        See also: #mi::neuraylib::IMdl_factory::encode_module_name(),
             #mi::neuraylib::IMdl_factory::encode_type_name()
        """
        return _pymdlsdk.IMdl_factory_encode_function_definition_name(self, name, parameter_types)

    def encode_type_name(self, name):
        r"""
        Encodes an MDL type name.

        :type name: string
        :param name:             The decoded MDL name of a type.
        :rtype: :py:class:`IString`
        :return: The encoded MDL name of the type, or ``NULL`` if ``name`` is ``NULL``.
                                    Returns the input string if encoded names are disabled

        Notes: This method does not require the corresponding module to be loaded. The method does
              not check whether the given name is valid, nor whether it is defined in the
              corresponding module.

        See also: #mi::neuraylib::IMdl_factory::encode_function_definition_name(),
             #mi::neuraylib::IMdl_factory::encode_module_name()
        """
        return _pymdlsdk.IMdl_factory_encode_type_name(self, name)

    def deprecated_create_variants(self, transaction, module_name, variant_data):
        return _pymdlsdk.IMdl_factory_deprecated_create_variants(self, transaction, module_name, variant_data)

    def deprecated_create_materials(self, *args):
        return _pymdlsdk.IMdl_factory_deprecated_create_materials(self, *args)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IMdl_factory_compare_iid(self, iid)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IMdl_factory__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IMdl_factory__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IMdl_factory_get_iid(self)

# Register IMdl_factory in _pymdlsdk:
_pymdlsdk.IMdl_factory_swigregister(IMdl_factory)

def IMdl_factory_IID():
    return _pymdlsdk.IMdl_factory_IID()

def IMdl_factory__get_interface(iface):
    return _pymdlsdk.IMdl_factory__get_interface(iface)

class IMdl_impexp_api(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IMdl_impexp_api_swiginit(self, _pymdlsdk.new_IMdl_impexp_api(*args))
    __swig_destroy__ = _pymdlsdk.delete_IMdl_impexp_api

    def __deref__(self):
        return _pymdlsdk.IMdl_impexp_api___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IMdl_impexp_api___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IMdl_impexp_api_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IMdl_impexp_api___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IMdl_impexp_api___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IMdl_impexp_api_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IMdl_impexp_api_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IMdl_impexp_api__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def load_module(self, transaction, argument, context=None):
        r"""
        Loads an MDL module from disk (or a builtin module) into the database.

        The module is located on disk according to the module search paths
        (see #mi::neuraylib::IMdl_configuration::add_mdl_path()), loaded, and compiled.
        If successful, the method creates DB elements for the module and all
        its imported modules, as well as for all material and function definitions contained in
        these modules.

        The method can also be used for builtin modules for which the first step, locating the
        module on disk, is skipped.

        :type transaction: :py:class:`ITransaction`
        :param transaction:   The transaction to be used.
        :type argument: string
        :param argument:      The MDL name of the module (for non-MDLE modules), or an MDLE file
                                 path (absolute or relative to the current working directory).
        :type context: :py:class:`IMdl_execution_context`, optional
        :param context:       The execution context can be used to pass options to control the
                                 behavior of the MDL compiler. The following options are supported
                                 by this operation:
                                 - string "internal_space" = "coordinate_object"|"coordinate_world"
                                   (default = "coordinate_world")
                                 .
                                 During module loading, compiler messages
                                 like errors or warnings are stored in the context. Can be ``NULL``.
        :rtype: int
        :return: 
                                 -  1: Success (module exists already, loading from file was skipped).
                                 -  0: Success (module was actually loaded from file or is a builtin
                                       module).
                                 - -1: The MDL module name/MDLE file path ``argument`` is
                                       invalid or a ``NULL`` pointer.
                                 - -2: Failed to find or to compile the module ``argument``.
                                 - -3: The DB name for an imported module is already in use but is not
                                       an MDL module, or the DB name for a definition in this module is
                                       already in use.
                                 - -4: Initialization of an imported module failed.

        See also: #mi::neuraylib::IMdl_impexp_api::get_mdl_module_name()
        """
        return _pymdlsdk.IMdl_impexp_api_load_module(self, transaction, argument, context)

    def load_module_from_string(self, transaction, module_name, module_source, context=None):
        r"""
        Loads an MDL module from memory into the database.

        The provided module source is compiled. If successful, the method creates DB elements for
        the module and all its imported modules, as well as for all material and function
        definitions contained in these modules.

        :type transaction: :py:class:`ITransaction`
        :param transaction:   The transaction to be used.
        :type module_name: string
        :param module_name:   The MDL name of the module.
        :type module_source: string
        :param module_source: The MDL source code of the module.
        :type context: :py:class:`IMdl_execution_context`, optional
        :param context:       The execution context can be used to pass options to control the
                                 behavior of the MDL compiler. The following options are supported
                                 by this operation:
                                 - string "internal_space" = "coordinate_object"|"coordinate_world"
                                   (default = "coordinate_world")
                                 .
                                 During module loading, compiler messages
                                 like errors or warnings are stored in the context. Can be ``NULL``.
        :rtype: int
        :return: 
                                 -  1: Success (module exists already, creating from ``module_source``
                                       was skipped).
                                 -  0: Success (module was actually created from ``module_source)``.
                                 - -1: The module name ``module_name`` is invalid, or ``module_name`` or
                                       ``module_source`` is a ``NULL`` pointer.
                                 - -2: Shadows a file-based module or failed to compile the module
           ``module_name``.
                                 - -3: The DB name for an imported module is already in use but is not
                                       an MDL module, or the DB name for a definition in this module is
                                       already in use.
                                 - -4: Initialization of an imported module failed.

        See also: #mi::neuraylib::IMdl_impexp_api::get_mdl_module_name()
        """
        return _pymdlsdk.IMdl_impexp_api_load_module_from_string(self, transaction, module_name, module_source, context)

    def export_module(self, transaction, module_name, filename, context=None):
        r"""
        Exports an MDL module from the database to disk.

        The following options are supported:
        - ``"bundle_resources"`` of type bool: If ``true``, referenced resources are exported
          into the same directory as the module, even if they can be found via the module search
          path. Default: ``false``.

        :type transaction: :py:class:`ITransaction`
        :param transaction:       The transaction to be used.
        :type module_name: string
        :param module_name:       The DB name of the MDL module to export.
        :type filename: string
        :param filename:          The name of the file to be used for the export.
        :type context: :py:class:`IMdl_execution_context`, optional
        :param context:           The execution context can be used to pass options to control the
                                     behavior of the MDL compiler. During module loading, compiler
                                     messages like errors or warnings are stored in the context.
                                     Can be ``NULL``.
        :rtype: int
        :return: 
                                     -     0: Success.
                                     -    -1: Invalid parameters (``NULL`` pointer).
                                     -    -2: Failed to open ``filename`` for write operations.
                                     - -6002: There is no MDL module in the database of the given name.
                                     - -6003: The export failed for unknown reasons.
                                     - -6004: The MDL module can not be exported since it is a builtin
                                              module.
                                     - -6005: The MDL module can not be exported since ``filename`` does
                                              not result in a valid MDL identifier.
                                     - -6010: Incorrect type for a referenced resource.
                                     - -6013: The export of a file-based resource failed.
                                     - -6014: The export of a memory-based resource failed.
                                     - -6016: The export of an archive-based resource failed.
        """
        return _pymdlsdk.IMdl_impexp_api_export_module(self, transaction, module_name, filename, context)

    def export_module_to_string(self, transaction, module_name, exported_module, context=None):
        r"""
        Exports an MDL module from the database to string.

        :type transaction: :py:class:`ITransaction`
        :param transaction:       The transaction to be used.
        :type module_name: string
        :param module_name:       The DB name of the MDL module to export.
        :type exported_module: :py:class:`IString`
        :param exported_module:   The exported module source code is written to this string.
        :type context: :py:class:`IMdl_execution_context`, optional
        :param context:           The execution context can be used to pass options to control the
                                     behavior of the MDL compiler. During module loading, compiler
                                     messages like errors or warnings are stored in the context.
                                     Can be ``NULL``.
        :rtype: int
        :return: 
                                     -     0: Success.
                                     -    -1: Invalid parameters (``NULL`` pointer).
                                     - -6002: There is no MDL module in the database of the given name.
                                     - -6003: The export failed for unknown reasons.
                                     - -6004: The MDL module can not be exported since it is a builtin
                                              module.
                                     - -6006: The option ``bundle_resources`` is not supported for
                                              string-based exports.
                                     - -6010: Incorrect type for a referenced resource.
                                     - -6011: The export of file-based resources is not supported for
                                              string-based exports.
                                     - -6012: The export of memory-based resources is not supported for
                                              string-based exports.
                                     - -6013: The export of a file-based resource failed.
                                     - -6014: The export of a memory-based resource failed.
                                     - -6015: The export of archive-based resources is not supported for
                                              string-based exports.
                                     - -6016: The export of an archive-based resource failed.
        """
        return _pymdlsdk.IMdl_impexp_api_export_module_to_string(self, transaction, module_name, exported_module, context)

    def export_canvas(self, filename, canvas, quality=100, force_default_gamma=False):
        r"""
        Exports a canvas to a file on disk.

        If the image plugin that is selected for the export based on the ``filename`` parameter is
        not capable of handling the pixel type of ``canvas``, the canvas is internally converted into
        one of the pixel types supported by that image plugin for export. If the image plugin
        supports multiple pixel types for export, the "best" of them (w.r.t. the pixel type of the
        canvas) is chosen.

        The "best" pixel type is determined by attempting to apply the following conversions in the
        given order to the pixel type of the canvas:
        - use an equivalent pixel type (``"Color"`` instead of ``"Float32<4>"`` and vice versa,
          similar for ``"Rgb_fp"`` / ``"Float32<3>"`` and ``"Rgba"`` / ``"Sint32"``),
        - add an alpha channel (if not already present),
        - increase bits per channel (smaller increase preferred),
        - add additional channels (if possible),
        - decrease bits per channel (smaller decrease preferred), and
        - drop one or more channels.

        :type filename: string
        :param filename:              The file name of the resource to export the canvas to. The
                                         ending of the file name determines the image format, e.g.,
                                         ``".jpg"``. Note that support for a given image format requires
                                         an image plugin capable of handling that format.
        :type canvas: mi::neuraylib::ICanvas
        :param canvas:                The canvas to export.
        :type quality: int, optional
        :param quality:               The compression quality is an integer in the range from 0 to
                                         100, where 0 is the lowest quality, and 100 is the highest
                                         quality.
        :type force_default_gamma: boolean, optional
        :param force_default_gamma:   If enabled, adjusts the gamma value of the exported pixel data
                                         according to the pixel type chosen for export (1.0 for HDR
                                         pixel types, 2.2 for LDR pixel types).
        :rtype: int
        :return: 
                                        -  0: Success.
                                        - -1: Invalid file name.
                                        - -2: Invalid canvas.
                                        - -3: Invalid quality.
                                        - -4: Unspecified failure.
        """
        return _pymdlsdk.IMdl_impexp_api_export_canvas(self, filename, canvas, quality, force_default_gamma)

    def export_lightprofile(self, filename, lightprofile):
        r"""
        Exports a light profile to disk.

        :type filename: string
        :param filename:          The file name of the resource to export the light profile to.
        :type lightprofile: :py:class:`ILightprofile`
        :param lightprofile:      The light profile to export.
        :rtype: int
        :return: 
                                     -  0: Success.
                                     - -1: Invalid file name.
                                     - -2: Invalid light profile.
                                     - -4: Unspecified failure.
        """
        return _pymdlsdk.IMdl_impexp_api_export_lightprofile(self, filename, lightprofile)

    def export_bsdf_data(self, filename, reflection, transmission):
        r"""
        Exports BSDF data to a file on disk.

        :type filename: string
        :param filename:          The file name of the resource to export the BSDF measurement to.
        :type reflection: mi::neuraylib::IBsdf_isotropic_data
        :param reflection:        The BSDF data for reflection to export. Can be ``NULL``.
        :type transmission: mi::neuraylib::IBsdf_isotropic_data
        :param transmission:      The BSDF data for transmission to export. Can be ``NULL``.
        :rtype: int
        :return: 
                                     -  0: Success.
                                     - -1: Invalid file name.
                                     - -4: Unspecified failure.
        """
        return _pymdlsdk.IMdl_impexp_api_export_bsdf_data(self, filename, reflection, transmission)

    def get_mdl_module_name(self, *args):
        r"""
        Returns the MDL name for an MDL module identified by its filename.

        The return value can be passed to #mi::neuraylib::IMdl_impexp_api::load_module() or
        #mi::neuraylib::IMdl_factory::get_db_module_name().

        Notes: This method does not support MDLE modules. This is also not necessary, since in case
              of MDLEs the filename can be directly passed to
              #mi::neuraylib::IMdl_impexp_api::load_module() or
              #mi::neuraylib::IMdl_factory::get_db_module_name().

        :type filename: string
        :param filename:   The filename of an MDL module (excluding MDLE modules).
        :type option: int, optional
        :param option:     Controls the algorithm's behavior if several overlapping search paths
                              contain the given filename.
        :rtype: :py:class:`IString`
        :return: The MDL name of the given module, or ``NULL`` in case of failures.
        """
        return _pymdlsdk.IMdl_impexp_api_get_mdl_module_name(self, *args)

    def uvtile_marker_to_string(self, marker, u, v):
        r"""
        Replaces an uv-tile marker by coordinates of a given uv-tile.

        :type marker: string
        :param marker:   String containing a valid uv-tile marker.
        :type u: int
        :param u:        The u coordinate of the uv-tile.
        :type v: int
        :param v:        The v coordinate of the uv-tile.
        :rtype: :py:class:`IString`
        :return: String with the uv-tile marker replaced by the coordinates of the uv-tile,
                            ``NULL`` in case of errors.
        """
        return _pymdlsdk.IMdl_impexp_api_uvtile_marker_to_string(self, marker, u, v)

    def uvtile_string_to_marker(self, str, marker):
        r"""
        Replaces the pattern describing the coordinates of a uv-tile by the given marker.

        :type str: string
        :param str:      String containing the coordinate pattern, e.g., "_u1_v1".
        :type marker: string
        :param marker:   The marker to replace the pattern with, e.g., "<UVTILE1>".
        :rtype: :py:class:`IString`
        :return: The string with the coordinate pattern replaced by the marker (if found), or
                            ``NULL`` case of errors.
        """
        return _pymdlsdk.IMdl_impexp_api_uvtile_string_to_marker(self, str, marker)

    def serialize_function_name(self, definition_name, argument_types, return_type, mdle_callback, context):
        r"""
        Serializes the name of a function or material definition.

        See also: 'mi_mdl_serialized_names'

        :type definition_name: string
        :param definition_name:   The DB name of the function or material definition.
        :type argument_types: :py:class:`IType_list`
        :param argument_types:    The arguments of the corresponding function call or material
                                     instance. Required for template-like functions, ignored (can be
                                     ``NULL)`` in all other cases.
        :type return_type: :py:class:`IType`
        :param return_type:       The arguments of the corresponding function call or material
                                     instance. Required for the cast operator, ignored (can be
                                     ``NULL)`` in all other cases.
        :type mdle_callback: :py:class:`IMdle_serialization_callback`
        :param mdle_callback:     A callback to map the filename of MDLE modules. Ignored for
                                     non-MDLE modules. Can be ``NULL`` (which is treated like a callback
                                     implementing the identity transformation).
        :type context: :py:class:`IMdl_execution_context`
        :param context:           The execution context can be used to pass options and to retrieve
                                     error and/or warning messages. Can be ``NULL``.
        :rtype: :py:class:`ISerialized_function_name`
        :return: The serialized function name, or ``NULL`` in case of errors, or if
                                     encoded names are disabled.
        """
        return _pymdlsdk.IMdl_impexp_api_serialize_function_name(self, definition_name, argument_types, return_type, mdle_callback, context)

    def deserialize_function_name(self, *args):
        r"""
        *Overload 1:*
        Deserializes the serialized name of a function or material definition (first overload)

        See also: 'mi_mdl_serialized_names'

        :type transaction: :py:class:`ITransaction`
        :param transaction:       The transaction to be used.
        :type function_name: string
        :param function_name:     The serialized name of a function or material definition.
        :type mdle_callback: :py:class:`IMdle_deserialization_callback`
        :param mdle_callback:     A callback to map the filename of MDLE modules. Ignored for
                                     non-MDLE modules. Can be ``NULL`` (which is treated like a callback
                                     implementing the identity transformation).
        :type context: :py:class:`IMdl_execution_context`
        :param context:           The execution context can be used to pass options and to retrieve
                                     error and/or warning messages. Can be ``NULL``.
        :rtype: :py:class:`IDeserialized_function_name`
        :return: The deserialized function name, or ``NULL`` in case of errors, or
                                     if encoded names are disabled.

        |

        *Overload 2:*
        Deserializes the serialized name of a function or material definition (second overload).

        If the corresponding module has not been loaded, it will be loaded as a side effect. The
        method also performs an overload resolution on the deserialized function or material
        definition (as in
        #mi::neuraylib::IModule::get_function_overloads(const char*,const IArray*)const).

        See also: 'mi_mdl_serialized_names'

        :type transaction: :py:class:`ITransaction`
        :param transaction:       The transaction to be used.
        :type module_name: string
        :param module_name:       The serialized name of a module.
        :type function_name_without_module_name: string
        :param function_name_without_module_name:    The serialized name of a function or material
                                                        definition without the module name (starts with
                                                        ``"::"``, as returned by
                    #mi::neuraylib::ISerialized_function_name::get_function_name_without_module_name()).
        :type mdle_callback: :py:class:`IMdle_deserialization_callback`
        :param mdle_callback:     A callback to map the filename of MDLE modules. Ignored for
                                     non-MDLE modules. Can be ``NULL`` (which is treated like a callback
                                     implementing the identity transformation).
        :type context: :py:class:`IMdl_execution_context`
        :param context:           The execution context can be used to pass options and to retrieve
                                     error and/or warning messages. Can be ``NULL``.
        :rtype: :py:class:`IDeserialized_function_name`
        :return: The deserialized function name, or ``NULL`` in case of errors, or
                                     if encoded names are disabled.
        """
        return _pymdlsdk.IMdl_impexp_api_deserialize_function_name(self, *args)

    def deserialize_module_name(self, module_name, mdle_callback, context):
        r"""
        Deserializes the serialized name of a module.

        If the corresponding module has not been loaded, it will be loaded as a side effect. The
        method also performs an overload resolution on the deserialized function or material
        definition (as in
        #mi::neuraylib::IModule::get_function_overloads(const char*,const IArray*)const).

        See also: 'mi_mdl_serialized_names'

        :type module_name: string
        :param module_name:       The serialized name of a module.
        :type mdle_callback: :py:class:`IMdle_deserialization_callback`
        :param mdle_callback:     A callback to map the filename of MDLE modules. Ignored for
                                     non-MDLE modules. Can be ``NULL`` (which is treated like a callback
                                     implementing the identity transformation).
        :type context: :py:class:`IMdl_execution_context`
        :param context:           The execution context can be used to pass options and to retrieve
                                     error and/or warning messages. Can be ``NULL``.
        :rtype: :py:class:`IDeserialized_module_name`
        :return: The deserialized module name, or ``NULL`` in case of errors, or
                                     if encoded names are disabled.
        """
        return _pymdlsdk.IMdl_impexp_api_deserialize_module_name(self, module_name, mdle_callback, context)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IMdl_impexp_api_compare_iid(self, iid)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IMdl_impexp_api__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IMdl_impexp_api__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IMdl_impexp_api_get_iid(self)

# Register IMdl_impexp_api in _pymdlsdk:
_pymdlsdk.IMdl_impexp_api_swigregister(IMdl_impexp_api)

def IMdl_impexp_api_IID():
    return _pymdlsdk.IMdl_impexp_api_IID()

def IMdl_impexp_api__get_interface(iface):
    return _pymdlsdk.IMdl_impexp_api__get_interface(iface)

class IMessage(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IMessage_swiginit(self, _pymdlsdk.new_IMessage(*args))
    __swig_destroy__ = _pymdlsdk.delete_IMessage

    def __deref__(self):
        return _pymdlsdk.IMessage___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IMessage___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IMessage_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IMessage___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IMessage___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IMessage_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IMessage_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IMessage__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self):
        r""" Returns the kind of message."""
        return _pymdlsdk.IMessage_get_kind(self)

    def get_severity(self):
        r""" Returns the severity of the message."""
        return _pymdlsdk.IMessage_get_severity(self)

    def get_string(self):
        r""" Returns the message string."""
        return _pymdlsdk.IMessage_get_string(self)

    def get_code(self):
        r""" Returns a unique identifier for the message."""
        return _pymdlsdk.IMessage_get_code(self)

    def get_notes_count(self):
        r"""
        Returns the number of notes associated with the message

        Notes can be used to describe an error message further or add additional details.
        """
        return _pymdlsdk.IMessage_get_notes_count(self)

    def get_note(self, index):
        r""" Returns the note at index or ``NULL``, if no such index exists."""
        return _pymdlsdk.IMessage_get_note(self, index)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IMessage_compare_iid(self, iid)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IMessage__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IMessage__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IMessage_get_iid(self)

# Register IMessage in _pymdlsdk:
_pymdlsdk.IMessage_swigregister(IMessage)

def IMessage_IID():
    return _pymdlsdk.IMessage_IID()

def IMessage__get_interface(iface):
    return _pymdlsdk.IMessage__get_interface(iface)

class IModule(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IModule_swiginit(self, _pymdlsdk.new_IModule(*args))
    __swig_destroy__ = _pymdlsdk.delete_IModule

    def __deref__(self):
        return _pymdlsdk.IModule___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IModule___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IModule_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IModule___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IModule___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IModule_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IModule_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IModule__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_filename(self):
        r"""
        Returns the name of the MDL source file from which this module was created.

        :rtype: string
        :return: The full pathname of the source file from which this MDL module was created,
                            or ``NULL`` if no such file exists.
        """
        return _pymdlsdk.IModule_get_filename(self)

    def get_mdl_name(self):
        r"""
        Returns the MDL name of the module.

        Notes: The MDL name of the module is different from the name of the DB element.
              Use #mi::neuraylib::ITransaction::name_of() to obtain the name of the DB element.

        :rtype: string
        :return: The MDL name of the module.
        """
        return _pymdlsdk.IModule_get_mdl_name(self)

    def get_mdl_package_component_count(self):
        r""" Returns the number of package components in the MDL name."""
        return _pymdlsdk.IModule_get_mdl_package_component_count(self)

    def get_mdl_package_component_name(self, index):
        r"""
        Returns the name of a package component in the MDL name.

        :rtype: string
        :return: The ``index`` -th package component name, or ``NULL`` if ``index`` is out of
                            bounds.
        """
        return _pymdlsdk.IModule_get_mdl_package_component_name(self, index)

    def get_mdl_simple_name(self):
        r"""
        Returns the simple MDL name of the module.

        The simple name is the last component of the MDL name, i.e., without any packages and scope
        qualifiers.

        :rtype: string
        :return: The simple MDL name of the module.
        """
        return _pymdlsdk.IModule_get_mdl_simple_name(self)

    def get_mdl_version(self):
        r""" Returns the MDL version of this module."""
        return _pymdlsdk.IModule_get_mdl_version(self)

    def get_import_count(self):
        r""" Returns the number of modules imported by the module."""
        return _pymdlsdk.IModule_get_import_count(self)

    def get_import(self, index):
        r"""
        Returns the DB name of the imported module at ``index``.

        :type index: int
        :param index:    The index of the imported module.
        :rtype: string
        :return: The DB name of the imported module.
        """
        return _pymdlsdk.IModule_get_import(self, index)

    def get_types(self):
        r""" Returns the types exported by this module."""
        return _pymdlsdk.IModule_get_types(self)

    def get_constants(self):
        r""" Returns the constants exported by this module."""
        return _pymdlsdk.IModule_get_constants(self)

    def get_function_count(self):
        r""" Returns the number of function definitions exported by the module."""
        return _pymdlsdk.IModule_get_function_count(self)

    def get_function(self, index):
        r"""
        Returns the DB name of the function definition at ``index``.

        :type index: int
        :param index:    The index of the function definition.
        :rtype: string
        :return: The DB name of the function definition. The method may return ``NULL`` for
                            valid indices if the corresponding function definition has already been
                            removed from the DB.
        """
        return _pymdlsdk.IModule_get_function(self, index)

    def get_material_count(self):
        r""" Returns the number of material definitions exported by the module."""
        return _pymdlsdk.IModule_get_material_count(self)

    def get_material(self, index):
        r"""
        Returns the DB name of the material definition at ``index``.

        :type index: int
        :param index:    The index of the material definition.
        :rtype: string
        :return: The DB name of the material definition. The method may return ``NULL`` for
                            valid indices if the corresponding material definition has already been
                            removed from the DB.
        """
        return _pymdlsdk.IModule_get_material(self, index)

    def get_resources_count(self):
        r"""
        Returns the number of resources defined in the module.
        Resources defined in a module that is imported by this module are not included.
        """
        return _pymdlsdk.IModule_get_resources_count(self)

    def get_resource_type(self, index):
        r"""
        Returns the type of the resource at ``index``.

        :type index: int
        :param index:    The index of the resource.
        :rtype: :py:class:`IType_resource`
        :return: The type of the resource.
        """
        return _pymdlsdk.IModule_get_resource_type(self, index)

    def get_resource_mdl_file_path(self, index):
        r"""
        Returns the absolute MDL file path of the resource at ``index``.

        :type index: int
        :param index:    The index of the resource.
        :rtype: string
        :return: The absolute MDL file path of the resource.
        """
        return _pymdlsdk.IModule_get_resource_mdl_file_path(self, index)

    def get_resource_name(self, index):
        r"""
        Returns the database name of the resource at ``index``.

        :type index: int
        :param index:    The index of the resource.
        :rtype: string
        :return: The database name of the resource or ``NULL`` if
                            this resource could not be resolved.
        """
        return _pymdlsdk.IModule_get_resource_name(self, index)

    def get_annotation_definition_count(self):
        r""" Returns the number of annotations defined in the module."""
        return _pymdlsdk.IModule_get_annotation_definition_count(self)

    def get_annotation_definition(self, *args):
        r"""
        *Overload 1:*
        Returns the annotation definition at ``index``.

        :type index: int
        :param index:    The index of the annotation definition.
        :rtype: :py:class:`IAnnotation_definition`
        :return: The annotation definition or ``NULL`` if
                            ``index`` is out of range.

        |

        *Overload 2:*
        Returns the annotation definition of the given ``name``.

        :type name: string
        :param name:     The name of the annotation definition.
        :rtype: :py:class:`IAnnotation_definition`
        :return: The annotation definition or ``NULL`` if there is no such definition.
        """
        return _pymdlsdk.IModule_get_annotation_definition(self, *args)

    def get_annotations(self):
        r""" Returns the annotations of the module, or ``NULL`` if there are no such annotations."""
        return _pymdlsdk.IModule_get_annotations(self)

    def is_standard_module(self):
        r"""
        Indicates whether this module is a standard module.

        Examples for standard modules are ``"limits"``, ``"anno"``, ``"state"``, ``"math"``, ``"tex"``,
        ``"noise"``, and ``"df"``.
        """
        return _pymdlsdk.IModule_is_standard_module(self)

    def is_mdle_module(self):
        r""" Indicates whether this module results from an ``.mdle`` file."""
        return _pymdlsdk.IModule_is_mdle_module(self)

    def get_function_overloads(self, *args):
        r"""
        *Overload 1:*
        Returns overloads of a function or material definition.

        The method returns overloads of a function or material definition of this module, either
        all overloads or just the overloads matching a given set of arguments.

        :type name: string
        :param name:             The DB name of a function or material definition from this module
                                    *without* signature.
        :type arguments: :py:class:`IExpression_list`, optional
        :param arguments:        Optional arguments to select specific overload(s). If present, the
                                    method returns only the overloads of ``name`` whose signature
                                    matches the provided arguments, i.e., a call to
                                    #mi::neuraylib::IFunction_definition::create_function_call() or
                                    #mi::neuraylib::IMaterial_definition::create_material_instance()
                                    with these arguments would succeed.
        :rtype: :py:class:`IArray`
        :return: The DB names of overloads of the given function or material
                                    definition, or ``NULL`` if ``name`` is invalid.

        |

        *Overload 2:*
        Returns overloads of a function or material definition.

        The method returns the best-matching overloads of a function or material definition of this
        module, given a list of positional parameter types.

        Notes: This overload should only be used if no actual arguments are available. If arguments
              are available, consider using
              #get_function_overloads(const char*,const IExpression_list*)const instead.

        This method does not work for the function definitions with the following semantics:
              - #mi::neuraylib::IFunction_definition::DS_CAST,
              - #mi::neuraylib::IFunction_definition::DS_TERNARY,
              - #mi::neuraylib::IFunction_definition::DS_ARRAY_INDEX,
              - #mi::neuraylib::IFunction_definition::DS_INTRINSIC_DAG_ARRAY_CONSTRUCTOR,
              - #mi::neuraylib::IFunction_definition::DS_INTRINSIC_DAG_ARRAY_LENGTH. and
              - #mi::neuraylib::IFunction_definition::DS_INTRINSIC_DAG_FIELD_ACCESS.
              These are the 'mi_neuray_mdl_template_like_function_definitions' plus the field
              access function definitions.

        :type name: string
        :param name:             The DB name of a function or material definition from this module
                                    *without* signature.
        :type parameter_types: :py:class:`IArray`
        :param parameter_types:  A static or dynamic array with elements of type #mi::IString
                                    representing positional parameter type names as returned by
                                    #mi::neuraylib::IFunction_definition::get_mdl_parameter_type_name().
        :rtype: :py:class:`IArray`
        :return: The DB names of overloads of the given function or material
                                    definition, or ``NULL`` if ``name`` is invalid.
        """
        return _pymdlsdk.IModule_get_function_overloads(self, *args)

    def is_valid(self, context):
        r"""
        Returns true if all imports of the module are valid.

        :type context: :py:class:`IMdl_execution_context`
        :param context:     In case of failure, the execution context can be checked for error
                               messages. Can be ``NULL``.
        """
        return _pymdlsdk.IModule_is_valid(self, context)

    def reload(self, recursive, context):
        r"""
        Reload the module from disk.

        Notes: This function works for file-based modules, only.

        :type context: :py:class:`IMdl_execution_context`
        :param context:     In case of failure, the execution context can be checked for error
                               messages. Can be ``NULL``.
        :type recursive: boolean
        :param recursive:   If true, all imported file based modules are reloaded
                               prior to this one.
        :rtype: int
        :return: 
                          -     0: Success
                          -    -1: Reloading failed, check the context for details.
        """
        return _pymdlsdk.IModule_reload(self, recursive, context)

    def reload_from_string(self, module_source, recursive, context):
        r"""
        Reload the module from string.

        Notes: This function works for string/memory-based modules, only. Standard modules and
        the built-in If: MDL_SOURCE_RELEASE { module mdl::base }Else: modules  {``mdl::base`` and
        ``mdl::nvidia::distilling_support`` } cannot be reloaded.

        :type module_source: string
        :param module_source: The module source code.
        :type recursive: boolean
        :param recursive:     If true, all imported file based modules are reloaded
                                 prior to this one.
        :type context: :py:class:`IMdl_execution_context`
        :param context:       In case of failure, the execution context can be checked for error
                                 messages. Can be ``NULL``.
        :rtype: int
        :return: 
                          -     0: Success
                          -    -1: Reloading failed, check the context for details.
        """
        return _pymdlsdk.IModule_reload_from_string(self, module_source, recursive, context)

    def deprecated_get_function_overloads(self, name, param_sig):
        return _pymdlsdk.IModule_deprecated_get_function_overloads(self, name, param_sig)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IModule_compare_iid(self, iid)

    def get_element_type(self):
        r""" Indicates the actual scene element represented by interfaces derived from this interface."""
        return _pymdlsdk.IModule_get_element_type(self)

    def create_attribute(self, name, type):
        r"""
        Creates a new attribute ``name`` of the type ``type``.

        :type name: string
        :param name:         The name of the attribute. The name must not contain ``"["``, ``"]"``, or
                                ``"``."
        :type type: string
        :param type:         The type of the attribute. See 'mi_neuray_types' for a list of
                                supported attribute types.
        :rtype: :py:class:`IData`
        :return: A pointer to the created attribute, or ``NULL`` in case of failure.
                                Reasons for failure are:
                                - ``name`` or ``type`` is invalid,
                                - there is already an attribute with the name ``name``, or
                                - ``name`` is the name of a reserved attribute and ``type`` does not match
                                  the required type(s) of such an attribute.
        """
        return _pymdlsdk.IModule_create_attribute(self, name, type)

    def destroy_attribute(self, name):
        r"""
        Destroys the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute to destroy.
        :rtype: boolean
        :return: Returns ``true`` if the attribute has been successfully destroyed, and
                                ``false`` otherwise (there is no attribute with the name ``name)``.
        """
        return _pymdlsdk.IModule_destroy_attribute(self, name)

    def access_attribute(self, name):
        r"""
        Returns a const pointer to the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also access parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: :py:class:`IData`
        :return: A pointer to the attribute, or ``NULL`` if there is no attribute with
                                the name ``name``.
        """
        return _pymdlsdk.IModule_access_attribute(self, name)

    def edit_attribute(self, name):
        r"""
        Returns a mutable pointer to the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also access parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: :py:class:`IData`
        :return: A pointer to the attribute, or ``NULL`` if there is no attribute with
                                the name ``name``.
        """
        return _pymdlsdk.IModule_edit_attribute(self, name)

    def is_attribute(self, name):
        r"""
        Indicates existence of an attribute.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also checks for parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: boolean
        :return: ``true`` if the attribute set contains this attribute (and the attribute
                                contains the requested array element or struct member),
                                ``false`` otherwise
        """
        return _pymdlsdk.IModule_is_attribute(self, name)

    def get_attribute_type_name(self, name):
        r"""
        Returns the type of an attribute.

        See 'mi_neuray_types' for a list of supported attribute types.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also query parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: string
        :return: The type name of the attribute (or part thereof), or ``NULL`` if there
                                is no attribute with the name ``name``.

        Notes: The return value of this method is only valid until the next call of this method
              or any non-const methods on this instance.
        """
        return _pymdlsdk.IModule_get_attribute_type_name(self, name)

    def set_attribute_propagation(self, name, value):
        r"""
        Sets the propagation type of the attribute ``name``.

        :rtype: int
        :return: 
                                -  0: Success.
                                - -1: Invalid parameters (``NULL`` pointer or invalid enum value).
                                - -2: There is no attribute with name ``name``.
        """
        return _pymdlsdk.IModule_set_attribute_propagation(self, name, value)

    def get_attribute_propagation(self, name):
        r"""
        Returns the propagation type of the attribute ``name``.

        Notes: This method always returns #PROPAGATION_STANDARD in case of errors.
        """
        return _pymdlsdk.IModule_get_attribute_propagation(self, name)

    def enumerate_attributes(self, index):
        r"""
        Returns the name of the attribute indicated by ``index``.

        :type index: int
        :param index:        The index of the attribute.
        :rtype: string
        :return: The name of the attribute indicated by ``index``, or ``NULL`` if ``index``
                                is out of bounds.
        """
        return _pymdlsdk.IModule_enumerate_attributes(self, index)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IModule__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IModule__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IModule_get_iid(self)

# Register IModule in _pymdlsdk:
_pymdlsdk.IModule_swigregister(IModule)

def IModule_IID():
    return _pymdlsdk.IModule_IID()

def IModule__get_interface(iface):
    return _pymdlsdk.IModule__get_interface(iface)

class INeuray(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.INeuray_swiginit(self, _pymdlsdk.new_INeuray(*args))
    __swig_destroy__ = _pymdlsdk.delete_INeuray

    def __deref__(self):
        return _pymdlsdk.INeuray___deref__(self)

    def __ref__(self):
        return _pymdlsdk.INeuray___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.INeuray_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.INeuray___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.INeuray___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.INeuray_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.INeuray_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.INeuray__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    class Status(Enum):
        PRE_STARTING = _pymdlsdk._INeuray_PRE_STARTING
        STARTING = _pymdlsdk._INeuray_STARTING
        STARTED = _pymdlsdk._INeuray_STARTED
        SHUTTINGDOWN = _pymdlsdk._INeuray_SHUTTINGDOWN
        SHUTDOWN = _pymdlsdk._INeuray_SHUTDOWN
        FAILURE = _pymdlsdk._INeuray_FAILURE

    def get_api_component(self, type):
        iinterface = self._get_api_component(type.IID())
        if iinterface.is_valid_interface():
            typed_interface = iinterface.get_interface(type)
            iinterface = None
            return typed_interface
        else:
            return iinterface


    def get_status(self, *args):
        return INeuray.Status(self._get_status(*args))


    def get_interface_version(self):
        r"""
        Returns the interface version of the MDL SDK library.

        This number changes whenever the abstract interfaces of the MDL SDK APIchanges.
        """
        return _pymdlsdk.INeuray_get_interface_version(self)

    def get_version(self):
        r"""
        Returns the version of the MDL SDK library.

        This string contains the product version, build number, build date, and platform of the
        current library.
        """
        return _pymdlsdk.INeuray_get_version(self)

    def start(self, blocking=True):
        r"""
        Starts the operation of the MDL SDK library.

        All configuration which is marked to be done before the start of the library must be done
        before calling this function. When calling this function the MDL SDKwill start
        threads and start network operations etc. The MDL SDK librarymay not be ready for
        operation after the call returned if blocking mode is not used.

        If: IRAY_API {
        Notes: Starting the MDL SDK librarymultiple times, i.e., calling #shutdown() then calling
              #start() again, is not yet supported. This is true even if the first call to
              #start() fails.
        }

        :type blocking: boolean, optional
        :param blocking:If: MDL_SDK_API { Unused. The startup is always done in blocking mode.
                           }Else: Indicates whether the startup should be done in blocking mode. If {
                           ``true`` the method will not return before all initialization was done. If
                           ``false`` the method will return immediately and the startup is done in a
                           separate thread. The status of the startup sequence can be checked via
                           #get_status(). }
        :rtype: int
        :return: 
                               -  0: Success
                               - -1: Unspecified failure.
                               - -2: Authentication failure (challenge-response).
                               - -4: Provided license expired.
                               - -5: No professional GPU as required by the license in use was found.
                               - -6: Authentication failure (FLEXlm).
                               - -7: No NVIDIA VCA as required by the license in use was found.
        """
        return _pymdlsdk.INeuray_start(self, blocking)

    def shutdown(self, blocking=True):
        r"""
        Shuts down the library.

        For proper shutdown this may only be called after all transactions have been committed and
        all rendering is finished.

        You also need to release all interface pointers related to functionality obtained after
        startup before calling this method. In case you use the #mi::base::Handle class (or another
        handle class), you need to make sure that all such handles have been reset or destroyed.

        If: IRAY_API {
        Notes: Starting the MDL SDK librarymultiple times, i.e., calling #shutdown() then calling
              #start() again, is not yet supported. This is true even if the first call to
              #start() fails.
        }

        :type blocking: boolean, optional
        :param blocking:If: MDL_SDK_API { Unused. The shutdown is always done in blocking mode.
                           }Else: Indicates whether the shutdown should be done in blocking mode. If {
                           ``true`` the method will not return before shutdown has completed.
                           If ``false`` the method will return immediately and the shutdown is done
                           in a separate thread. The status of the shutdown sequence can be checked
                           via #get_status(). }
        :rtype: int
        :return: 0, in case of success, -1 in case of failure
        """
        return _pymdlsdk.INeuray_shutdown(self, blocking)

    def _get_status(self):
        r"""
        Returns the status of the library.

        :rtype: int
        :return: The status
        """
        return _pymdlsdk.INeuray__get_status(self)

    def _get_api_component(self, uuid):
        r"""
        Returns an API component from the MDL SDK API.

        See also: 'mi_neuray_api_components' for a list of built-in API components.

        See also: #register_api_component(), #unregister_api_component()

        :type uuid: :py:class:`Uuid`
        :param uuid:        The UUID under which the API components was registered. For built-in
                               API components this is the interface ID of the corresponding interface.
        :rtype: mi::base::IInterface
        :return: A pointer to the API component or ``NULL`` if the API component is not
                               supported or currently not available.
        """
        return _pymdlsdk.INeuray__get_api_component(self, uuid)

    def register_api_component(self, uuid, api_component):
        r"""
        Registers an API component with the MDL SDK API

        API components are a way for plugins to provide access to their functionality. The
        registration makes the API component available for subsequent calls of #get_api_component().

        :type uuid: :py:class:`Uuid`
        :param uuid:            The ID of the API component to register, e.g., the interface ID of
                                   the corresponding interface.
        :type api_component: mi::base::IInterface
        :param api_component:   The API component to register.
        :rtype: int
        :return: 
                                   -  0: Success.
                                   - -1: Invalid parameters (``NULL`` pointer).
                                   - -2: There is already an API component registered under the
                                         ID ``uuid``.
        """
        return _pymdlsdk.INeuray_register_api_component(self, uuid, api_component)

    def unregister_api_component(self, uuid):
        r"""
        Unregisters an API component with the MDL SDK API

        The API component will no longer be accessible via #get_api_component().

        :type uuid: :py:class:`Uuid`
        :param uuid:        The ID of the API component to unregister.
        :rtype: int
        :return: 
                               -  0: Success.
                               - -1: There is no API component registered under the ID ``uuid``.
        """
        return _pymdlsdk.INeuray_unregister_api_component(self, uuid)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.INeuray_compare_iid(self, iid)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.INeuray__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.INeuray__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.INeuray_get_iid(self)

# Register INeuray in _pymdlsdk:
_pymdlsdk.INeuray_swigregister(INeuray)

def INeuray_IID():
    return _pymdlsdk.INeuray_IID()

def INeuray__get_interface(iface):
    return _pymdlsdk.INeuray__get_interface(iface)

class IScene_element(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IScene_element_swiginit(self, _pymdlsdk.new_IScene_element(*args))
    __swig_destroy__ = _pymdlsdk.delete_IScene_element

    def __deref__(self):
        return _pymdlsdk.IScene_element___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IScene_element___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IScene_element_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IScene_element___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IScene_element___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IScene_element_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IScene_element_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IScene_element__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_element_type(self):
        r""" Indicates the actual scene element represented by interfaces derived from this interface."""
        return _pymdlsdk.IScene_element_get_element_type(self)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IScene_element_compare_iid(self, iid)

    def create_attribute(self, name, type):
        r"""
        Creates a new attribute ``name`` of the type ``type``.

        :type name: string
        :param name:         The name of the attribute. The name must not contain ``"["``, ``"]"``, or
                                ``"``."
        :type type: string
        :param type:         The type of the attribute. See 'mi_neuray_types' for a list of
                                supported attribute types.
        :rtype: :py:class:`IData`
        :return: A pointer to the created attribute, or ``NULL`` in case of failure.
                                Reasons for failure are:
                                - ``name`` or ``type`` is invalid,
                                - there is already an attribute with the name ``name``, or
                                - ``name`` is the name of a reserved attribute and ``type`` does not match
                                  the required type(s) of such an attribute.
        """
        return _pymdlsdk.IScene_element_create_attribute(self, name, type)

    def destroy_attribute(self, name):
        r"""
        Destroys the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute to destroy.
        :rtype: boolean
        :return: Returns ``true`` if the attribute has been successfully destroyed, and
                                ``false`` otherwise (there is no attribute with the name ``name)``.
        """
        return _pymdlsdk.IScene_element_destroy_attribute(self, name)

    def access_attribute(self, name):
        r"""
        Returns a const pointer to the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also access parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: :py:class:`IData`
        :return: A pointer to the attribute, or ``NULL`` if there is no attribute with
                                the name ``name``.
        """
        return _pymdlsdk.IScene_element_access_attribute(self, name)

    def edit_attribute(self, name):
        r"""
        Returns a mutable pointer to the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also access parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: :py:class:`IData`
        :return: A pointer to the attribute, or ``NULL`` if there is no attribute with
                                the name ``name``.
        """
        return _pymdlsdk.IScene_element_edit_attribute(self, name)

    def is_attribute(self, name):
        r"""
        Indicates existence of an attribute.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also checks for parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: boolean
        :return: ``true`` if the attribute set contains this attribute (and the attribute
                                contains the requested array element or struct member),
                                ``false`` otherwise
        """
        return _pymdlsdk.IScene_element_is_attribute(self, name)

    def get_attribute_type_name(self, name):
        r"""
        Returns the type of an attribute.

        See 'mi_neuray_types' for a list of supported attribute types.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also query parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: string
        :return: The type name of the attribute (or part thereof), or ``NULL`` if there
                                is no attribute with the name ``name``.

        Notes: The return value of this method is only valid until the next call of this method
              or any non-const methods on this instance.
        """
        return _pymdlsdk.IScene_element_get_attribute_type_name(self, name)

    def set_attribute_propagation(self, name, value):
        r"""
        Sets the propagation type of the attribute ``name``.

        :rtype: int
        :return: 
                                -  0: Success.
                                - -1: Invalid parameters (``NULL`` pointer or invalid enum value).
                                - -2: There is no attribute with name ``name``.
        """
        return _pymdlsdk.IScene_element_set_attribute_propagation(self, name, value)

    def get_attribute_propagation(self, name):
        r"""
        Returns the propagation type of the attribute ``name``.

        Notes: This method always returns #PROPAGATION_STANDARD in case of errors.
        """
        return _pymdlsdk.IScene_element_get_attribute_propagation(self, name)

    def enumerate_attributes(self, index):
        r"""
        Returns the name of the attribute indicated by ``index``.

        :type index: int
        :param index:        The index of the attribute.
        :rtype: string
        :return: The name of the attribute indicated by ``index``, or ``NULL`` if ``index``
                                is out of bounds.
        """
        return _pymdlsdk.IScene_element_enumerate_attributes(self, index)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IScene_element__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IScene_element__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IScene_element_get_iid(self)

# Register IScene_element in _pymdlsdk:
_pymdlsdk.IScene_element_swigregister(IScene_element)

def IScene_element_IID():
    return _pymdlsdk.IScene_element_IID()

def IScene_element__get_interface(iface):
    return _pymdlsdk.IScene_element__get_interface(iface)

class IScope(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IScope_swiginit(self, _pymdlsdk.new_IScope(*args))
    __swig_destroy__ = _pymdlsdk.delete_IScope

    def __deref__(self):
        return _pymdlsdk.IScope___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IScope___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IScope_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IScope___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IScope___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IScope_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IScope_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IScope__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def create_transaction(self):
        r"""
        Creates a new transaction associated with this scope.

        If: DICE_API { DiCE users should treat ``ITransaction`` as an opaque type. Instead, you should
        use #mi::neuraylib::IDice_transaction which is better suited for the needs of DiCE. To
        create such a DiCE transaction call the templated variant
        #mi::neuraylib::IScope::create_transaction<mi::neuraylib::IDice_transaction>(). }

        If: MDL_SDK_API { Notes: The MDL SDK currently supports only one transaction at a time. }

        :rtype: :py:class:`ITransaction`
        :return: A transaction associated with this scope.
        """
        return _pymdlsdk.IScope_create_transaction(self)

    def get_id(self):
        r"""
        Returns the ID of the scope.

        Can be used to retrieve the scope from the database later.

        :rtype: string
        :return: The ID of the scope.
        """
        return _pymdlsdk.IScope_get_id(self)

    def get_privacy_level(self):
        r"""
        Returns the privacy level of the scope.

        The global scope has privacy level 0, all other scopes have higher privacy levels. On each
        path from the global scope to any other scope in the scope tree the privacy levels are
        strictly increasing.

        :rtype: mi::Uint8
        :return: The privacy level of the scope.
        """
        return _pymdlsdk.IScope_get_privacy_level(self)

    def get_name(self):
        r"""
        Returns the name of the scope.

        :rtype: string
        :return: The name of the scope, or ``NULL`` if the scope has no name.
        """
        return _pymdlsdk.IScope_get_name(self)

    def get_parent(self):
        r"""
        Returns the parent scope.

        :rtype: :py:class:`IScope`
        :return: The parent scope or ``NULL`` if the scope is the global scope.
        """
        return _pymdlsdk.IScope_get_parent(self)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IScope_compare_iid(self, iid)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IScope__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IScope__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IScope_get_iid(self)

# Register IScope in _pymdlsdk:
_pymdlsdk.IScope_swigregister(IScope)

def IScope_IID():
    return _pymdlsdk.IScope_IID()

def IScope__get_interface(iface):
    return _pymdlsdk.IScope__get_interface(iface)

class ISerialized_function_name(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.ISerialized_function_name_swiginit(self, _pymdlsdk.new_ISerialized_function_name(*args))
    __swig_destroy__ = _pymdlsdk.delete_ISerialized_function_name

    def __deref__(self):
        return _pymdlsdk.ISerialized_function_name___deref__(self)

    def __ref__(self):
        return _pymdlsdk.ISerialized_function_name___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.ISerialized_function_name_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.ISerialized_function_name___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.ISerialized_function_name___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.ISerialized_function_name_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.ISerialized_function_name_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.ISerialized_function_name__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_function_name(self):
        r"""
        Returns the serialized function name.

        Useful for serialization schemes that support only a single string entity.

        Pass to the first overload of
        #mi::neuraylib::IMdl_impexp_api::deserialize_function_name() during deserialization.
        """
        return _pymdlsdk.ISerialized_function_name_get_function_name(self)

    def get_module_name(self):
        r"""
        Returns the serialized module name.

        Useful for serialization schemes that support two string entity entities.

        Pass to #mi::neuraylib::IMdl_impexp_api::deserialize_module_name() or the second overload
        of #mi::neuraylib::IMdl_impexp_api::deserialize_function_name() during deserialization.
        """
        return _pymdlsdk.ISerialized_function_name_get_module_name(self)

    def get_function_name_without_module_name(self):
        r"""
        Returns the serialized function name (without the module name).

        Useful for serialization schemes that support two string entity entities.

        Pass to the second overload
        of #mi::neuraylib::IMdl_impexp_api::deserialize_function_name() during deserialization.
        """
        return _pymdlsdk.ISerialized_function_name_get_function_name_without_module_name(self)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.ISerialized_function_name_compare_iid(self, iid)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.ISerialized_function_name__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.ISerialized_function_name__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.ISerialized_function_name_get_iid(self)

# Register ISerialized_function_name in _pymdlsdk:
_pymdlsdk.ISerialized_function_name_swigregister(ISerialized_function_name)

def ISerialized_function_name_IID():
    return _pymdlsdk.ISerialized_function_name_IID()

def ISerialized_function_name__get_interface(iface):
    return _pymdlsdk.ISerialized_function_name__get_interface(iface)

class ITransaction(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.ITransaction_swiginit(self, _pymdlsdk.new_ITransaction(*args))
    __swig_destroy__ = _pymdlsdk.delete_ITransaction

    def __deref__(self):
        return _pymdlsdk.ITransaction___deref__(self)

    def __ref__(self):
        return _pymdlsdk.ITransaction___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.ITransaction_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.ITransaction___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.ITransaction___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.ITransaction_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.ITransaction_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.ITransaction__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def access(self, *args):
        return  self._access(*args)

    def access_as(self, type, *args):
        iinterface = self._access(*args)
        if iinterface.is_valid_interface():
            typed_interface = iinterface.get_interface(type)
            iinterface = None
            return typed_interface
        else:
            return iinterface


    def edit(self, *args):
        return  self._edit(*args)

    def edit_as(self, type, *args):
        iinterface = self._edit(*args)
        if iinterface.is_valid_interface():
            typed_interface = iinterface.get_interface(type)
            iinterface = None
            return typed_interface
        else:
            return iinterface


    def commit(self):
        r"""
        Commits the transaction.

        Note that a commit() implicitly closes the transaction.
        A closed transaction does not allow any future operations and needs to be released.

        :rtype: int
        :return: 
                                -  0: Success.
                                - -1: Unspecified failure.
                                - -3: The transaction is not open.
        """
        return _pymdlsdk.ITransaction_commit(self)

    def abort(self):
        r"""
        If not: MDL_SDK_API {
        Aborts the transaction.

        Note that an abort() implicitly closes the transaction.
        A closed transaction does not allow any future operations and needs to be released.
        }Else:  { This operation is not supported.
        }
        """
        return _pymdlsdk.ITransaction_abort(self)

    def is_open(self):
        r"""
        Indicates whether the transaction is open.

        :rtype: boolean
        :return: ``true`` if the transaction is still open, or ``false`` if the transaction is
                      closed, i.e., it has been committed or aborted.
        """
        return _pymdlsdk.ITransaction_is_open(self)

    def create(self, type_name, argc=0, argv=0):
        r"""
        Creates an object of the type ``type_name``.

        Objects created with this method are typically If: IRAY_API { 'mi_neuray_types',
        'mi_neuray_scene_element' and 'mi_neuray_functors'. It is also possible to create
        instances of user-defined classes. }Else:  { and
        'mi_neuray_scene_element'. } Note that most types can also be created via the API
        component #mi::neuraylib::IFactory which does not require the context of a transaction.

        This method can not be used to create MDL definitions, material instances, or
        function calls. To create instances of
        #mi::neuraylib::IMaterial_instance and #mi::neuraylib::IFunction_call, use the
        methods #mi::neuraylib::IMaterial_definition::create_material_instance() or
        #mi::neuraylib::IFunction_definition::create_function_call(), respectively.

        The created object will be initialized in a manner dependent upon the passed type
        name. Each class has its own policy on initialization. So, one should not make any
        assumptions on the values of the various class members.

        :type type_name: string
        :param type_name:    The type name of the object to create. See 'mi_neuray_types' for
                                possible type names. In addition, 'mi_neuray_scene_element'
                            If: IRAY_API { and 'mi_neuray_functors' } can be created by
                            passing the name of the requested interfaces without namespace
                            qualifiers and the leading ``"I"``, e.g., ``"Image"`` for
                            #mi::neuraylib::IImage. If: IRAY_API { Names of user-defined classes are
                            also valid arguments. } Note that you can not create instances of
                            #mi::neuraylib::IAttribute_set or #mi::neuraylib::IScene_element, only
                            instances of the derived interfaces If: IRAY_API { (see also
                            #mi::neuraylib::IAttribute_container) } .
        :type argc: int, optional
        :param argc:         The number of elements in ``argv``. Passed to the constructor of factory
                                of the object to create.
        :type argv: mi::base::IInterface, optional
        :param argv:         The array of arguments passed to the constructor. Passed to the
                                constructor of factory of the object to create.
        :rtype: mi::base::IInterface
        :return: A pointer to the created object, or ``NULL`` if ``type_name`` is invalid
                                (``NULL`` pointer) or not a valid type name.
        """
        return _pymdlsdk.ITransaction_create(self, type_name, argc, argv)
    LOCAL_SCOPE = property(_pymdlsdk.ITransaction_LOCAL_SCOPE_get, doc=r"""
    Symbolic privacy level for the privacy level of the scope of this transaction.

    This symbolic constant can be passed to #store() and #copy() to indicate the privacy level
    of the scope of this transaction. It has the same affect as passing the result of
    #mi::neuraylib::IScope::get_privacy_level(), but is more convenient.
    """)

    def store(self, *args):
        r"""
        Stores the element ``db_element`` in the database under the name ``name`` and with the privacy
        level ``privacy``.

        After a successful store operation the passed interface pointer must no longer be used,
        except for releasing it. This is due to the fact that after a #store() the database
        retains ownership of the stored data. You can obtain the stored version from the database
        using the #access() or #edit() methods.

        Notes: **Overwriting vs editing of existing DB elements**

              While it is possible to overwrite existing DB elements, for performance reasons it is
              often better to edit the already existing DB element instead. Editing a DB element
              allows the DB to keep track of the type of changes which might help render modes to
              update their data structures more efficiently. When overwriting an existing DB element
              such information is not available and pessimistic assumptions have to be made which
              may result in lower performance.

        :type db_element: mi::base::IInterface
        :param db_element: The #mi::base::IInterface to store.
        :type name: string
        :param name:       The name under which to store ``db_element``. If there exists already a DB
                              element with that name then it will be overwritten If: IRAY_API { (but see
                          also return code -9 below) } .
        :type privacy: mi::Uint8, optional
        :param privacy:    The privacy level under which to store ``db_element`` (in the range from 0
                              to the privacy level of the scope of this transaction). In addition, the
                              constant #LOCAL_SCOPE can be used as a shortcut to indicate the privacy
                              level of the scope of this transaction without supplying the actual value
                              itself.
        :rtype: int
        :return: 
                   -  0: Success.
                   - -1: Unspecified failure.
                   - -2: Invalid parameters (``NULL`` pointer).
                   - -3: The transaction is not open.
                   - -4: ``db_element`` is not a DB element.
                   - -5: Invalid privacy level.
                   - -6: ``db_element`` has already been stored previously.
                   - -7: The element is to be stored in a transaction different from the one that was
                         used to create it.
                   - -8: The element is a user-defined class that has not been If: IRAY_API {
                     registered (see #mi::neuraylib::IExtension_api::register_class()). }Else:  {              registered. }

               - -9: There is already an element of name ``name`` and overwriting elements of that
                     type is not supported. This applies to elements of type
                     #mi::neuraylib::IModule, #mi::neuraylib::IMaterial_definition, and
                     #mi::neuraylib::IFunction_definition.
                     It also applies to elements of type #mi::neuraylib::IFunction_call
                     and #mi::neuraylib::IMaterial_instance that are used as defaults
                     in an #mi::neuraylib::IMaterial_definition or
                     #mi::neuraylib::IFunction_definition.
        """
        return _pymdlsdk.ITransaction_store(self, *args)

    def _access(self, name):
        r"""
        Retrieves an element from the database.

        The database searches for the most recent version of the named DB element visible for the
        current transaction. That version will be returned.

        :type name: string
        :param name:   The name of the element to retrieve.
        :rtype: mi::base::IInterface
        :return: The requested element from the database, or ``NULL`` if ``name`` is invalid, no
                          DB element with that name exists, or the transaction is already closed.
        """
        return _pymdlsdk.ITransaction__access(self, name)

    def _edit(self, name):
        r"""
        Retrieves an element from the database and returns it ready for editing.

        The database searches for the most recent version of the named DB element visible for the
        current transaction. It will then make a copy of that version and return the copy. The
        edited DB element will be committed to the database automatically, when the obtained
        interface is released. It is neither necessary nor possible to store the edited element
        manually in the database using the #store() method.

        :type name: string
        :param name:   The name of the element to retrieve.
        :rtype: mi::base::IInterface
        :return: The requested element from the database, or ``NULL`` if ``name`` is invalid, no
                          DB element with that name exists, or the transaction is already closed.
        """
        return _pymdlsdk.ITransaction__edit(self, name)

    def copy(self, source, target, privacy=0):
        r"""
        Creates a copy of a database element.

        Note that DB elements of type #mi::neuraylib::IModule, #mi::neuraylib::IMaterial_definition,
        and #mi::neuraylib::IFunction_definition can not be copied.

        :type source: string
        :param source:    The name of the element to be copied.
        :type target: string
        :param target:    The desired name of the copy.
        :type privacy: mi::Uint8, optional
        :param privacy:   The desired privacy level of the copy (in the range from
                             0 to the privacy level of the scope of this transaction). In addition, the
                             constant #LOCAL_SCOPE can be used as a shortcut to indicate the privacy
                             level of the scope of this transaction without supplying the actual value
                             itself.
        :rtype: int
        :return: 
                             -  0: Success.
                             - -2: Invalid parameters (``NULL`` pointer).
                             - -3: The transaction is not open.
                             - -4: There is no DB element named ``source`` visible in this transaction.
                             - -5: Invalid privacy level.
                             - -6: DB elements of this type cannot be copied.
                             - -9: There is already an element of name ``name`` and overwriting elements
                                   of that type is not supported. This applies to elements of type
                                   #mi::neuraylib::IModule, #mi::neuraylib::IMaterial_definition, and
                                   #mi::neuraylib::IFunction_definition.
                                   It also applies to elements of type #mi::neuraylib::IFunction_call
                                   and #mi::neuraylib::IMaterial_instance that are used as defaults
                                   in an #mi::neuraylib::IMaterial_definition or
                                   #mi::neuraylib::IFunction_definition.
        """
        return _pymdlsdk.ITransaction_copy(self, source, target, privacy)

    def remove(self, name, only_localized=False):
        r"""
        Removes the element with the name ``name`` from the database.

        Note that the element continues to be stored in the database as long as it is referenced by
        other elements. If it is no longer referenced, and the last transaction were it was
        referenced has been committed, it will be lazily removed by the garbage collection of the
        DB. There is no guarantee when this will happen.

        This implies that a #remove() call might actually remove an element that was stored later
        under the same name. This can potentially lead to invalid tag accesses. Those cases can be
        avoided by using #mi::neuraylib::IDatabase::garbage_collection() after a transaction was
        committed and before starting the next one to force garbage collection of all possible
        elements.

        :type name: string
        :param name:           The name of the element in the database to remove.
        :type only_localized: boolean, optional
        :param only_localized: If: MDL_SDK_API { Unused. }Else: If  {``true``, the element is only removed
                              if it exists in the scope of the transaction; parent scopes are not
                              considered. }
        :rtype: int
        :return: 
                                  -  0: Success.
                                  - -1: There is no DB element named ``name`` visible in this
                                        transaction (``only_localize`` is ``false)`` or there is no
                                        DB element named ``name`` in the scope of this transaction
                                        (``only_localized`` is ``true)``.
                                  - -2: Invalid parameters (``NULL`` pointer).
                                  - -3: The transaction is not open.
        """
        return _pymdlsdk.ITransaction_remove(self, name, only_localized)

    def name_of(self, db_element):
        r"""
        Returns the name of a database element.

        :type db_element: mi::base::IInterface
        :param db_element:   The DB element.
        :rtype: string
        :return: The name of the DB element, or ``NULL`` if ``db_element`` is invalid
                                (``NULL`` pointer), the object is not in the database, or the
                                transaction is already closed.
        """
        return _pymdlsdk.ITransaction_name_of(self, db_element)

    def get_time_stamp(self, *args):
        r"""
        *Overload 1:*
        Returns the time stamp describing the current "time".

        Notes: The time stamp is not related to time in the classical meaning. It rather relates to
              the current transaction and the number of database changes since the start of the
              transaction.

        The time stamp is only meaningful for the current MDL SDKinstance. It
              should not be put into external storage and re-used for different or later
              MDL SDKinstances.

        The return value of this method is only valid until the next call of this method
              (or one of its overloads) on this instance.

        See also: has_changed_since_time_stamp(), #get_time_stamp(const char*)const

        |

        *Overload 2:*
        Returns the time stamp of the last change of a database element.

        Notes: The time stamp is not related to time in the classical meaning. It rather relates to
              the transaction and the number of database changes since the start of the transaction
              when the database element was changed last.

        The time stamp is only meaningful for the current MDL SDKinstance. It
              should not be put into external storage and re-used for different or later
              MDL SDKinstances.

        The return value of this method is only valid until the next call of this method
              (or one of its overloads) on this instance.

        See also: has_changed_since_time_stamp(), #get_time_stamp()
        """
        return _pymdlsdk.ITransaction_get_time_stamp(self, *args)

    def has_changed_since_time_stamp(self, element, time_stamp):
        r"""
        Checks whether an element has been stored or changed in the database since a given time
        stamp.

        Notes: ``time_stamp`` should not stem from another concurrent transaction. Such changes will
              never be visible in this transaction, but the method might still return ``true``
              depending on the start order of the two transactions.

        In case of multiple overlapping transactions the returned answer may not list
              all changes due to the isolation of the transactions. If accurate results are
              required, transactions changing elements should be committed before transactions
              querying the journal for such changes are started.

        See also: #get_time_stamp(), #get_time_stamp(const char*)const

        :type element: string
        :param element:     The name of the element.
        :type time_stamp: string
        :param time_stamp:  The time stamp obtained from #get_time_stamp() or
                               #get_time_stamp(const char*)const.
        :rtype: boolean
        :return: ``true`` if the element has been stored or changed since the time stamp
                               (or if ``element`` or ``time_stamp`` is invalid, or there is no element
                               with that name), ``false`` otherwise.
        """
        return _pymdlsdk.ITransaction_has_changed_since_time_stamp(self, element, time_stamp)

    def get_id(self):
        r"""
        Returns the ID of this transaction.

        The transaction ID is of most use when debugging an application as the value returned allows
        one to correlate log messages and admin HTTP server output with the API actions.

        :rtype: string
        :return: The ID of the transaction.
        """
        return _pymdlsdk.ITransaction_get_id(self)

    def get_scope(self):
        r""" Returns the scope of this transaction."""
        return _pymdlsdk.ITransaction_get_scope(self)

    def list_elements(self, root_element, name_pattern=None, type_names=None):
        r"""
        Returns scene elements of a subgraph originating at a given scene element.

        The method iterates over all elements of a subgraph originating at the given scene element
        and returns their names. Optionally, the results can be filtered by a regular expression
        for the element names and a list for type names.

        Note that the runtime of the method depends on the number of elements in the subgraph. It
        might be expensive to call this method for large subgraphs.

        The returned scene elements are in such an order that all elements referenced by a given
        element are listed before that element ("before" in the sense of "using smaller array
        indices").

        :type root_element: string
        :param root_element:   The root of the subgraph to traverse.
        :type name_pattern: string, optional
        :param name_pattern:   An extended regular expression that acts as filter on the names of
                                  returned scene elements (see ['OGBS7])'. The regular expression
                                  is matched to *any* *part* of the scene element name, not just to
                                  the *entire* scene element name. The value ``NULL`` is handled as
                                  ``".*"``.
        :type type_names: :py:class:`IArray`, optional
        :param type_names:     A list of type names that acts as filter on the names of returned
                                  scene elements. Only scene elements with a matching type name pass
                                  the filter. The value ``NULL`` lets all scene elements pass the filter
                                  irrespective of their type name.
        :rtype: :py:class:`IArray`
        :return: A list of name of scene elements in the subgraph matching the given
                                  regular expression and type name filter, or ``NULL`` in case of
                                  an invalid root element name or an invalid regular expression.
        """
        return _pymdlsdk.ITransaction_list_elements(self, root_element, name_pattern, type_names)

    def get_privacy_level(self, name):
        r"""
        Returns the privacy level of the element with the name ``name``.

        :type name: string
        :param name:          The name of the element.
        :rtype: int
        :return: 
                                 - >= 0: Success. The privacy level of the element (in the range 0-255).
                                 -   -2: Invalid parameters (``NULL`` pointer).
                                 -   -3: The transaction is not open.
                                 -   -4: There is no DB element named ``name`` visible in this
                                         transaction.
        """
        return _pymdlsdk.ITransaction_get_privacy_level(self, name)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.ITransaction_compare_iid(self, iid)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.ITransaction__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.ITransaction__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.ITransaction_get_iid(self)

# Register ITransaction in _pymdlsdk:
_pymdlsdk.ITransaction_swigregister(ITransaction)

def ITransaction_IID():
    return _pymdlsdk.ITransaction_IID()

def ITransaction__get_interface(iface):
    return _pymdlsdk.ITransaction__get_interface(iface)

class IAnnotation(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IAnnotation_swiginit(self, _pymdlsdk.new_IAnnotation(*args))
    __swig_destroy__ = _pymdlsdk.delete_IAnnotation

    def __deref__(self):
        return _pymdlsdk.IAnnotation___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IAnnotation___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IAnnotation_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IAnnotation___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IAnnotation___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IAnnotation_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IAnnotation_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IAnnotation__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_name(self):
        r""" Returns the name of the annotation."""
        return _pymdlsdk.IAnnotation_get_name(self)

    def set_name(self, name):
        r""" Sets the name of the annotation."""
        return _pymdlsdk.IAnnotation_set_name(self, name)

    def get_arguments(self):
        r"""
        Returns the arguments of the annotation.

        The arguments of annotations are always constant expressions.
        """
        return _pymdlsdk.IAnnotation_get_arguments(self)

    def get_definition(self):
        r""" Returns the definition of this annotation."""
        return _pymdlsdk.IAnnotation_get_definition(self)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IAnnotation_compare_iid(self, iid)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IAnnotation__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IAnnotation__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IAnnotation_get_iid(self)

# Register IAnnotation in _pymdlsdk:
_pymdlsdk.IAnnotation_swigregister(IAnnotation)

def IAnnotation_IID():
    return _pymdlsdk.IAnnotation_IID()

def IAnnotation__get_interface(iface):
    return _pymdlsdk.IAnnotation__get_interface(iface)

class IAnnotation_block(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IAnnotation_block_swiginit(self, _pymdlsdk.new_IAnnotation_block(*args))
    __swig_destroy__ = _pymdlsdk.delete_IAnnotation_block

    def __deref__(self):
        return _pymdlsdk.IAnnotation_block___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IAnnotation_block___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IAnnotation_block_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IAnnotation_block___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IAnnotation_block___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IAnnotation_block_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IAnnotation_block_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IAnnotation_block__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_size(self):
        r""" Returns the number of annotations in this block."""
        return _pymdlsdk.IAnnotation_block_get_size(self)

    def get_annotation(self, index):
        r""" Returns the annotation for ``index``, or ``NULL`` if index is out of bounds."""
        return _pymdlsdk.IAnnotation_block_get_annotation(self, index)

    def set_annotation(self, index, annotation):
        r"""
        Sets an annotation block at a given index.

        :rtype: int
        :return: -  0: Success.
                      - -1: Invalid parameter (``NULL`` pointer).
                      - -2: ``index`` is out of bounds.
        """
        return _pymdlsdk.IAnnotation_block_set_annotation(self, index, annotation)

    def add_annotation(self, annotation):
        r"""
        Adds an annotation at the end of the annotation block.

        :rtype: int
        :return: -  0: Success.
                      - -1: Invalid parameter (``NULL`` pointer).
        """
        return _pymdlsdk.IAnnotation_block_add_annotation(self, annotation)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IAnnotation_block_compare_iid(self, iid)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IAnnotation_block__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IAnnotation_block__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IAnnotation_block_get_iid(self)

# Register IAnnotation_block in _pymdlsdk:
_pymdlsdk.IAnnotation_block_swigregister(IAnnotation_block)

def IAnnotation_block_IID():
    return _pymdlsdk.IAnnotation_block_IID()

def IAnnotation_block__get_interface(iface):
    return _pymdlsdk.IAnnotation_block__get_interface(iface)

class IAnnotation_definition(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IAnnotation_definition_swiginit(self, _pymdlsdk.new_IAnnotation_definition(*args))
    __swig_destroy__ = _pymdlsdk.delete_IAnnotation_definition

    def __deref__(self):
        return _pymdlsdk.IAnnotation_definition___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IAnnotation_definition___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IAnnotation_definition_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IAnnotation_definition___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IAnnotation_definition___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IAnnotation_definition_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IAnnotation_definition_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IAnnotation_definition__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_module(self):
        r"""
        Returns the DB name of the module containing this annotation definition.

        The type of the module is #mi::neuraylib::IModule.
        """
        return _pymdlsdk.IAnnotation_definition_get_module(self)

    def get_name(self):
        r""" Returns the MDL name of the annotation definition."""
        return _pymdlsdk.IAnnotation_definition_get_name(self)

    def get_mdl_module_name(self):
        r""" Returns the MDL name of the module containing this annotation definition."""
        return _pymdlsdk.IAnnotation_definition_get_mdl_module_name(self)

    def get_mdl_simple_name(self):
        r"""
        Returns the simple MDL name of the annotation definition.

        The simple name is the last component of the MDL name, i.e., without any packages and
        scope qualifiers, and without the parameter type names.

        :rtype: string
        :return: The simple MDL name of the annotation definition.
        """
        return _pymdlsdk.IAnnotation_definition_get_mdl_simple_name(self)

    def get_mdl_parameter_type_name(self, index):
        r"""
        Returns the type name of the parameter at ``index``.

        Notes: The type names provided here are substrings of the MDL name returned by #get_name().
              They are provided here such that parsing of the MDL name is not necessary. However,
              for most use cases it is strongly recommended to use #get_parameter_types() instead.

        :type index: int
        :param index:    The index of the parameter.
        :rtype: string
        :return: The type name of the parameter, or ``NULL`` if ``index`` is out of range.
        """
        return _pymdlsdk.IAnnotation_definition_get_mdl_parameter_type_name(self, index)

    def get_semantic(self):
        r""" Returns the semantic of this annotation definition."""
        return _pymdlsdk.IAnnotation_definition_get_semantic(self)

    def is_exported(self):
        r""" Indicates whether the annotation definition is exported by its module."""
        return _pymdlsdk.IAnnotation_definition_is_exported(self)

    def get_mdl_version(self, since, removed):
        r"""
        Returns the MDL version when this annotation definition was added and removed.

        :type since: int, out
        :param since:     The MDL version in which this annotation definition was added. If the
                                  annotation definition does not belong to the standard library, the
                                  MDL version of the corresponding module is returned.
        :type removed: int, out
        :param removed:   The MDL version in which this annotation definition was removed, or
                                  mi::neuraylib::MDL_VERSION_INVALID if the annotation has not been
                                  removed so far or does not belong to the standard library.
        """
        return _pymdlsdk.IAnnotation_definition_get_mdl_version(self, since, removed)

    def get_parameter_count(self):
        r""" Returns the parameter count of the annotation definition."""
        return _pymdlsdk.IAnnotation_definition_get_parameter_count(self)

    def get_parameter_name(self, index):
        r"""
        Returns the parameter name of the given index.

        :type index: int
        :param index:    The parameter index.
        :rtype: string
        :return: The name of the parameter or ``NULL`` if index
                            is out of range.
        """
        return _pymdlsdk.IAnnotation_definition_get_parameter_name(self, index)

    def get_parameter_index(self, name):
        r"""
        Returns the parameter index of the given name.

        :type name: string
        :param name:     The parameter name.
        :rtype: int
        :return: The index of the parameter or ``-1`` if there is no
                            parameter of that ``name``.
        """
        return _pymdlsdk.IAnnotation_definition_get_parameter_index(self, name)

    def get_parameter_types(self):
        r""" Returns the parameter types of the annotation definition."""
        return _pymdlsdk.IAnnotation_definition_get_parameter_types(self)

    def get_defaults(self):
        r""" Returns the parameter defaults of the annotation definition."""
        return _pymdlsdk.IAnnotation_definition_get_defaults(self)

    def get_annotations(self):
        r"""
        Returns the annotations of this definition or ``NULL`` if no
        annotations exist.
        """
        return _pymdlsdk.IAnnotation_definition_get_annotations(self)

    def create_annotation(self, arguments):
        r"""
        Creates an annotation.

        :type arguments: :py:class:`IExpression_list`
        :param arguments:    The arguments for new annotation.
        :rtype: :py:class:`IAnnotation`
        :return: The created annotation or ``NULL`` if one of the arguments
                                does not correspond to an actual parameter of the annotation or
                                is not a constant expression.
        """
        return _pymdlsdk.IAnnotation_definition_create_annotation(self, arguments)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IAnnotation_definition_compare_iid(self, iid)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IAnnotation_definition__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IAnnotation_definition__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IAnnotation_definition_get_iid(self)

# Register IAnnotation_definition in _pymdlsdk:
_pymdlsdk.IAnnotation_definition_swigregister(IAnnotation_definition)

def IAnnotation_definition_IID():
    return _pymdlsdk.IAnnotation_definition_IID()

def IAnnotation_definition__get_interface(iface):
    return _pymdlsdk.IAnnotation_definition__get_interface(iface)

class IAnnotation_list(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IAnnotation_list_swiginit(self, _pymdlsdk.new_IAnnotation_list(*args))
    __swig_destroy__ = _pymdlsdk.delete_IAnnotation_list

    def __deref__(self):
        return _pymdlsdk.IAnnotation_list___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IAnnotation_list___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IAnnotation_list_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IAnnotation_list___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IAnnotation_list___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IAnnotation_list_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IAnnotation_list_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IAnnotation_list__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_size(self):
        r""" Returns the number of elements."""
        return _pymdlsdk.IAnnotation_list_get_size(self)

    def get_index(self, name):
        r""" Returns the index for the given name, or -1 if there is no such block."""
        return _pymdlsdk.IAnnotation_list_get_index(self, name)

    def get_name(self, index):
        r""" Returns the name for the given index, or ``NULL`` if there is no such block."""
        return _pymdlsdk.IAnnotation_list_get_name(self, index)

    def get_annotation_block(self, *args):
        r"""
        *Overload 1:*
        Returns the annotation block for ``index``, or ``NULL`` if there is no such block.

        |

        *Overload 2:*
        Returns the annotation block for ``name``, or ``NULL`` if there is no such block.
        """
        return _pymdlsdk.IAnnotation_list_get_annotation_block(self, *args)

    def set_annotation_block(self, *args):
        r"""
        *Overload 1:*
        Sets an annotation block at a given index.

        :rtype: int
        :return: -  0: Success.
                      - -1: Invalid parameter (``NULL`` pointer).
                      - -2: ``index`` is out of bounds.

        |

        *Overload 2:*
        Sets an annotation block identified by name.

        :rtype: int
        :return: -  0: Success.
                      - -1: Invalid parameter (``NULL`` pointer).
                      - -2: There is no annotation block mapped to ``name`` in the list.
        """
        return _pymdlsdk.IAnnotation_list_set_annotation_block(self, *args)

    def add_annotation_block(self, name, block):
        r"""
        Adds an annotation block at the end of the list.

        :rtype: int
        :return: -  0: Success.
                      - -1: Invalid parameter (``NULL`` pointer).
                      - -2: There is already an annotation block mapped to ``name`` in the list.
        """
        return _pymdlsdk.IAnnotation_list_add_annotation_block(self, name, block)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IAnnotation_list_compare_iid(self, iid)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IAnnotation_list__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IAnnotation_list__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IAnnotation_list_get_iid(self)

# Register IAnnotation_list in _pymdlsdk:
_pymdlsdk.IAnnotation_list_swigregister(IAnnotation_list)

def IAnnotation_list_IID():
    return _pymdlsdk.IAnnotation_list_IID()

def IAnnotation_list__get_interface(iface):
    return _pymdlsdk.IAnnotation_list__get_interface(iface)

class IExpression(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IExpression_swiginit(self, _pymdlsdk.new_IExpression(*args))
    __swig_destroy__ = _pymdlsdk.delete_IExpression

    def __deref__(self):
        return _pymdlsdk.IExpression___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IExpression___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IExpression_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IExpression___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IExpression___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IExpression_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IExpression_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IExpression__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    class Kind(Enum) :
        EK_CONSTANT = _pymdlsdk._IExpression_EK_CONSTANT
        EK_CALL = _pymdlsdk._IExpression_EK_CALL
        EK_PARAMETER = _pymdlsdk._IExpression_EK_PARAMETER
        EK_DIRECT_CALL = _pymdlsdk._IExpression_EK_DIRECT_CALL
        EK_TEMPORARY = _pymdlsdk._IExpression_EK_TEMPORARY


    def get_kind(self, *args):
        return IExpression.Kind(self._get_kind(*args))


    def get_type(self, *args):
        return  self._get_type(*args)

    def get_type_as(self, type, *args):
        iinterface = self._get_type(*args)
        if iinterface.is_valid_interface():
            typed_interface = iinterface.get_interface(type)
            iinterface = None
            return typed_interface
        else:
            return iinterface


    def _get_kind(self):
        r""" Returns the kind of this expression."""
        return _pymdlsdk.IExpression__get_kind(self)

    def _get_type(self):
        r""" Returns the type of this expression."""
        return _pymdlsdk.IExpression__get_type(self)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IExpression_compare_iid(self, iid)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IExpression__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IExpression__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IExpression_get_iid(self)

# Register IExpression in _pymdlsdk:
_pymdlsdk.IExpression_swigregister(IExpression)

def IExpression_IID():
    return _pymdlsdk.IExpression_IID()

def IExpression__get_interface(iface):
    return _pymdlsdk.IExpression__get_interface(iface)

class IExpression_call(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IExpression_call_swiginit(self, _pymdlsdk.new_IExpression_call(*args))
    __swig_destroy__ = _pymdlsdk.delete_IExpression_call

    def __deref__(self):
        return _pymdlsdk.IExpression_call___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IExpression_call___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IExpression_call_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IExpression_call___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IExpression_call___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IExpression_call_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IExpression_call_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IExpression_call__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IExpression.Kind(self._get_kind(*args))


    def get_type(self, *args):
        return  self._get_type(*args)

    def get_type_as(self, type, *args):
        iinterface = self._get_type(*args)
        if iinterface.is_valid_interface():
            typed_interface = iinterface.get_interface(type)
            iinterface = None
            return typed_interface
        else:
            return iinterface


    def get_call(self):
        r""" Returns the DB name of the referenced function call or material instance."""
        return _pymdlsdk.IExpression_call_get_call(self)

    def set_call(self, name):
        r"""
        Sets the name of the referenced function call or material instance.

        :type name: string
        :param name:    The DB name of the function call or material instance.
        :rtype: int
        :return: 
                           -  0: Success.
                           - -1: Invalid parameter (``NULL`` pointer).
                           - -2: There is no DB element with that name.
                           - -3: The DB element has not the correct type.
                           - -4: The return type of the DB element does not match the type of this
                                 expression.
                           - -5: The material instance or function call referenced by "name" is
                                 a parameter default and therefore cannot be used in a call.
                           - -6: The material instance or function call referenced by "name" is
                                 invalid and therefore cannot be used in a call.
        """
        return _pymdlsdk.IExpression_call_set_call(self, name)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IExpression_call_compare_iid(self, iid)

    def _get_kind(self):
        r""" Returns the kind of this expression."""
        return _pymdlsdk.IExpression_call__get_kind(self)

    def _get_type(self):
        r""" Returns the type of this expression."""
        return _pymdlsdk.IExpression_call__get_type(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IExpression_call__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IExpression_call__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IExpression_call_get_iid(self)

# Register IExpression_call in _pymdlsdk:
_pymdlsdk.IExpression_call_swigregister(IExpression_call)

def IExpression_call_IID():
    return _pymdlsdk.IExpression_call_IID()

def IExpression_call__get_interface(iface):
    return _pymdlsdk.IExpression_call__get_interface(iface)

class IExpression_constant(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IExpression_constant_swiginit(self, _pymdlsdk.new_IExpression_constant(*args))
    __swig_destroy__ = _pymdlsdk.delete_IExpression_constant

    def __deref__(self):
        return _pymdlsdk.IExpression_constant___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IExpression_constant___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IExpression_constant_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IExpression_constant___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IExpression_constant___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IExpression_constant_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IExpression_constant_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IExpression_constant__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IExpression.Kind(self._get_kind(*args))


    def get_type(self, *args):
        return  self._get_type(*args)

    def get_type_as(self, type, *args):
        iinterface = self._get_type(*args)
        if iinterface.is_valid_interface():
            typed_interface = iinterface.get_interface(type)
            iinterface = None
            return typed_interface
        else:
            return iinterface


    def get_value(self, *args):
        return  self._get_value(*args)

    def get_value_as(self, type, *args):
        iinterface = self._get_value(*args)
        if iinterface.is_valid_interface():
            typed_interface = iinterface.get_interface(type)
            iinterface = None
            return typed_interface
        else:
            return iinterface


    def _get_value(self, *args):
        r"""
        *Overload 1:*
        Returns the value of the constant.

        |

        *Overload 2:*
        Returns the value of the constant.
        """
        return _pymdlsdk.IExpression_constant__get_value(self, *args)

    def set_value(self, value):
        r"""
        Sets the value of the constant.

        :rtype: int
        :return: 
                      -  0: Success.
                      - -1: Invalid parameter (``NULL`` pointer).
                      - -2: The type of ``value`` does not match the type of the constant.
        """
        return _pymdlsdk.IExpression_constant_set_value(self, value)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IExpression_constant_compare_iid(self, iid)

    def _get_kind(self):
        r""" Returns the kind of this expression."""
        return _pymdlsdk.IExpression_constant__get_kind(self)

    def _get_type(self):
        r""" Returns the type of this expression."""
        return _pymdlsdk.IExpression_constant__get_type(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IExpression_constant__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IExpression_constant__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IExpression_constant_get_iid(self)

# Register IExpression_constant in _pymdlsdk:
_pymdlsdk.IExpression_constant_swigregister(IExpression_constant)

def IExpression_constant_IID():
    return _pymdlsdk.IExpression_constant_IID()

def IExpression_constant__get_interface(iface):
    return _pymdlsdk.IExpression_constant__get_interface(iface)

class IExpression_direct_call(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IExpression_direct_call_swiginit(self, _pymdlsdk.new_IExpression_direct_call(*args))
    __swig_destroy__ = _pymdlsdk.delete_IExpression_direct_call

    def __deref__(self):
        return _pymdlsdk.IExpression_direct_call___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IExpression_direct_call___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IExpression_direct_call_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IExpression_direct_call___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IExpression_direct_call___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IExpression_direct_call_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IExpression_direct_call_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IExpression_direct_call__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IExpression.Kind(self._get_kind(*args))


    def get_type(self, *args):
        return  self._get_type(*args)

    def get_type_as(self, type, *args):
        iinterface = self._get_type(*args)
        if iinterface.is_valid_interface():
            typed_interface = iinterface.get_interface(type)
            iinterface = None
            return typed_interface
        else:
            return iinterface


    def get_definition(self):
        r""" Returns the DB name of the corresponding function or material definition."""
        return _pymdlsdk.IExpression_direct_call_get_definition(self)

    def get_arguments(self):
        r""" Returns the arguments of the direct call."""
        return _pymdlsdk.IExpression_direct_call_get_arguments(self)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IExpression_direct_call_compare_iid(self, iid)

    def _get_kind(self):
        r""" Returns the kind of this expression."""
        return _pymdlsdk.IExpression_direct_call__get_kind(self)

    def _get_type(self):
        r""" Returns the type of this expression."""
        return _pymdlsdk.IExpression_direct_call__get_type(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IExpression_direct_call__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IExpression_direct_call__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IExpression_direct_call_get_iid(self)

# Register IExpression_direct_call in _pymdlsdk:
_pymdlsdk.IExpression_direct_call_swigregister(IExpression_direct_call)

def IExpression_direct_call_IID():
    return _pymdlsdk.IExpression_direct_call_IID()

def IExpression_direct_call__get_interface(iface):
    return _pymdlsdk.IExpression_direct_call__get_interface(iface)

class IExpression_factory(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IExpression_factory_swiginit(self, _pymdlsdk.new_IExpression_factory(*args))
    __swig_destroy__ = _pymdlsdk.delete_IExpression_factory

    def __deref__(self):
        return _pymdlsdk.IExpression_factory___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IExpression_factory___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IExpression_factory_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IExpression_factory___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IExpression_factory___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IExpression_factory_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IExpression_factory_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IExpression_factory__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_value_factory(self):
        r""" Returns the value factory associated with this expression factory."""
        return _pymdlsdk.IExpression_factory_get_value_factory(self)

    def create_constant(self, value):
        r"""
        Creates a constant (const).

        :type value: :py:class:`IValue`
        :param value:        The value of the constant.
        :rtype: :py:class:`IExpression_constant`
        :return: The created constant.
        """
        return _pymdlsdk.IExpression_factory_create_constant(self, value)

    def create_call(self, name):
        r"""
        Creates a call.

        :type name: string
        :param name:         The DB name of the referenced function call or material instance.
        :rtype: :py:class:`IExpression_call`
        :return: The created call, or ``NULL`` in case of errors.
        """
        return _pymdlsdk.IExpression_factory_create_call(self, name)

    def create_parameter(self, type, index):
        r"""
        Creates a parameter reference.

        :type type: :py:class:`IType`
        :param type:         The type of the parameter.
        :type index: int
        :param index:        The index of the parameter.
        :rtype: :py:class:`IExpression_parameter`
        :return: The created parameter reference, or ``NULL`` in case of errors.
        """
        return _pymdlsdk.IExpression_factory_create_parameter(self, type, index)

    def create_direct_call_with_ret(self, name, arguments):
        r"""
        Creates a direct call.

        :type name: string
        :param name:         The DB name of the referenced function or material definition.
        :type arguments: :py:class:`IExpression_list`
        :param arguments:    The arguments of the created direct call.

                                Arguments for parameters without default are mandatory, otherwise
                                optional. The type of an argument must match the corresponding parameter
                                type. Any argument missing in ``arguments`` will be set to the default of
                                the corresponding parameter.

                                Note that the expressions in ``arguments`` are copied. Valid
                                subexpressions are constants, direct calls, and parameter references.
                                operation is a deep copy, e.g., DB elements referenced in call
                                expressions are also copied.

                                ``NULL`` is a valid argument which is handled like an empty expression
                                list.
        :type errors: int, out, optional
        :param errors:  An optional pointer to an #mi::Sint32 to which an error code will be
                                written. The error codes have the following meaning:
                                -  0: Success.
                                - -1: An argument for a non-existing parameter was provided in
                                      ``arguments``.
                                - -2: The type of an argument in ``arguments`` does not have the correct
                                      type.
                                - -3: A parameter that has no default was not provided with an argument
                                      value.
                                - -4: The function or material definition can not be instantiated
                                      because it is not exported.
                                - -5: A parameter type is uniform, but the corresponding argument has a
                                      varying return type.
                                - -6: An argument expression is not a constant, a direct call, nor a
                                      parameter.
                                - -7: Invalid parameters (``NULL`` pointer) or ``name`` is not a valid
                                      DB name of a function or material definition.
                                - -8: One of the parameter types is uniform, but the corresponding
                                      argument or default is a call expression and the return type of
                                      the called function or material definition is effectively varying
                                      since the function or material definition itself is varying.
                                - -9: The function or material definition is invalid due to a module
                                      reload.
        :rtype: :py:class:`IExpression_direct_call`
        :return: The created call, or ``NULL`` in case of errors.
        """
        return _pymdlsdk.IExpression_factory_create_direct_call_with_ret(self, name, arguments)

    def create_direct_call(self, name, arguments):
        r"""
        Creates a direct call.

        :type name: string
        :param name:         The DB name of the referenced function or material definition.
        :type arguments: :py:class:`IExpression_list`
        :param arguments:    The arguments of the created direct call.

                                Arguments for parameters without default are mandatory, otherwise
                                optional. The type of an argument must match the corresponding parameter
                                type. Any argument missing in ``arguments`` will be set to the default of
                                the corresponding parameter.

                                Note that the expressions in ``arguments`` are copied. Valid
                                subexpressions are constants, direct calls, and parameter references.
                                operation is a deep copy, e.g., DB elements referenced in call
                                expressions are also copied.

                                ``NULL`` is a valid argument which is handled like an empty expression
                                list.
        :param errors:  An optional pointer to an #mi::Sint32 to which an error code will be
                                written. The error codes have the following meaning:
                                -  0: Success.
                                - -1: An argument for a non-existing parameter was provided in
                                      ``arguments``.
                                - -2: The type of an argument in ``arguments`` does not have the correct
                                      type.
                                - -3: A parameter that has no default was not provided with an argument
                                      value.
                                - -4: The function or material definition can not be instantiated
                                      because it is not exported.
                                - -5: A parameter type is uniform, but the corresponding argument has a
                                      varying return type.
                                - -6: An argument expression is not a constant, a direct call, nor a
                                      parameter.
                                - -7: Invalid parameters (``NULL`` pointer) or ``name`` is not a valid
                                      DB name of a function or material definition.
                                - -8: One of the parameter types is uniform, but the corresponding
                                      argument or default is a call expression and the return type of
                                      the called function or material definition is effectively varying
                                      since the function or material definition itself is varying.
                                - -9: The function or material definition is invalid due to a module
                                      reload.
        :rtype: :py:class:`IExpression_direct_call`
        :return: The created call, or ``NULL`` in case of errors.
        """
        return _pymdlsdk.IExpression_factory_create_direct_call(self, name, arguments)

    def create_expression_list(self):
        r""" Creates a new expression list."""
        return _pymdlsdk.IExpression_factory_create_expression_list(self)

    def create_annotation(self, name, arguments):
        r"""
        Creates a new annotation.

        Returns ``NULL`` if one of the arguments is not a constant expression.
        """
        return _pymdlsdk.IExpression_factory_create_annotation(self, name, arguments)

    def create_annotation_block(self):
        r""" Creates a new annotation block."""
        return _pymdlsdk.IExpression_factory_create_annotation_block(self)

    def create_annotation_list(self):
        r""" Creates a new annotation list."""
        return _pymdlsdk.IExpression_factory_create_annotation_list(self)

    def clone(self, *args):
        r"""
        *Overload 1:*
        Clones the given expression.

        Note that referenced DB elements, e.g., resources in constant expressions, or function calls
        and material instances in call expressions, are not copied, but shared. Function calls and
        material instances that serve as default arguments, are copied, though.

        |

        *Overload 2:*
        Clones the given expression list.

        Note that referenced DB elements, e.g., resources in constant expressions, or function calls
        and material instances in call expressions, are not copied, but shared.
        """
        return _pymdlsdk.IExpression_factory_clone(self, *args)

    def compare(self, *args):
        r"""
        *Overload 1:*
        Compares two instances of #mi::neuraylib::IExpression.

        The comparison operator for instances of #mi::neuraylib::IExpression is defined as follows:
        - If ``lhs`` or ``rhs`` is ``NULL``, the result is the lexicographic comparison of
          the pointer addresses themselves.
        - Otherwise, the types of ``lhs`` and ``rhs`` are compared. If they are different, the result
          is determined by that comparison.
        - Next, the kind of the expressions are compared. If they are different, the result is
          determined by ``operator``< on the #mi::neuraylib::IExpression::Kind values.
        - Finally, the expressions are compared as follows:
          - For constants the results is defined by comparing their values.
          - For calls the result is defined by ``strcmp()`` on the names of the referenced DB
            elements.
          - For parameter and temporary references, the results is defined by ``operator``<() on the
            indices.

        :type lhs: :py:class:`IExpression`
        :param lhs:          The left-hand side operand for the comparison.
        :type rhs: :py:class:`IExpression`
        :param rhs:          The right-hand side operand for the comparison.
        :rtype: int
        :return: -1 if ``lhs`` < ``rhs``, 0 if ``lhs`` == ``rhs``, and +1 if ``lhs`` > ``rhs``.

        |

        *Overload 2:*
        Compares two instances of #mi::neuraylib::IExpression_list.

        The comparison operator for instances of #mi::neuraylib::IExpression_list is defined as
        follows:
        - If ``lhs`` or ``rhs`` is ``NULL``, the result is the lexicographic comparison of
          the pointer addresses themselves.
        - Next, the list sizes are compared using ``operator``<().
        - Next, the lists are traversed by increasing index and the names are compared using
          ``strcmp()``.
        - Finally, the list elements are enumerated by increasing index and the expressions are
          compared.

        :type lhs: :py:class:`IExpression_list`
        :param lhs:          The left-hand side operand for the comparison.
        :type rhs: :py:class:`IExpression_list`
        :param rhs:          The right-hand side operand for the comparison.
        :rtype: int
        :return: -1 if ``lhs`` < ``rhs``, 0 if ``lhs`` == ``rhs``, and +1 if ``lhs`` > ``rhs``.
        """
        return _pymdlsdk.IExpression_factory_compare(self, *args)

    def dump(self, *args):
        r"""
        *Overload 1:*
         Returns a textual representation of an expression.

         The parameter ``depth`` is only relevant for constants, where the argument is passed to
         #mi::neuraylib::IValue_factory::dump().

         Notes: The exact format of the textual representation is unspecified and might change in
               future releases. The textual representation is primarily meant as a debugging aid. Do
               *not* base application logic on it.

        |

        *Overload 2:*
         Returns a textual representation of an expression list.

         The representation of the expression list will contain line breaks. Subsequent lines have a
         suitable indentation. The assumed indentation level of the first line is specified by
        ``depth``.

         Notes: The exact format of the textual representation is unspecified and might change in
               future releases. The textual representation is primarily meant as a debugging aid. Do
               *not* base application logic on it.

        |

        *Overload 3:*
         Returns a textual representation of an expression list.

         The representation of the expression list will contain line breaks. Subsequent lines have a
         suitable indentation. The assumed indentation level of the first line is specified by
        ``depth``.

         Notes: The exact format of the textual representation is unspecified and might change in
               future releases. The textual representation is primarily meant as a debugging aid. Do
               *not* base application logic on it.

        |

        *Overload 4:*
         Returns a textual representation of an annotation.

         The representation of the annotation will contain line breaks. Subsequent lines have a
         suitable indentation. The assumed indentation level of the first line is specified by
        ``depth``.

         Notes: The exact format of the textual representation is unspecified and might change in
               future releases. The textual representation is primarily meant as a debugging aid. Do
               *not* base application logic on it.

        |

        *Overload 5:*
         Returns a textual representation of an annotation.

         The representation of the annotation will contain line breaks. Subsequent lines have a
         suitable indentation. The assumed indentation level of the first line is specified by
        ``depth``.

         Notes: The exact format of the textual representation is unspecified and might change in
               future releases. The textual representation is primarily meant as a debugging aid. Do
               *not* base application logic on it.

        |

        *Overload 6:*
         Returns a textual representation of an annotation block.

         The representation of the annotation block will contain line breaks. Subsequent lines have a
         suitable indentation. The assumed indentation level of the first line is specified by
        ``depth``.

         Notes: The exact format of the textual representation is unspecified and might change in
               future releases. The textual representation is primarily meant as a debugging aid. Do
               *not* base application logic on it.

        |

        *Overload 7:*
         Returns a textual representation of an annotation block.

         The representation of the annotation block will contain line breaks. Subsequent lines have a
         suitable indentation. The assumed indentation level of the first line is specified by
        ``depth``.

         Notes: The exact format of the textual representation is unspecified and might change in
               future releases. The textual representation is primarily meant as a debugging aid. Do
               *not* base application logic on it.

        |

        *Overload 8:*
         Returns a textual representation of an annotation list.

         The representation of the annotation list will contain line breaks. Subsequent lines have a
         suitable indentation. The assumed indentation level of the first line is specified by
        ``depth``.

         Notes: The exact format of the textual representation is unspecified and might change in
               future releases. The textual representation is primarily meant as a debugging aid. Do
               *not* base application logic on it.

        |

        *Overload 9:*
         Returns a textual representation of an annotation list.

         The representation of the annotation list will contain line breaks. Subsequent lines have a
         suitable indentation. The assumed indentation level of the first line is specified by
        ``depth``.

         Notes: The exact format of the textual representation is unspecified and might change in
               future releases. The textual representation is primarily meant as a debugging aid. Do
               *not* base application logic on it.
        """
        return _pymdlsdk.IExpression_factory_dump(self, *args)

    def create_cast_with_ret(self, src_expr, target_type, cast_db_name, force_cast):
        r"""
        Returns an expression which casts the source expression to the ``target_type``.

        This is a convenience function that creates an instance of the cast operator with
        the necessary arguments, stores it in the database and creates and returns an
        #mi::neuraylib::IExpression_call using the just created function. If ``force_cast`` is
        set to ``true``, the cast will always be inserted, even if the types match. If ``force_cast``
        is set to ``false``, the original expression is returned for identical types.
        If the type of ``src_expr`` and ``target_type`` are not compatible, ``NULL`` is returned.

        :type src_expr: :py:class:`IExpression`
        :param src_expr:     The expression whose type is supposed to be casted.
        :type target_type: :py:class:`IType`
        :param target_type:  The result type of the cast.
        :type cast_db_name: string
        :param cast_db_name: This name is used when storing the instance
                                of the cast-operator function into the database. If the name is already
                                taken by another DB element, this string will be used as the base for
                                generating a unique name. If NULL, a unique name is generated.
        :type force_cast: boolean
        :param force_cast:   If true, the cast will be created even if the types are
                                identical. Please note that a cast cannot be forced for
                                incompatible types.
        :type errors: int, optional
        :param errors:       An optional pointer to an #mi::Sint32 to which an error code will be
                                written. The error codes have the following meaning:
                                - 0: Success.
                                - 1: Invalid parameters (``NULL`` pointer).
                                - 2: The type of ``src_expr`` cannot be cast to ``target_type``.

        :rtype: :py:class:`IExpression`
        :return: The resulting expression or ``NULL`` in case of failure.
        """
        return _pymdlsdk.IExpression_factory_create_cast_with_ret(self, src_expr, target_type, cast_db_name, force_cast)

    def create_cast(self, src_expr, target_type, cast_db_name, force_cast):
        r"""
        Returns an expression which casts the source expression to the ``target_type``.

        This is a convenience function that creates an instance of the cast operator with
        the necessary arguments, stores it in the database and creates and returns an
        #mi::neuraylib::IExpression_call using the just created function. If ``force_cast`` is
        set to ``true``, the cast will always be inserted, even if the types match. If ``force_cast``
        is set to ``false``, the original expression is returned for identical types.
        If the type of ``src_expr`` and ``target_type`` are not compatible, ``NULL`` is returned.

        :type src_expr: :py:class:`IExpression`
        :param src_expr:     The expression whose type is supposed to be casted.
        :type target_type: :py:class:`IType`
        :param target_type:  The result type of the cast.
        :type cast_db_name: string
        :param cast_db_name: This name is used when storing the instance
                                of the cast-operator function into the database. If the name is already
                                taken by another DB element, this string will be used as the base for
                                generating a unique name. If NULL, a unique name is generated.
        :type force_cast: boolean
        :param force_cast:   If true, the cast will be created even if the types are
                                identical. Please note that a cast cannot be forced for
                                incompatible types.
        :param errors:       An optional pointer to an #mi::Sint32 to which an error code will be
                                written. The error codes have the following meaning:
                                - 0: Success.
                                - 1: Invalid parameters (``NULL`` pointer).
                                - 2: The type of ``src_expr`` cannot be cast to ``target_type``.

        :rtype: :py:class:`IExpression`
        :return: The resulting expression or ``NULL`` in case of failure.
        """
        return _pymdlsdk.IExpression_factory_create_cast(self, src_expr, target_type, cast_db_name, force_cast)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IExpression_factory_compare_iid(self, iid)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IExpression_factory__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IExpression_factory__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IExpression_factory_get_iid(self)

# Register IExpression_factory in _pymdlsdk:
_pymdlsdk.IExpression_factory_swigregister(IExpression_factory)

def IExpression_factory_IID():
    return _pymdlsdk.IExpression_factory_IID()

def IExpression_factory__get_interface(iface):
    return _pymdlsdk.IExpression_factory__get_interface(iface)

class IExpression_list(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IExpression_list_swiginit(self, _pymdlsdk.new_IExpression_list(*args))
    __swig_destroy__ = _pymdlsdk.delete_IExpression_list

    def __deref__(self):
        return _pymdlsdk.IExpression_list___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IExpression_list___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IExpression_list_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IExpression_list___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IExpression_list___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IExpression_list_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IExpression_list_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IExpression_list__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_expression(self, *args):
        return  self._get_expression(*args)

    def get_expression_as(self, type, *args):
        iinterface = self._get_expression(*args)
        if iinterface.is_valid_interface():
            typed_interface = iinterface.get_interface(type)
            iinterface = None
            return typed_interface
        else:
            return iinterface


    def get_size(self):
        r""" Returns the number of elements."""
        return _pymdlsdk.IExpression_list_get_size(self)

    def get_index(self, name):
        r""" Returns the index for the given name, or -1 if there is no such expression."""
        return _pymdlsdk.IExpression_list_get_index(self, name)

    def get_name(self, index):
        r""" Returns the name for the given index, or ``NULL`` if there is no such expression."""
        return _pymdlsdk.IExpression_list_get_name(self, index)

    def _get_expression(self, *args):
        r"""
        *Overload 1:*
        Returns the expression for ``index``, or ``NULL`` if there is no such expression.

        |

        *Overload 2:*
        Returns the expression for ``name``, or ``NULL`` if there is no such expression.
        """
        return _pymdlsdk.IExpression_list__get_expression(self, *args)

    def set_expression(self, *args):
        r"""
        *Overload 1:*
        Sets an expression at a given index.

        :rtype: int
        :return: -  0: Success.
                      - -1: Invalid parameter (``NULL`` pointer).
                      - -2: ``index`` is out of bounds.

        |

        *Overload 2:*
        Sets an expression identified by name.

        :rtype: int
        :return: -  0: Success.
                      - -1: Invalid parameter (``NULL`` pointer).
                      - -2: There is no expression mapped to ``name`` in the list.
        """
        return _pymdlsdk.IExpression_list_set_expression(self, *args)

    def add_expression(self, name, expression):
        r"""
        Adds an expression at the end of the list.

        :rtype: int
        :return: -  0: Success.
                      - -1: Invalid parameter (``NULL`` pointer).
                      - -2: There is already an expression mapped to ``name`` in the list.
        """
        return _pymdlsdk.IExpression_list_add_expression(self, name, expression)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IExpression_list_compare_iid(self, iid)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IExpression_list__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IExpression_list__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IExpression_list_get_iid(self)

# Register IExpression_list in _pymdlsdk:
_pymdlsdk.IExpression_list_swigregister(IExpression_list)

def IExpression_list_IID():
    return _pymdlsdk.IExpression_list_IID()

def IExpression_list__get_interface(iface):
    return _pymdlsdk.IExpression_list__get_interface(iface)

class IExpression_parameter(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IExpression_parameter_swiginit(self, _pymdlsdk.new_IExpression_parameter(*args))
    __swig_destroy__ = _pymdlsdk.delete_IExpression_parameter

    def __deref__(self):
        return _pymdlsdk.IExpression_parameter___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IExpression_parameter___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IExpression_parameter_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IExpression_parameter___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IExpression_parameter___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IExpression_parameter_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IExpression_parameter_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IExpression_parameter__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IExpression.Kind(self._get_kind(*args))


    def get_type(self, *args):
        return  self._get_type(*args)

    def get_type_as(self, type, *args):
        iinterface = self._get_type(*args)
        if iinterface.is_valid_interface():
            typed_interface = iinterface.get_interface(type)
            iinterface = None
            return typed_interface
        else:
            return iinterface


    def get_index(self):
        r""" Returns the index of the referenced parameter."""
        return _pymdlsdk.IExpression_parameter_get_index(self)

    def set_index(self, index):
        r""" Sets the index of the referenced parameter."""
        return _pymdlsdk.IExpression_parameter_set_index(self, index)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IExpression_parameter_compare_iid(self, iid)

    def _get_kind(self):
        r""" Returns the kind of this expression."""
        return _pymdlsdk.IExpression_parameter__get_kind(self)

    def _get_type(self):
        r""" Returns the type of this expression."""
        return _pymdlsdk.IExpression_parameter__get_type(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IExpression_parameter__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IExpression_parameter__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IExpression_parameter_get_iid(self)

# Register IExpression_parameter in _pymdlsdk:
_pymdlsdk.IExpression_parameter_swigregister(IExpression_parameter)

def IExpression_parameter_IID():
    return _pymdlsdk.IExpression_parameter_IID()

def IExpression_parameter__get_interface(iface):
    return _pymdlsdk.IExpression_parameter__get_interface(iface)

class IExpression_temporary(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IExpression_temporary_swiginit(self, _pymdlsdk.new_IExpression_temporary(*args))
    __swig_destroy__ = _pymdlsdk.delete_IExpression_temporary

    def __deref__(self):
        return _pymdlsdk.IExpression_temporary___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IExpression_temporary___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IExpression_temporary_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IExpression_temporary___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IExpression_temporary___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IExpression_temporary_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IExpression_temporary_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IExpression_temporary__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IExpression.Kind(self._get_kind(*args))


    def get_type(self, *args):
        return  self._get_type(*args)

    def get_type_as(self, type, *args):
        iinterface = self._get_type(*args)
        if iinterface.is_valid_interface():
            typed_interface = iinterface.get_interface(type)
            iinterface = None
            return typed_interface
        else:
            return iinterface


    def get_index(self):
        r""" Returns the index of the referenced temporary."""
        return _pymdlsdk.IExpression_temporary_get_index(self)

    def set_index(self, index):
        r""" Sets the index of the referenced temporary."""
        return _pymdlsdk.IExpression_temporary_set_index(self, index)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IExpression_temporary_compare_iid(self, iid)

    def _get_kind(self):
        r""" Returns the kind of this expression."""
        return _pymdlsdk.IExpression_temporary__get_kind(self)

    def _get_type(self):
        r""" Returns the type of this expression."""
        return _pymdlsdk.IExpression_temporary__get_type(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IExpression_temporary__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IExpression_temporary__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IExpression_temporary_get_iid(self)

# Register IExpression_temporary in _pymdlsdk:
_pymdlsdk.IExpression_temporary_swigregister(IExpression_temporary)

def IExpression_temporary_IID():
    return _pymdlsdk.IExpression_temporary_IID()

def IExpression_temporary__get_interface(iface):
    return _pymdlsdk.IExpression_temporary__get_interface(iface)

class IFunction_call(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IFunction_call_swiginit(self, _pymdlsdk.new_IFunction_call(*args))
    __swig_destroy__ = _pymdlsdk.delete_IFunction_call

    def __deref__(self):
        return _pymdlsdk.IFunction_call___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IFunction_call___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IFunction_call_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IFunction_call___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IFunction_call___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IFunction_call_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IFunction_call_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IFunction_call__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_function_definition(self):
        r"""
        Returns the DB name of the corresponding function definition.

        The type of the function definition is #mi::neuraylib::IFunction_definition.

        Notes: The DB name of the function definition is different from its MDL name (see
              #get_mdl_function_definition()).
        """
        return _pymdlsdk.IFunction_call_get_function_definition(self)

    def get_mdl_function_definition(self):
        r"""
        Returns the MDL name of the corresponding function definition.

        Notes: The MDL name of the function definition is different from the name of the DB element
              (see #get_function_definition()).
        """
        return _pymdlsdk.IFunction_call_get_mdl_function_definition(self)

    def is_material(self):
        r"""
        Indicates whether the call represents a material instance.

        If materials-are-functions is enabled, then this method returns ``true`` iff
        #mi::neuraylib::IFunction_call::get_interface<mi::neuraylib::IMaterial_instance>()
        succeeds. Otherwise, this method always returns ``false``.

        See also: #mi::neuraylib::IMdl_configuration::set_materials_are_functions().
        """
        return _pymdlsdk.IFunction_call_is_material(self)

    def is_array_constructor(self):
        r"""
        Indicates whether this call is an instance of the array constructor.

        See also: 'mi_neuray_mdl_arrays'
        """
        return _pymdlsdk.IFunction_call_is_array_constructor(self)

    def get_return_type(self):
        r""" Returns the return type of the corresponding function definition."""
        return _pymdlsdk.IFunction_call_get_return_type(self)

    def get_parameter_count(self):
        r""" Returns the number of parameters."""
        return _pymdlsdk.IFunction_call_get_parameter_count(self)

    def get_parameter_name(self, index):
        r"""
        Returns the name of the parameter at ``index``.

        :type index: int
        :param index:        The index of the parameter.
        :rtype: string
        :return: The name of the parameter, or ``NULL`` if ``index`` is out of range.
        """
        return _pymdlsdk.IFunction_call_get_parameter_name(self, index)

    def get_parameter_index(self, name):
        r"""
        Returns the index position of a parameter.

        :type name: string
        :param name:         The name of the parameter.
        :rtype: int
        :return: The index of the parameter, or -1 if ``name`` is invalid.
        """
        return _pymdlsdk.IFunction_call_get_parameter_index(self, name)

    def get_parameter_types(self):
        r""" Returns the types of all parameters."""
        return _pymdlsdk.IFunction_call_get_parameter_types(self)

    def get_arguments(self):
        r""" Returns all arguments."""
        return _pymdlsdk.IFunction_call_get_arguments(self)

    def set_arguments(self, arguments):
        r"""
        Sets multiple arguments.

        :type arguments: :py:class:`IExpression_list`
        :param arguments:    The arguments. Note that the expressions are copied. This copy operation
                                is a shallow copy, e.g., DB elements referenced in call expressions are
                                *not* copied.
        :rtype: int
        :return: 
                                -  0: Success.
                                - -1: Invalid parameters (``NULL`` pointer).
                                - -2: One of the parameters in ``arguments`` does not exist.
                                - -3: One of the argument types does not match the corresponding
                                      parameter type.
                                - -4: The function call is immutable (because it appears in a default of
                                      a function or material definition).
                                - -5: One of the parameter types is uniform, but the corresponding
                                      argument type is varying.
                                - -6: One of the arguments is not a constant nor a call.
                                - -7: One of the arguments contains references to DB elements in a scope
                                      that is more private scope than the scope of this material
                                      instance.
                                - -8: One of the parameter types is uniform, but the corresponding
                                      argument is a call expression and the return type of the
                                      called function definition is effectively varying since the
                                      function definition itself is varying.
        """
        return _pymdlsdk.IFunction_call_set_arguments(self, arguments)

    def set_argument(self, *args):
        r"""
        *Overload 1:*
        Sets the argument at ``index``.

        :type index: int
        :param index:        The index of the argument.
        :type argument: :py:class:`IExpression`
        :param argument:     The argument. Note that the expression is copied. This copy operation
                                is a shallow copy, e.g., DB elements referenced in call expressions are
                                *not* copied.
        :rtype: int
        :return: 
                                -  0: Success.
                                - -1: Invalid parameters (``NULL`` pointer).
                                - -2: Parameter ``index`` does not exist.
                                - -3: The argument type does not match the parameter type.
                                - -4: The function call is immutable (because it appears in a default of
                                      a function or material definition).
                                - -5: The parameter type is uniform, but the argument type is varying.
                                - -6: The argument expression is not a constant nor a call.
                                - -7: The argument contains references to DB elements in a scope that is
                                      more private scope than the scope of this material instance.
                                - -8: The parameter types is uniform, but the argument is a call
                                      expression and the return type of the called function definition
                                      is effectively varying since the function definition itself is
                                      varying.

        |

        *Overload 2:*
        Sets an argument identified by name.

        :type name: string
        :param name:         The name of the parameter.
        :type argument: :py:class:`IExpression`
        :param argument:     The argument. Note that the expression is copied. This copy operation
                                is a shallow copy, e.g., DB elements referenced in call expressions are
                                *not* copied.
        :rtype: int
        :return: 
                                -  0: Success.
                                - -1: Invalid parameters (``NULL`` pointer).
                                - -2: Parameter ``name`` does not exist.
                                - -3: The argument type does not match the parameter type.
                                - -4: The function call is immutable (because it appears in a default of
                                      a function or material definition).
                                - -5: The parameter type is uniform, but the argument type is varying.
                                - -6: The argument expression is not a constant nor a call.
                                - -7: The argument contains references to DB elements in a scope that is
                                      more private scope than the scope of this material instance.
                                - -8: The parameter types is uniform, but the argument is a call
                                      expression and the return type of the called function definition
                                      is effectively varying since the function definition itself is
                                      varying.
        """
        return _pymdlsdk.IFunction_call_set_argument(self, *args)

    def is_default(self):
        r"""
        Indicates, if this function call acts as a default argument of a material or function
        definition.

        Defaults are immutable, their arguments cannot be changed and they cannot be used
        in call expressions.

        :rtype: boolean
        :return: true, if this function call is a default, false otherwise.
        """
        return _pymdlsdk.IFunction_call_is_default(self)

    def is_valid(self, context):
        r"""
        Returns ``true`` if this function call and all its arguments point to valid
        material and function definitions, ``false`` otherwise.

        Material and function definitions can become invalid due to a module reload.

        See also: #mi::neuraylib::IModule::reload(), #mi::neuraylib::IMaterial_instance::repair()

        :type context: :py:class:`IMdl_execution_context`
        :param context:  Execution context that can be queried for error messages
                            after the operation has finished. Can be ``NULL``.
        :rtype: boolean
        :return: 
                 - ``true``:  The instance is valid.
                 - ``false``: The instance is invalid.
        """
        return _pymdlsdk.IFunction_call_is_valid(self, context)

    def repair(self, flags, context):
        r"""
        Attempts to repair an invalid function call.

        :type flags: int
        :param flags:    Repair options, see #mi::neuraylib::Mdl_repair_options.
        :type context: :py:class:`IMdl_execution_context`
        :param context:  Execution context that can be queried for error messages
                            after the operation has finished. Can be ``NULL``.
        :rtype: int
        :return: 
                -   0:   Success.
                -  -1:   Repair failed. Check the ``context`` for details.
        """
        return _pymdlsdk.IFunction_call_repair(self, flags, context)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IFunction_call_compare_iid(self, iid)

    def get_element_type(self):
        r""" Indicates the actual scene element represented by interfaces derived from this interface."""
        return _pymdlsdk.IFunction_call_get_element_type(self)

    def create_attribute(self, name, type):
        r"""
        Creates a new attribute ``name`` of the type ``type``.

        :type name: string
        :param name:         The name of the attribute. The name must not contain ``"["``, ``"]"``, or
                                ``"``."
        :type type: string
        :param type:         The type of the attribute. See 'mi_neuray_types' for a list of
                                supported attribute types.
        :rtype: :py:class:`IData`
        :return: A pointer to the created attribute, or ``NULL`` in case of failure.
                                Reasons for failure are:
                                - ``name`` or ``type`` is invalid,
                                - there is already an attribute with the name ``name``, or
                                - ``name`` is the name of a reserved attribute and ``type`` does not match
                                  the required type(s) of such an attribute.
        """
        return _pymdlsdk.IFunction_call_create_attribute(self, name, type)

    def destroy_attribute(self, name):
        r"""
        Destroys the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute to destroy.
        :rtype: boolean
        :return: Returns ``true`` if the attribute has been successfully destroyed, and
                                ``false`` otherwise (there is no attribute with the name ``name)``.
        """
        return _pymdlsdk.IFunction_call_destroy_attribute(self, name)

    def access_attribute(self, name):
        r"""
        Returns a const pointer to the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also access parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: :py:class:`IData`
        :return: A pointer to the attribute, or ``NULL`` if there is no attribute with
                                the name ``name``.
        """
        return _pymdlsdk.IFunction_call_access_attribute(self, name)

    def edit_attribute(self, name):
        r"""
        Returns a mutable pointer to the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also access parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: :py:class:`IData`
        :return: A pointer to the attribute, or ``NULL`` if there is no attribute with
                                the name ``name``.
        """
        return _pymdlsdk.IFunction_call_edit_attribute(self, name)

    def is_attribute(self, name):
        r"""
        Indicates existence of an attribute.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also checks for parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: boolean
        :return: ``true`` if the attribute set contains this attribute (and the attribute
                                contains the requested array element or struct member),
                                ``false`` otherwise
        """
        return _pymdlsdk.IFunction_call_is_attribute(self, name)

    def get_attribute_type_name(self, name):
        r"""
        Returns the type of an attribute.

        See 'mi_neuray_types' for a list of supported attribute types.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also query parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: string
        :return: The type name of the attribute (or part thereof), or ``NULL`` if there
                                is no attribute with the name ``name``.

        Notes: The return value of this method is only valid until the next call of this method
              or any non-const methods on this instance.
        """
        return _pymdlsdk.IFunction_call_get_attribute_type_name(self, name)

    def set_attribute_propagation(self, name, value):
        r"""
        Sets the propagation type of the attribute ``name``.

        :rtype: int
        :return: 
                                -  0: Success.
                                - -1: Invalid parameters (``NULL`` pointer or invalid enum value).
                                - -2: There is no attribute with name ``name``.
        """
        return _pymdlsdk.IFunction_call_set_attribute_propagation(self, name, value)

    def get_attribute_propagation(self, name):
        r"""
        Returns the propagation type of the attribute ``name``.

        Notes: This method always returns #PROPAGATION_STANDARD in case of errors.
        """
        return _pymdlsdk.IFunction_call_get_attribute_propagation(self, name)

    def enumerate_attributes(self, index):
        r"""
        Returns the name of the attribute indicated by ``index``.

        :type index: int
        :param index:        The index of the attribute.
        :rtype: string
        :return: The name of the attribute indicated by ``index``, or ``NULL`` if ``index``
                                is out of bounds.
        """
        return _pymdlsdk.IFunction_call_enumerate_attributes(self, index)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IFunction_call__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IFunction_call__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IFunction_call_get_iid(self)

# Register IFunction_call in _pymdlsdk:
_pymdlsdk.IFunction_call_swigregister(IFunction_call)

def IFunction_call_IID():
    return _pymdlsdk.IFunction_call_IID()

def IFunction_call__get_interface(iface):
    return _pymdlsdk.IFunction_call__get_interface(iface)

class IFunction_definition(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IFunction_definition_swiginit(self, _pymdlsdk.new_IFunction_definition(*args))
    __swig_destroy__ = _pymdlsdk.delete_IFunction_definition

    def __deref__(self):
        return _pymdlsdk.IFunction_definition___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IFunction_definition___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IFunction_definition_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IFunction_definition___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IFunction_definition___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IFunction_definition_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IFunction_definition_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IFunction_definition__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_module(self):
        r"""
        Returns the DB name of the module containing this function definition.

        The type of the module is #mi::neuraylib::IModule.
        """
        return _pymdlsdk.IFunction_definition_get_module(self)

    def get_mdl_name(self):
        r"""
        Returns the MDL name of the function definition.

        Notes: The MDL name of the function definition is different from the name of the DB element.
              Use #mi::neuraylib::ITransaction::name_of() to obtain the name of the DB element.

        :rtype: string
        :return: The MDL name of the function definition.
        """
        return _pymdlsdk.IFunction_definition_get_mdl_name(self)

    def get_mdl_module_name(self):
        r""" Returns the MDL name of the module containing this function definition."""
        return _pymdlsdk.IFunction_definition_get_mdl_module_name(self)

    def get_mdl_simple_name(self):
        r"""
        Returns the simple MDL name of the function definition.

        The simple name is the last component of the MDL name, i.e., without any packages and
        scope qualifiers, and without the parameter type names.

        :rtype: string
        :return: The simple MDL name of the function definition.
        """
        return _pymdlsdk.IFunction_definition_get_mdl_simple_name(self)

    def get_mdl_parameter_type_name(self, index):
        r"""
        Returns the type name of the parameter at ``index``.

        Notes: The type names provided here are substrings of the MDL name returned by
              #get_mdl_name(). They are provided here such that parsing of the MDL name is not
              necessary. Their main use case is one variant of overload resolution if no actual
              arguments are given (see
              #mi::neuraylib::IModule::get_function_overloads(const char*,const IArray*)const. For
              almost all other use cases it is strongly recommended to use #get_parameter_types()
              instead.

        :type index: int
        :param index:    The index of the parameter.
        :rtype: string
        :return: The type name of the parameter, or ``NULL`` if ``index`` is out of range.
        """
        return _pymdlsdk.IFunction_definition_get_mdl_parameter_type_name(self, index)

    def get_prototype(self):
        r"""
        Returns the DB name of the prototype, or ``NULL`` if this function definition is not a
        variant.
        """
        return _pymdlsdk.IFunction_definition_get_prototype(self)

    def get_mdl_version(self, since, removed):
        r"""
        Returns the MDL version when this function definition was added and removed.

        :type since: int, out
        :param since:     The MDL version in which this function definition was added. If the
                                  function definition does not belong to the standard library, the
                                  MDL version of the corresponding module is returned.
        :type removed: int, out
        :param removed:   The MDL version in which this function definition was removed, or
                                  mi::neuraylib::MDL_VERSION_INVALID if the function has not been
                                  removed so far or does not belong to the standard library.
        """
        return _pymdlsdk.IFunction_definition_get_mdl_version(self, since, removed)

    def get_semantic(self):
        r""" Returns the semantic of this function definition."""
        return _pymdlsdk.IFunction_definition_get_semantic(self)

    def is_array_constructor(self):
        r"""
        Indicates whether this definition represents the array constructor.

        See also: 'mi_neuray_mdl_arrays'
        """
        return _pymdlsdk.IFunction_definition_is_array_constructor(self)

    def is_exported(self):
        r""" Indicates whether the function definition is exported by its module."""
        return _pymdlsdk.IFunction_definition_is_exported(self)

    def is_uniform(self):
        r"""
        Indicates whether the function definition is uniform.

        Notes: This includes, in addition to functions definitions that are explicitly marked as
              uniform, also function definitions that are not explicitly marked either uniform or
              varying and that have been analyzed by the MDL compiler to be uniform.
        """
        return _pymdlsdk.IFunction_definition_is_uniform(self)

    def is_material(self):
        r"""
        Indicates whether the definition represents a material.

        If materials-are-functions is enabled, then this method returns ``true`` iff
        #mi::neuraylib::IFunction_definition::get_interface<mi::neuraylib::IMaterial_definition>()
        succeeds. Otherwise, this method always returns ``false``.

        See also: #mi::neuraylib::IMdl_configuration::set_materials_are_functions().
        """
        return _pymdlsdk.IFunction_definition_is_material(self)

    def get_return_type(self):
        r"""
        Returns the return type.

        :rtype: :py:class:`IType`
        :return: The return type.
        """
        return _pymdlsdk.IFunction_definition_get_return_type(self)

    def get_parameter_count(self):
        r""" Returns the number of parameters."""
        return _pymdlsdk.IFunction_definition_get_parameter_count(self)

    def get_parameter_name(self, index):
        r"""
        Returns the name of the parameter at ``index``.

        :type index: int
        :param index:    The index of the parameter.
        :rtype: string
        :return: The name of the parameter, or ``NULL`` if ``index`` is out of range.
        """
        return _pymdlsdk.IFunction_definition_get_parameter_name(self, index)

    def get_parameter_index(self, name):
        r"""
        Returns the index position of a parameter.

        :type name: string
        :param name:     The name of the parameter.
        :rtype: int
        :return: The index of the parameter, or -1 if ``name`` is invalid.
        """
        return _pymdlsdk.IFunction_definition_get_parameter_index(self, name)

    def get_parameter_types(self):
        r""" Returns the types of all parameters."""
        return _pymdlsdk.IFunction_definition_get_parameter_types(self)

    def get_defaults(self):
        r"""
        Returns the defaults of all parameters.

        Notes: Not all parameters have defaults. Hence, the indices in the returned expression list
              do not necessarily coincide with the parameter indices of this definition. Therefore,
              defaults should be retrieved via the name of the parameter instead of its index.
        """
        return _pymdlsdk.IFunction_definition_get_defaults(self)

    def get_enable_if_conditions(self):
        r"""
        Returns the enable_if conditions of all parameters.

        Notes: Not all parameters have a condition. Hence, the indices in the returned expression
              list do not necessarily coincide with the parameter indices of this definition.
              Therefore, conditions should be retrieved via the name of the parameter instead of
              its index.
        """
        return _pymdlsdk.IFunction_definition_get_enable_if_conditions(self)

    def get_enable_if_users(self, index):
        r"""
        Returns the number of other parameters whose enable_if condition might depend on the
        argument of the given parameter.

        :type index: int
        :param index:    The index of the parameter.
        :rtype: int
        :return: The number of other parameters whose enable_if condition depends on this
                            parameter argument.
        """
        return _pymdlsdk.IFunction_definition_get_enable_if_users(self, index)

    def get_enable_if_user(self, index, u_index):
        r"""
        Returns the index of a parameter whose enable_if condition might depend on the
        argument of the given parameter.

        :type index: int
        :param index:    The index of the parameter.
        :type u_index: int
        :param u_index:  The index of the enable_if user.
        :rtype: int
        :return: The index of a parameter whose enable_if condition depends on this
                            parameter argument, or ~0 if indexes are out of range.
        """
        return _pymdlsdk.IFunction_definition_get_enable_if_user(self, index, u_index)

    def get_annotations(self):
        r"""
        Returns the annotations of the function definition itself, or ``NULL`` if there are no such
        annotations.
        """
        return _pymdlsdk.IFunction_definition_get_annotations(self)

    def get_return_annotations(self):
        r"""
        Returns the annotations of the return type of this function definition, or ``NULL`` if there
        are no such annotations.
        """
        return _pymdlsdk.IFunction_definition_get_return_annotations(self)

    def get_parameter_annotations(self):
        r"""
        Returns the annotations of all parameters.

        Notes: Not all parameters have annotations. Hence, the indices in the returned annotation
              list do not necessarily coincide with the parameter indices of this definition.
              Therefore, annotation blocks should be retrieved via the name of the parameter
              instead of its index.
        """
        return _pymdlsdk.IFunction_definition_get_parameter_annotations(self)

    def get_thumbnail(self):
        r"""
        Returns the resolved file name of the thumbnail image for this function definition.

        The function first checks for a thumbnail annotation. If the annotation is provided,
        it uses the 'name' argument of the annotation and resolves that in the MDL search path.
        If the annotation is not provided or file resolution fails, it checks for a file
        module_name.material_name.png next to the MDL module.
        In case this cannot be found either ``NULL`` is returned.
        """
        return _pymdlsdk.IFunction_definition_get_thumbnail(self)

    def is_valid(self, context):
        r"""
        Returns ``true`` if the definition is valid, ``false`` otherwise.
        A definition can become invalid if the module it has been defined in
        or another module imported by that module has been reloaded. In the first case,
        the definition can no longer be used. In the second case, the
        definition can be validated by reloading the module it has been
        defined in.
        :type context: :py:class:`IMdl_execution_context`
        :param context:  Execution context that can be queried for error messages
                            after the operation has finished. Can be ``NULL``.
        :rtype: boolean
        :return: - ``true``   The definition is valid.
                        - ``false``  The definition is invalid.
        """
        return _pymdlsdk.IFunction_definition_is_valid(self, context)

    def get_body(self):
        r"""
        Returns the direct call expression that represents the body of the function (if possible).

        Notes: Functions bodies with control flow can not be represented by an expression. For such
              functions, this method always returns ``NULL``. For all other functions, i.e., for
              functions, whose body is an expression or a plain return statement, the method never
              returns ``NULL`` (unless there is no body at all, see below).

        Functions with a known semantic, i.e., different from
              #mi::neuraylib::IFunction_definition::DS_UNKNOWN, do not have a body as such, and the
              method returns ``NULL`` for such functions.
        """
        return _pymdlsdk.IFunction_definition_get_body(self)

    def get_temporary_count(self):
        r""" Returns the number of temporaries used by this function."""
        return _pymdlsdk.IFunction_definition_get_temporary_count(self)

    def get_temporary(self, index):
        r"""
        Returns the expression of a temporary.

        :type index: int
        :param index:            The index of the temporary.
        :rtype: :py:class:`IExpression`
        :return: The expression of the temporary, or ``NULL`` if ``index`` is out of
                                    range.
        """
        return _pymdlsdk.IFunction_definition_get_temporary(self, index)

    def get_temporary_name(self, index):
        r"""
        Returns the name of a temporary.

        Notes: Names of temporaries are not necessarily unique, e.g., due to inlining. Names are for
              informational purposes and should not be used to identify a particular temporary.

        See also: #mi::neuraylib::IMdl_configuration::set_expose_names_of_let_expressions()

        :type index: int
        :param index:            The index of the temporary.
        :rtype: string
        :return: The name of the temporary, or ``NULL`` if the temporary has no name
                                    or ``index`` is out of range.
        """
        return _pymdlsdk.IFunction_definition_get_temporary_name(self, index)

    def create_function_call_with_ret(self, arguments):
        r"""
        Creates a new function call.

        :type arguments: :py:class:`IExpression_list`
        :param arguments:    The arguments of the created function call.

                                Arguments for parameters without default are mandatory, otherwise
                                optional. The type of an argument must match the corresponding parameter
                                type. Any argument missing in ``arguments`` will be set to the default of
                                the corresponding parameter.

                                Note that the expressions in ``arguments`` are copied. This copy
                                operation is a deep copy, e.g., DB elements referenced in call
                                expressions are also copied.

                                ``NULL`` is a valid argument which is handled like an empty expression
                                list.
        :type errors: int, out, optional
        :param errors:  An optional pointer to an #mi::Sint32 to which an error code will be
                                written. The error codes have the following meaning:
                                -  0: Success.
                                - -1: An argument for a non-existing parameter was provided in
                                      ``arguments``.
                                - -2: The type of an argument in ``arguments`` does not have the correct
                                      type, see #get_parameter_types().
                                - -3: A parameter that has no default was not provided with an argument
                                      value.
                                - -4: The definition can not be instantiated because it is not exported.
                                - -5: A parameter type is uniform, but the corresponding argument has a
                                      varying return type.
                                - -6: An argument expression is not a constant nor a call.
                                - -8: One of the parameter types is uniform, but the corresponding
                                      argument or default is a call expression and the return type of
                                      the called function definition is effectively varying since the
                                      function definition itself is varying.
                                - -9: The function definition is invalid due to a module reload, see
                                      #is_valid() for diagnostics.
        :rtype: :py:class:`IFunction_call`
        :return: The created function call, or ``NULL`` in case of errors.
        """
        return _pymdlsdk.IFunction_definition_create_function_call_with_ret(self, arguments)

    def create_function_call(self, arguments):
        r"""
        Creates a new function call.

        :type arguments: :py:class:`IExpression_list`
        :param arguments:    The arguments of the created function call.

                                Arguments for parameters without default are mandatory, otherwise
                                optional. The type of an argument must match the corresponding parameter
                                type. Any argument missing in ``arguments`` will be set to the default of
                                the corresponding parameter.

                                Note that the expressions in ``arguments`` are copied. This copy
                                operation is a deep copy, e.g., DB elements referenced in call
                                expressions are also copied.

                                ``NULL`` is a valid argument which is handled like an empty expression
                                list.
        :param errors:  An optional pointer to an #mi::Sint32 to which an error code will be
                                written. The error codes have the following meaning:
                                -  0: Success.
                                - -1: An argument for a non-existing parameter was provided in
                                      ``arguments``.
                                - -2: The type of an argument in ``arguments`` does not have the correct
                                      type, see #get_parameter_types().
                                - -3: A parameter that has no default was not provided with an argument
                                      value.
                                - -4: The definition can not be instantiated because it is not exported.
                                - -5: A parameter type is uniform, but the corresponding argument has a
                                      varying return type.
                                - -6: An argument expression is not a constant nor a call.
                                - -8: One of the parameter types is uniform, but the corresponding
                                      argument or default is a call expression and the return type of
                                      the called function definition is effectively varying since the
                                      function definition itself is varying.
                                - -9: The function definition is invalid due to a module reload, see
                                      #is_valid() for diagnostics.
        :rtype: :py:class:`IFunction_call`
        :return: The created function call, or ``NULL`` in case of errors.
        """
        return _pymdlsdk.IFunction_definition_create_function_call(self, arguments)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IFunction_definition_compare_iid(self, iid)

    def get_element_type(self):
        r""" Indicates the actual scene element represented by interfaces derived from this interface."""
        return _pymdlsdk.IFunction_definition_get_element_type(self)

    def create_attribute(self, name, type):
        r"""
        Creates a new attribute ``name`` of the type ``type``.

        :type name: string
        :param name:         The name of the attribute. The name must not contain ``"["``, ``"]"``, or
                                ``"``."
        :type type: string
        :param type:         The type of the attribute. See 'mi_neuray_types' for a list of
                                supported attribute types.
        :rtype: :py:class:`IData`
        :return: A pointer to the created attribute, or ``NULL`` in case of failure.
                                Reasons for failure are:
                                - ``name`` or ``type`` is invalid,
                                - there is already an attribute with the name ``name``, or
                                - ``name`` is the name of a reserved attribute and ``type`` does not match
                                  the required type(s) of such an attribute.
        """
        return _pymdlsdk.IFunction_definition_create_attribute(self, name, type)

    def destroy_attribute(self, name):
        r"""
        Destroys the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute to destroy.
        :rtype: boolean
        :return: Returns ``true`` if the attribute has been successfully destroyed, and
                                ``false`` otherwise (there is no attribute with the name ``name)``.
        """
        return _pymdlsdk.IFunction_definition_destroy_attribute(self, name)

    def access_attribute(self, name):
        r"""
        Returns a const pointer to the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also access parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: :py:class:`IData`
        :return: A pointer to the attribute, or ``NULL`` if there is no attribute with
                                the name ``name``.
        """
        return _pymdlsdk.IFunction_definition_access_attribute(self, name)

    def edit_attribute(self, name):
        r"""
        Returns a mutable pointer to the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also access parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: :py:class:`IData`
        :return: A pointer to the attribute, or ``NULL`` if there is no attribute with
                                the name ``name``.
        """
        return _pymdlsdk.IFunction_definition_edit_attribute(self, name)

    def is_attribute(self, name):
        r"""
        Indicates existence of an attribute.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also checks for parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: boolean
        :return: ``true`` if the attribute set contains this attribute (and the attribute
                                contains the requested array element or struct member),
                                ``false`` otherwise
        """
        return _pymdlsdk.IFunction_definition_is_attribute(self, name)

    def get_attribute_type_name(self, name):
        r"""
        Returns the type of an attribute.

        See 'mi_neuray_types' for a list of supported attribute types.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also query parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: string
        :return: The type name of the attribute (or part thereof), or ``NULL`` if there
                                is no attribute with the name ``name``.

        Notes: The return value of this method is only valid until the next call of this method
              or any non-const methods on this instance.
        """
        return _pymdlsdk.IFunction_definition_get_attribute_type_name(self, name)

    def set_attribute_propagation(self, name, value):
        r"""
        Sets the propagation type of the attribute ``name``.

        :rtype: int
        :return: 
                                -  0: Success.
                                - -1: Invalid parameters (``NULL`` pointer or invalid enum value).
                                - -2: There is no attribute with name ``name``.
        """
        return _pymdlsdk.IFunction_definition_set_attribute_propagation(self, name, value)

    def get_attribute_propagation(self, name):
        r"""
        Returns the propagation type of the attribute ``name``.

        Notes: This method always returns #PROPAGATION_STANDARD in case of errors.
        """
        return _pymdlsdk.IFunction_definition_get_attribute_propagation(self, name)

    def enumerate_attributes(self, index):
        r"""
        Returns the name of the attribute indicated by ``index``.

        :type index: int
        :param index:        The index of the attribute.
        :rtype: string
        :return: The name of the attribute indicated by ``index``, or ``NULL`` if ``index``
                                is out of bounds.
        """
        return _pymdlsdk.IFunction_definition_enumerate_attributes(self, index)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IFunction_definition__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IFunction_definition__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IFunction_definition_get_iid(self)

# Register IFunction_definition in _pymdlsdk:
_pymdlsdk.IFunction_definition_swigregister(IFunction_definition)

def IFunction_definition_IID():
    return _pymdlsdk.IFunction_definition_IID()

def IFunction_definition__get_interface(iface):
    return _pymdlsdk.IFunction_definition__get_interface(iface)

class IImage(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IImage_swiginit(self, _pymdlsdk.new_IImage(*args))
    __swig_destroy__ = _pymdlsdk.delete_IImage

    def __deref__(self):
        return _pymdlsdk.IImage___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IImage___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IImage_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IImage___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IImage___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IImage_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IImage_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IImage__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def reset_file(self, filename):
        r"""
        Sets the image to a file identified by ``filename``.

        Note that support for a given image format requires an image plugin capable of handling
        that format.

        The filename can include one of the following three uv-tileset markers in the filename:
        <UDIM>, <UVTILE0>, or <UVTILE1>. The image refers then to a
        whole uv-tileset, a set of images used together as a single large two-dimensional image.
        The different markers indicate the different filename conventions that encode where each
        image file is placed in the uv texture space.



          |Marker
          |Pattern
          |(0,0) index
          |Convention to format a (u, v)-index
        |
        -

          |<UDIM>
          |DDDD
          |1001
          |UDIM, expands to the four digit number 1000+(u+1+v∗10)
        |

          |<UVTILE0>
          |"_u"I"_v"I
          |_u0_v0
          |0-based uv-tileset, expands to "_u"u"_v"v
        |

          |<UVTILE1>
          |"_u"I"_v"I
          |_u1_v1
          |1-based uv-tileset, expands to "_u"(u+1)"_v"(v+1)
        |


        :rtype: int
        :return: 
                                  -  0: Success.
                                  - -1: Invalid parameters (``NULL`` pointer).
                                  - -2: Failure to resolve the given filename, e.g., the file does not
                                        exist.
                                  - -3: Failure to open the file.
                                  - -4: No image plugin found to handle the file.
                                  - -5: The image plugin failed to import the file.
        """
        return _pymdlsdk.IImage_reset_file(self, filename)

    def reset_reader(self, *args):
        r"""
        *Overload 1:*
        Sets the image to the data provided by a reader.

        :type reader: mi::neuraylib::IReader
        :param reader:         The reader that provides the data for the image. The reader needs to
                                  support absolute access.
        :type image_format: string
        :param image_format:   The image format of the data, e.g., ``"jpg"``. Note that support for a
                                  given image format requires an image plugin capable of handling that
                                  format.
        :rtype: int
        :return: 
                                  -  0: Success.
                                  - -1: Invalid parameters (``NULL`` pointer).
                                  - -3: The reader does not support absolute access.
                                  - -4: No image plugin found to handle the data.
                                  - -5: The image plugin failed to import the data.

        |

        *Overload 2:*
        Sets the image to the uv-tile data provided by an array of readers.

        :type reader: :py:class:`IArray`
        :param reader:         A static or dynamic array of structures of type ``Uvtile_reader``. Such
                                  a structure has the following members:
                                  - #mi::Sint32 **u**

                                    The u-component of this uv-tile.
                                  - #mi::Sint32 **v**

                                    The v-component of this uv-tile.
                                  - #mi::neuraylib::IReader* **reader**

                                    The reader that provides the data for this uv-tile. The reader needs
                                    to support absolute access.
        :type image_format: string
        :param image_format:   The image format of the data, e.g., ``"jpg"``. Note that support for a
                                  given image format requires an image plugin capable of handling that
                                  format.
        :rtype: int
        :return: 
                                  -  0: Success.
                                  - -1: Invalid parameters (``NULL`` pointer).
                                  - -3: The reader does not support absolute access.
                                  - -4: No image plugin found to handle the data.
                                  - -5: The image plugin failed to import the data.
        """
        return _pymdlsdk.IImage_reset_reader(self, *args)

    def get_filename(self, uvtile_id=0):
        r"""
        Returns the resolved file name of the file containing the image.

        The method returns ``NULL`` if there is no file associated with the image, e.g., after
        default construction, calls to #set_from_canvas(), or failures to resolve the file name
        passed to #reset_file().

        See also: #get_original_filename()
        """
        return _pymdlsdk.IImage_get_filename(self, uvtile_id)

    def get_original_filename(self):
        r"""
        Returns the unresolved file as passed to #reset_file().

        The method returns ``NULL`` after default construction or calls to #set_from_canvas().

        See also: #get_filename()
        """
        return _pymdlsdk.IImage_get_original_filename(self)

    def set_from_canvas(self, *args):
        r"""
        *Overload 1:*
        Sets the pixels of this image based on the passed canvas (possibly sharing the pixel data).

        :type canvas: mi::neuraylib::ICanvas
        :param canvas:   The pixel data to be used by this image.
        :type shared: boolean, optional
        :param shared:   If ``false`` (the default), the pixel data is copied from ``canvas`` and the
                            method does the same as
                            #mi::neuraylib::IImage::set_from_canvas(const mi::neuraylib::ICanvas*).
                            If set to ``true``, the image uses the canvas directly (doing reference
                            counting on the canvas pointer). You must not modify the canvas content
                            after this call.
        :rtype: boolean
        :return: ``true`` if the pixel data of this image has been set correctly, and
                            ``false`` otherwise.

        |

        *Overload 2:*
        Sets the pixels of the uv-tiles of this image based on the passed canvases (possibly sharing
        the pixel data).

        :type uvtiles: :py:class:`IArray`
        :param uvtiles:  A static or dynamic array of structures of type ``Uvtile``. Such a structure
                            has the following members:
                            - #mi::Sint32 **u**

                              The u-component of this uv-tile.
                            - #mi::Sint32 **v**

                              The v-component of this uv-tile.
                            - #mi::neuraylib::ICanvas* **canvas**

                              The pixel data to be used for this image. Note that the pixel data is
                              copied, not shared. If sharing is intended use
                              #mi::neuraylib::IImage::set_from_canvas(mi::IArray*,bool) instead.
        :type shared: boolean, optional
        :param shared:   If ``false`` (the default), the pixel data is copied from ``canvas`` and the
                            method does the same as
                            #mi::neuraylib::IImage::set_from_canvas(const mi::neuraylib::ICanvas*).
                            If set to ``true``, the image uses the canvases directly (doing reference
                            counting on the canvas pointers). You must not modify the canvas contents
                            after this call.
        :rtype: boolean
        :return: ``true`` if the pixel data of this image has been set correctly, and
                            ``false`` otherwise.
        """
        return _pymdlsdk.IImage_set_from_canvas(self, *args)

    def get_canvas(self, level=0, uvtile_id=0):
        r"""
        Returns a canvas with the pixel data of the image.

        Note that it is not possible to manipulate the pixel data.

        :type level: int, optional
        :param level:       The desired mipmap level. Level 0 is the highest resolution.
        :type uvtile_id: int, optional
        :param uvtile_id:   The uv-tile id of the canvas.
        :rtype: mi::neuraylib::ICanvas
        :return: A canvas pointing to the pixel data of the image, or ``NULL`` in case of
                               failure, e.g. because of an invalid tile id.
        """
        return _pymdlsdk.IImage_get_canvas(self, level, uvtile_id)

    def get_type(self, uvtile_id=0):
        r"""
        Returns the pixel type of the image.

        :type uvtile_id: int, optional
        :param uvtile_id:   The uv-tile id of the canvas to get the pixel type for.
        :rtype: char
        :return: The pixel type or 0 in case of an invalid tile id.
            See 'mi_neuray_types' for a list of supported pixel types.
        """
        return _pymdlsdk.IImage_get_type(self, uvtile_id)

    def get_levels(self, uvtile_id=0):
        r"""
        Returns the number of levels in the mipmap pyramid.

        :type uvtile_id: int, optional
        :param uvtile_id:   The uv-tile id of the canvas to get the number of levels for.
        :rtype: int
        :return: The number of levels or -1 in case of an invalid tile id.
        """
        return _pymdlsdk.IImage_get_levels(self, uvtile_id)

    def resolution_x(self, level=0, uvtile_id=0):
        r"""
        Returns the horizontal resolution of the image.

        :type level: int, optional
        :param level:       The desired mipmap level. Level 0 is the highest resolution.
        :type uvtile_id: int, optional
        :param uvtile_id:   The uv-tile id of the canvas to get the resolution for.
        :rtype: int
        :return: The horizontal resolution or -1 in case of an invalid tile id.
        """
        return _pymdlsdk.IImage_resolution_x(self, level, uvtile_id)

    def resolution_y(self, level=0, uvtile_id=0):
        r"""
        Returns the vertical resolution of the image.

        :type level: int, optional
        :param level:       The desired mipmap level. Level 0 is the highest resolution.
        :type uvtile_id: int, optional
        :param uvtile_id:   The uv-tile id of the canvas to get the resolution for.
        :rtype: int
        :return: The vertical resolution or -1 in case of an invalid tile id.
        """
        return _pymdlsdk.IImage_resolution_y(self, level, uvtile_id)

    def resolution_z(self, level=0, uvtile_id=0):
        r"""
        Returns the number of layers of the 3D image.

        :type level: int, optional
        :param level:       The desired mipmap level. Level 0 is the highest resolution.
        :type uvtile_id: int, optional
        :param uvtile_id:   The uv-tile id of the canvas to get the resolution for.
        :rtype: int
        :return: The number of layers or -1 in case of an invalid tile id.
        """
        return _pymdlsdk.IImage_resolution_z(self, level, uvtile_id)

    def get_uvtile_length(self):
        r""" Returns the number of uv-tiles of the image."""
        return _pymdlsdk.IImage_get_uvtile_length(self)

    def get_uvtile_uv(self, uvtile_id, u, v):
        r"""
        Returns the u and v tile indices of the uv-tile at the given index.

        :type uvtile_id: int
        :param uvtile_id:   The uv-tile id of the canvas.
        :type u: int
        :param u:           The u-component of the uv-tile
        :type v: int
        :param v:           The v-component of the uv-tile
        :rtype: int
        :return: 0 on success, -1 if uvtile_id is out of range.
        """
        return _pymdlsdk.IImage_get_uvtile_uv(self, uvtile_id, u, v)

    def get_uvtile_id(self, u, v):
        r"""
        Returns the uvtile-id corresponding to the tile at u,v.

        :type u: int
        :param u:           The u-component of the uv-tile
        :type v: int
        :param v:           The v-component of the uv-tile
        :rtype: int
        :return: The uvtile-id or -1 of there is no tile with the given coordinates.
        """
        return _pymdlsdk.IImage_get_uvtile_id(self, u, v)

    def is_uvtile(self):
        r""" Returns ``true`` if this image represents a uvtile/udim image sequence."""
        return _pymdlsdk.IImage_is_uvtile(self)

    def get_uvtile_uv_ranges(self, min_u, min_v, max_u, max_v):
        r"""
        Returns the ranges of u and v coordinates (or all values zero if #is_uvtile() returns
        ``false)``.
        """
        return _pymdlsdk.IImage_get_uvtile_uv_ranges(self, min_u, min_v, max_u, max_v)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IImage_compare_iid(self, iid)

    def get_element_type(self):
        r""" Indicates the actual scene element represented by interfaces derived from this interface."""
        return _pymdlsdk.IImage_get_element_type(self)

    def create_attribute(self, name, type):
        r"""
        Creates a new attribute ``name`` of the type ``type``.

        :type name: string
        :param name:         The name of the attribute. The name must not contain ``"["``, ``"]"``, or
                                ``"``."
        :type type: string
        :param type:         The type of the attribute. See 'mi_neuray_types' for a list of
                                supported attribute types.
        :rtype: :py:class:`IData`
        :return: A pointer to the created attribute, or ``NULL`` in case of failure.
                                Reasons for failure are:
                                - ``name`` or ``type`` is invalid,
                                - there is already an attribute with the name ``name``, or
                                - ``name`` is the name of a reserved attribute and ``type`` does not match
                                  the required type(s) of such an attribute.
        """
        return _pymdlsdk.IImage_create_attribute(self, name, type)

    def destroy_attribute(self, name):
        r"""
        Destroys the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute to destroy.
        :rtype: boolean
        :return: Returns ``true`` if the attribute has been successfully destroyed, and
                                ``false`` otherwise (there is no attribute with the name ``name)``.
        """
        return _pymdlsdk.IImage_destroy_attribute(self, name)

    def access_attribute(self, name):
        r"""
        Returns a const pointer to the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also access parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: :py:class:`IData`
        :return: A pointer to the attribute, or ``NULL`` if there is no attribute with
                                the name ``name``.
        """
        return _pymdlsdk.IImage_access_attribute(self, name)

    def edit_attribute(self, name):
        r"""
        Returns a mutable pointer to the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also access parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: :py:class:`IData`
        :return: A pointer to the attribute, or ``NULL`` if there is no attribute with
                                the name ``name``.
        """
        return _pymdlsdk.IImage_edit_attribute(self, name)

    def is_attribute(self, name):
        r"""
        Indicates existence of an attribute.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also checks for parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: boolean
        :return: ``true`` if the attribute set contains this attribute (and the attribute
                                contains the requested array element or struct member),
                                ``false`` otherwise
        """
        return _pymdlsdk.IImage_is_attribute(self, name)

    def get_attribute_type_name(self, name):
        r"""
        Returns the type of an attribute.

        See 'mi_neuray_types' for a list of supported attribute types.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also query parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: string
        :return: The type name of the attribute (or part thereof), or ``NULL`` if there
                                is no attribute with the name ``name``.

        Notes: The return value of this method is only valid until the next call of this method
              or any non-const methods on this instance.
        """
        return _pymdlsdk.IImage_get_attribute_type_name(self, name)

    def set_attribute_propagation(self, name, value):
        r"""
        Sets the propagation type of the attribute ``name``.

        :rtype: int
        :return: 
                                -  0: Success.
                                - -1: Invalid parameters (``NULL`` pointer or invalid enum value).
                                - -2: There is no attribute with name ``name``.
        """
        return _pymdlsdk.IImage_set_attribute_propagation(self, name, value)

    def get_attribute_propagation(self, name):
        r"""
        Returns the propagation type of the attribute ``name``.

        Notes: This method always returns #PROPAGATION_STANDARD in case of errors.
        """
        return _pymdlsdk.IImage_get_attribute_propagation(self, name)

    def enumerate_attributes(self, index):
        r"""
        Returns the name of the attribute indicated by ``index``.

        :type index: int
        :param index:        The index of the attribute.
        :rtype: string
        :return: The name of the attribute indicated by ``index``, or ``NULL`` if ``index``
                                is out of bounds.
        """
        return _pymdlsdk.IImage_enumerate_attributes(self, index)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IImage__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IImage__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IImage_get_iid(self)

# Register IImage in _pymdlsdk:
_pymdlsdk.IImage_swigregister(IImage)

def IImage_IID():
    return _pymdlsdk.IImage_IID()

def IImage__get_interface(iface):
    return _pymdlsdk.IImage__get_interface(iface)

class ILightprofile(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.ILightprofile_swiginit(self, _pymdlsdk.new_ILightprofile(*args))
    __swig_destroy__ = _pymdlsdk.delete_ILightprofile

    def __deref__(self):
        return _pymdlsdk.ILightprofile___deref__(self)

    def __ref__(self):
        return _pymdlsdk.ILightprofile___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.ILightprofile_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.ILightprofile___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.ILightprofile___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.ILightprofile_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.ILightprofile_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.ILightprofile__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def reset_file(self, *args):
        r"""
        Sets the light profile to a file identified by ``filename``.

        :type filename: string
        :param filename:           The new file containing the light profile data.
        :type resolution_phi: int, optional
        :param resolution_phi:     The desired resolution of the equidistant grid in phi-direction.


                                      The special value 0 leaves the choice of a suitable resolution to
                                      the implementation. Currently, the implementation behaves as
                                      follows: If the angles in phi-direction are already equidistant,
                                      the resolution in the file itself (after unfolding of symmetries)
                                      is kept unchanged. If the angles in phi-direction are not
                                      equidistant, a suitable resolution that maintains the angles given
                                      in the file is chosen. If that fails, a fixed resolution is
                                      chosen.
        :type resolution_theta: int, optional
        :param resolution_theta:   The desired resolution of the equidistant grid in theta-direction.


                                      The special value 0 leaves the choice of a suitable resolution to
                                      the implementation. Currently, the implementation behaves as
                                      follows: If the angles in theta-direction are already equidistant,
                                      the resolution in the file itself (after unfolding of symmetries)
                                      is kept unchanged. If the angles in theta-direction are not
                                      equidistant, a suitable resolution that maintains the angles given
                                      in the file is chosen. If that fails, a fixed resolution is
                                      chosen.
        :type degree: int, optional
        :param degree:             The interpolation method to use.
        :type flags: int, optional
        :param flags:              Flags to be used when interpreting the file data,
                                      see #mi::neuraylib::Lightprofile_flags for details.
        :rtype: int
        :return: 
                                      -  0: Success.
                                      - -1: Invalid parameters (``NULL`` pointer).
                                      - -2: Failure to resolve the given filename, e.g., the file does
                                            not exist.
                                      - -3: ``degree`` or ``flags`` is invalid (exactly one of
                                            #mi::neuraylib::LIGHTPROFILE_CLOCKWISE or
                                            #mi::neuraylib::LIGHTPROFILE_COUNTER_CLOCKWISE must be set).
                                      - -4: File format error.
                                      - -5: ``resolution_phi`` or ``resolution_theta`` is invalid (must
                                            not be 1).
        """
        return _pymdlsdk.ILightprofile_reset_file(self, *args)

    def reset_reader(self, *args):
        r"""
        Sets the light profile to the data provided by a reader.

        :type reader: mi::neuraylib::IReader
        :param reader:             The reader that provides the data for the BSDF measurement in
                                      ``.ies`` format.
        :type resolution_phi: int, optional
        :param resolution_phi:     The desired resolution of the equidistant grid in phi-direction.


                                      The special value 0 leaves the choice of a suitable resolution to
                                      the implementation. Currently, the implementation behaves as
                                      follows: If the angles in phi-direction are already equidistant,
                                      the resolution in the file itself (after unfolding of symmetries)
                                      is kept unchanged. If the angles in phi-direction are not
                                      equidistant, a suitable resolution that maintains the angles given
                                      in the file is chosen. If that fails, a fixed resolution is
                                      chosen.
        :type resolution_theta: int, optional
        :param resolution_theta:   The desired resolution of the equidistant grid in theta-direction.


                                      The special value 0 leaves the choice of a suitable resolution to
                                      the implementation. Currently, the implementation behaves as
                                      follows: If the angles in theta-direction are already equidistant,
                                      the resolution in the file itself (after unfolding of symmetries)
                                      is kept unchanged. If the angles in theta-direction are not
                                      equidistant, a suitable resolution that maintains the angles given
                                      in the file is chosen. If that fails, a fixed resolution is
                                      chosen.
        :type degree: int, optional
        :param degree:             The interpolation method to use.
        :type flags: int, optional
        :param flags:              Flags to be used when interpreting the data,
                                      see #mi::neuraylib::Lightprofile_flags for details.
        :rtype: int
        :return: 
                                      -  0: Success.
                                      - -1: Invalid parameters (``NULL`` pointer).
                                      - -3: ``degree`` or ``flags`` is invalid (exactly one of
                                            #mi::neuraylib::LIGHTPROFILE_CLOCKWISE or
                                            #mi::neuraylib::LIGHTPROFILE_COUNTER_CLOCKWISE must be set).
                                      - -4: File format error.
                                      - -5: ``resolution_phi`` or ``resolution_theta`` is invalid (must
                                            not be 1).
        """
        return _pymdlsdk.ILightprofile_reset_reader(self, *args)

    def get_filename(self):
        r"""
        Returns the resolved file name of the file containing the light profile.

        The method returns ``NULL`` if there is no file associated with the light profile, e.g.,
        after default construction or failures to resolve the file name passed to #reset_file().

        See also: #get_original_filename()
        """
        return _pymdlsdk.ILightprofile_get_filename(self)

    def get_original_filename(self):
        r"""
        Returns the unresolved file name as passed to #reset_file().

        The method returns ``NULL`` after default construction.

        See also: #get_filename()
        """
        return _pymdlsdk.ILightprofile_get_original_filename(self)

    def get_resolution_phi(self):
        r""" Returns the resolution of the grid in phi-direction, or 0 after default construction."""
        return _pymdlsdk.ILightprofile_get_resolution_phi(self)

    def get_resolution_theta(self):
        r""" Returns the resolution of the grid in theta-direction, or 0 after default construction."""
        return _pymdlsdk.ILightprofile_get_resolution_theta(self)

    def get_degree(self):
        r"""
        Returns the interpolation degree that was used to interpolate the grid data, or
        #mi::neuraylib::LIGHTPROFILE_HERMITE_BASE_1 after default construction.
        """
        return _pymdlsdk.ILightprofile_get_degree(self)

    def get_flags(self):
        r"""
        Returns flags that were used to interpret the light profile data in the file, or
        #mi::neuraylib::LIGHTPROFILE_COUNTER_CLOCKWISE after default construction.

        See also: #mi::neuraylib::Lightprofile_flags.
        """
        return _pymdlsdk.ILightprofile_get_flags(self)

    def get_phi(self, index):
        r"""
        Returns the ``index`` -th phi value.

        Note that the grid is an equidistant grid, i.e., the distance between subsequent phi values
        is always the same. If ``index`` is out of bounds or after default construction, 0 is
        returned.
        """
        return _pymdlsdk.ILightprofile_get_phi(self, index)

    def get_theta(self, index):
        r"""
        Returns the ``index`` -th theta value.

        Note that the grid is an equidistant grid, i.e., the distance between subsequent theta
        values is always the same. If ``index`` is out of bounds or after default construction, 0 is
        returned.
        """
        return _pymdlsdk.ILightprofile_get_theta(self, index)

    def get_data(self, *args):
        r"""
        *Overload 1:*
        Returns the normalized data of the entire grid.

        :rtype: float
        :return: A pointer to the normalized data for all vertices of the grid. The data values are
                      stored as array in column-major order (where all elements of a column have the
                      same phi value). Returns ``NULL`` after default construction.

        See also: #get_candela_multiplier()

        |

        *Overload 2:*
        Returns the normalized data for a grid vertex.

        :type index_phi: int
        :param index_phi:     Index in phi-direction of the vertex.
        :type index_theta: int
        :param index_theta:   Index in theta-direction of the vertex.
        :rtype: float
        :return: The normalized data for the grid point, or 0 in case of errors or after
                                 default construction.

        See also: #get_candela_multiplier(), #sample()
        """
        return _pymdlsdk.ILightprofile_get_data(self, *args)

    def get_candela_multiplier(self):
        r"""
        Returns the normalization factor.

        All data is normalized such that the maximum is 1.0. The values returned by methods like
        #get_data() need to be multiplied by this normalization factor to retrieve the true value.
        Returns 0 after default construction.
        """
        return _pymdlsdk.ILightprofile_get_candela_multiplier(self)

    def sample(self, phi, theta, candela):
        r"""
        Samples the light profile.

        The method computes a bi-linear interpolation of the light profile at (phi,theta) according
        to the resolution.

        :type phi: float
        :param phi:       First dimension of sample point.
        :type theta: float
        :param theta:     Second dimension of sample point.
        :type candela: boolean
        :param candela:   If ``false``, normalized values are returned, otherwise true values.
                             See #get_candela_multiplier().
        :rtype: float
        :return: The computed sample value, or 0 in case of errors or after default
                             construction.

        See also: #get_data()
        """
        return _pymdlsdk.ILightprofile_sample(self, phi, theta, candela)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.ILightprofile_compare_iid(self, iid)

    def get_element_type(self):
        r""" Indicates the actual scene element represented by interfaces derived from this interface."""
        return _pymdlsdk.ILightprofile_get_element_type(self)

    def create_attribute(self, name, type):
        r"""
        Creates a new attribute ``name`` of the type ``type``.

        :type name: string
        :param name:         The name of the attribute. The name must not contain ``"["``, ``"]"``, or
                                ``"``."
        :type type: string
        :param type:         The type of the attribute. See 'mi_neuray_types' for a list of
                                supported attribute types.
        :rtype: :py:class:`IData`
        :return: A pointer to the created attribute, or ``NULL`` in case of failure.
                                Reasons for failure are:
                                - ``name`` or ``type`` is invalid,
                                - there is already an attribute with the name ``name``, or
                                - ``name`` is the name of a reserved attribute and ``type`` does not match
                                  the required type(s) of such an attribute.
        """
        return _pymdlsdk.ILightprofile_create_attribute(self, name, type)

    def destroy_attribute(self, name):
        r"""
        Destroys the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute to destroy.
        :rtype: boolean
        :return: Returns ``true`` if the attribute has been successfully destroyed, and
                                ``false`` otherwise (there is no attribute with the name ``name)``.
        """
        return _pymdlsdk.ILightprofile_destroy_attribute(self, name)

    def access_attribute(self, name):
        r"""
        Returns a const pointer to the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also access parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: :py:class:`IData`
        :return: A pointer to the attribute, or ``NULL`` if there is no attribute with
                                the name ``name``.
        """
        return _pymdlsdk.ILightprofile_access_attribute(self, name)

    def edit_attribute(self, name):
        r"""
        Returns a mutable pointer to the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also access parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: :py:class:`IData`
        :return: A pointer to the attribute, or ``NULL`` if there is no attribute with
                                the name ``name``.
        """
        return _pymdlsdk.ILightprofile_edit_attribute(self, name)

    def is_attribute(self, name):
        r"""
        Indicates existence of an attribute.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also checks for parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: boolean
        :return: ``true`` if the attribute set contains this attribute (and the attribute
                                contains the requested array element or struct member),
                                ``false`` otherwise
        """
        return _pymdlsdk.ILightprofile_is_attribute(self, name)

    def get_attribute_type_name(self, name):
        r"""
        Returns the type of an attribute.

        See 'mi_neuray_types' for a list of supported attribute types.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also query parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: string
        :return: The type name of the attribute (or part thereof), or ``NULL`` if there
                                is no attribute with the name ``name``.

        Notes: The return value of this method is only valid until the next call of this method
              or any non-const methods on this instance.
        """
        return _pymdlsdk.ILightprofile_get_attribute_type_name(self, name)

    def set_attribute_propagation(self, name, value):
        r"""
        Sets the propagation type of the attribute ``name``.

        :rtype: int
        :return: 
                                -  0: Success.
                                - -1: Invalid parameters (``NULL`` pointer or invalid enum value).
                                - -2: There is no attribute with name ``name``.
        """
        return _pymdlsdk.ILightprofile_set_attribute_propagation(self, name, value)

    def get_attribute_propagation(self, name):
        r"""
        Returns the propagation type of the attribute ``name``.

        Notes: This method always returns #PROPAGATION_STANDARD in case of errors.
        """
        return _pymdlsdk.ILightprofile_get_attribute_propagation(self, name)

    def enumerate_attributes(self, index):
        r"""
        Returns the name of the attribute indicated by ``index``.

        :type index: int
        :param index:        The index of the attribute.
        :rtype: string
        :return: The name of the attribute indicated by ``index``, or ``NULL`` if ``index``
                                is out of bounds.
        """
        return _pymdlsdk.ILightprofile_enumerate_attributes(self, index)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.ILightprofile__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.ILightprofile__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.ILightprofile_get_iid(self)

# Register ILightprofile in _pymdlsdk:
_pymdlsdk.ILightprofile_swigregister(ILightprofile)

def ILightprofile_IID():
    return _pymdlsdk.ILightprofile_IID()

def ILightprofile__get_interface(iface):
    return _pymdlsdk.ILightprofile__get_interface(iface)

class IMaterial_definition(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IMaterial_definition_swiginit(self, _pymdlsdk.new_IMaterial_definition(*args))
    __swig_destroy__ = _pymdlsdk.delete_IMaterial_definition

    def __deref__(self):
        return _pymdlsdk.IMaterial_definition___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IMaterial_definition___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IMaterial_definition_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IMaterial_definition___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IMaterial_definition___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IMaterial_definition_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IMaterial_definition_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IMaterial_definition__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_module(self):
        r"""
        Returns the DB name of the module containing this material definition.

        The type of the module is #mi::neuraylib::IModule.
        """
        return _pymdlsdk.IMaterial_definition_get_module(self)

    def get_mdl_name(self):
        r"""
        Returns the MDL name of the material definition.

        Notes: The MDL name of the material definition is different from the name of the DB element.
              Use #mi::neuraylib::ITransaction::name_of() to obtain the name of the DB element.

        :rtype: string
        :return: The MDL name of the material definition.
        """
        return _pymdlsdk.IMaterial_definition_get_mdl_name(self)

    def get_mdl_module_name(self):
        r""" Returns the MDL name of the module containing this material definition."""
        return _pymdlsdk.IMaterial_definition_get_mdl_module_name(self)

    def get_mdl_simple_name(self):
        r"""
        Returns the simple MDL name of the function definition.

        The simple name is the last component of the MDL name, i.e., without any packages and scope
        qualifiers.

        :rtype: string
        :return: The simple MDL name of the function definition.
        """
        return _pymdlsdk.IMaterial_definition_get_mdl_simple_name(self)

    def get_mdl_parameter_type_name(self, index):
        r"""
        Returns the type name of the parameter at ``index``.

        Notes: The type names provided here are substrings of the MDL name returned by
              #get_mdl_name(). They are provided here such that parsing of the MDL name is not
              necessary. Their main use case is one variant of overload resolution if no actual
              arguments are given (see
              #mi::neuraylib::IModule::get_function_overloads(const char*,const IArray*)const. For
              almost all other use cases it is strongly recommended to use #get_parameter_types()
              instead.

        :type index: int
        :param index:    The index of the parameter.
        :rtype: string
        :return: The type name of the parameter, or ``NULL`` if ``index`` is out of range.
        """
        return _pymdlsdk.IMaterial_definition_get_mdl_parameter_type_name(self, index)

    def get_prototype(self):
        r"""
        Returns the DB name of the prototype, or ``NULL`` if this material definition is not a
        variant.
        """
        return _pymdlsdk.IMaterial_definition_get_prototype(self)

    def get_mdl_version(self, since, removed):
        r"""
        Returns the MDL version when this material definition was added and removed.

        :type since: int, out
        :param since:     The MDL version in which this material definition was added. Since
                                  there are no material definitions in the standard library, the
                                  MDL version of the corresponding module is returned.
        :type removed: int, out
        :param removed:   The MDL version in which this material definition was removed. Since
                                  there are no material definitions in the standard library,
                                  mi::neuraylib::MDL_VERSION_INVALID is always returned.
        """
        return _pymdlsdk.IMaterial_definition_get_mdl_version(self, since, removed)

    def get_semantic(self):
        r"""
        Returns the semantic of this material definition.

        Right now there are no materials with special semantics, i.e., this method always returns
        #mi::neuraylib::IFunction_definition::DS_UNKNOWN.
        """
        return _pymdlsdk.IMaterial_definition_get_semantic(self)

    def is_exported(self):
        r""" Indicates whether the material definition is exported by its module."""
        return _pymdlsdk.IMaterial_definition_is_exported(self)

    def get_return_type(self):
        r""" Returns the return type (the fixed material type)."""
        return _pymdlsdk.IMaterial_definition_get_return_type(self)

    def get_parameter_count(self):
        r""" Returns the number of parameters."""
        return _pymdlsdk.IMaterial_definition_get_parameter_count(self)

    def get_parameter_name(self, index):
        r"""
        Returns the name of the parameter at ``index``.

        :type index: int
        :param index:    The index of the parameter.
        :rtype: string
        :return: The name of the parameter, or ``NULL`` if ``index`` is out of range.
        """
        return _pymdlsdk.IMaterial_definition_get_parameter_name(self, index)

    def get_parameter_index(self, name):
        r"""
        Returns the index position of a parameter.

        :type name: string
        :param name:     The name of the parameter.
        :rtype: int
        :return: The index of the parameter, or -1 if ``name`` is invalid.
        """
        return _pymdlsdk.IMaterial_definition_get_parameter_index(self, name)

    def get_parameter_types(self):
        r""" Returns the types of all parameters."""
        return _pymdlsdk.IMaterial_definition_get_parameter_types(self)

    def get_defaults(self):
        r"""
        Returns the defaults of all parameters.

        Notes: Not all parameters have defaults. Hence, the indices in the returned expression list
              do not necessarily coincide with the parameter indices of this definition. Therefore,
              defaults should be retrieved via the name of the parameter instead of its index.
        """
        return _pymdlsdk.IMaterial_definition_get_defaults(self)

    def get_enable_if_conditions(self):
        r"""
        Returns the enable_if conditions of all parameters.

        Notes: Not all parameters have a condition. Hence, the indices in the returned expression
              list do not necessarily coincide with the parameter indices of this definition.
              Therefore, conditions should be retrieved via the name of the parameter instead of
              its index.
        """
        return _pymdlsdk.IMaterial_definition_get_enable_if_conditions(self)

    def get_enable_if_users(self, index):
        r"""
        Returns the number of other parameters whose enable_if condition might depend on the
        argument of the given parameter.

        :type index: int
        :param index:    The index of the parameter.
        :rtype: int
        :return: The number of other parameters whose enable_if condition depends on this
                            parameter argument.
        """
        return _pymdlsdk.IMaterial_definition_get_enable_if_users(self, index)

    def get_enable_if_user(self, index, u_index):
        r"""
        Returns the index of a parameter whose enable_if condition might depend on the
        argument of the given parameter.

        :type index: int
        :param index:    The index of the parameter.
        :type u_index: int
        :param u_index:  The index of the enable_if user.
        :rtype: int
        :return: The index of a parameter whose enable_if condition depends on this
                            parameter argument, or ~0 if indexes are out of range.
        """
        return _pymdlsdk.IMaterial_definition_get_enable_if_user(self, index, u_index)

    def get_annotations(self):
        r"""
        Returns the annotations of the material definition itself, or ``NULL`` if there are no such
        annotations.
        """
        return _pymdlsdk.IMaterial_definition_get_annotations(self)

    def get_parameter_annotations(self):
        r"""
        Returns the annotations of all parameters.

        Notes: Not all parameters have annotations. Hence, the indices in the returned annotation
              list do not necessarily coincide with the parameter indices of this definition.
              Therefore, annotation blocks should be retrieved via the name of the parameter
              instead of its index.
        """
        return _pymdlsdk.IMaterial_definition_get_parameter_annotations(self)

    def get_thumbnail(self):
        r"""
        Returns the resolved file name of the thumbnail image for this material definition.

        The function first checks for a thumbnail annotation. If the annotation is provided,
        it uses the 'name' argument of the annotation and resolves that in the MDL search path.
        If the annotation is not provided or file resolution fails, it checks for a file
        module_name.material_name.png next to the MDL module.
        In case this cannot be found either ``NULL`` is returned.
        """
        return _pymdlsdk.IMaterial_definition_get_thumbnail(self)

    def is_valid(self, context):
        r"""
        Returns ``true`` if the definition is valid, ``false`` otherwise.
        A definition can become invalid if the module it has been defined in
        or another module imported by that module has been reloaded. In the first case,
        the definition can no longer be used. In the second case, the
        definition can be validated by reloading the module it has been
        defined in.
        :type context: :py:class:`IMdl_execution_context`
        :param context:  Execution context that can be queried for error messages
                            after the operation has finished. Can be ``NULL``.
        :rtype: boolean
        :return: - ``true``   The definition is valid.
                        - ``false``  The definition is invalid.
        """
        return _pymdlsdk.IMaterial_definition_is_valid(self, context)

    def get_body(self):
        r""" Returns the direct call expression that represents the body of the material."""
        return _pymdlsdk.IMaterial_definition_get_body(self)

    def get_temporary_count(self):
        r""" Returns the number of temporaries used by this material."""
        return _pymdlsdk.IMaterial_definition_get_temporary_count(self)

    def get_temporary(self, index):
        r"""
        Returns the expression of a temporary.

        :type index: int
        :param index:            The index of the temporary.
        :rtype: :py:class:`IExpression`
        :return: The expression of the temporary, or ``NULL`` if ``index`` is out of
                                    range.
        """
        return _pymdlsdk.IMaterial_definition_get_temporary(self, index)

    def get_temporary_name(self, index):
        r"""
        Returns the name of a temporary.

        Notes: Names of temporaries are not necessarily unique, e.g., due to inlining. Names are for
              informational purposes and should not be used to identify a particular temporary.

        See also: #mi::neuraylib::IMdl_configuration::set_expose_names_of_let_expressions()

        :type index: int
        :param index:            The index of the temporary.
        :rtype: string
        :return: The name of the temporary, or ``NULL`` if the temporary has no name
                                    or ``index`` is out of range.
        """
        return _pymdlsdk.IMaterial_definition_get_temporary_name(self, index)

    def create_material_instance_with_ret(self, arguments):
        r"""
        Creates a new material instance.

        :type arguments: :py:class:`IExpression_list`
        :param arguments:    The arguments of the created material instance.

                                Arguments for parameters without default are mandatory, otherwise
                                optional. The type of an argument must match the corresponding parameter
                                type. Any argument missing in ``arguments`` will be set to the default of
                                the corresponding parameter.

                                Note that the expressions in ``arguments`` are copied. This copy
                                operation is a deep copy, e.g., DB elements referenced in call
                                expressions are also copied.

                                ``NULL`` is a valid argument which is handled like an empty expression
                                list.
        :type errors: int, out, optional
        :param errors:  An optional pointer to an #mi::Sint32 to which an error code will be
                                written. The error codes have the following meaning:
                                -  0: Success.
                                - -1: An argument for a non-existing parameter was provided in
                                      ``arguments``.
                                - -2: The type of an argument in ``arguments`` does not have the correct
                                      type, see #get_parameter_types().
                                - -3: A parameter that has no default was not provided with an argument
                                      value.
                                - -4: The definition can not be instantiated because it is not exported.
                                - -5: A parameter type is uniform, but the corresponding argument has a
                                      varying return type.
                                - -6: An argument expression is not a constant nor a call.
                                - -8: One of the parameter types is uniform, but the corresponding
                                      argument or default is a call expression and the return type of
                                      the called function definition is effectively varying since the
                                      function definition itself is varying.
                                - -9: The material definition is invalid due to a module reload, see
                                      #is_valid() for diagnostics.
        :rtype: :py:class:`IMaterial_instance`
        :return: The created material instance, or ``NULL`` in case of errors.
        """
        return _pymdlsdk.IMaterial_definition_create_material_instance_with_ret(self, arguments)

    def create_material_instance(self, arguments):
        r"""
        Creates a new material instance.

        :type arguments: :py:class:`IExpression_list`
        :param arguments:    The arguments of the created material instance.

                                Arguments for parameters without default are mandatory, otherwise
                                optional. The type of an argument must match the corresponding parameter
                                type. Any argument missing in ``arguments`` will be set to the default of
                                the corresponding parameter.

                                Note that the expressions in ``arguments`` are copied. This copy
                                operation is a deep copy, e.g., DB elements referenced in call
                                expressions are also copied.

                                ``NULL`` is a valid argument which is handled like an empty expression
                                list.
        :param errors:  An optional pointer to an #mi::Sint32 to which an error code will be
                                written. The error codes have the following meaning:
                                -  0: Success.
                                - -1: An argument for a non-existing parameter was provided in
                                      ``arguments``.
                                - -2: The type of an argument in ``arguments`` does not have the correct
                                      type, see #get_parameter_types().
                                - -3: A parameter that has no default was not provided with an argument
                                      value.
                                - -4: The definition can not be instantiated because it is not exported.
                                - -5: A parameter type is uniform, but the corresponding argument has a
                                      varying return type.
                                - -6: An argument expression is not a constant nor a call.
                                - -8: One of the parameter types is uniform, but the corresponding
                                      argument or default is a call expression and the return type of
                                      the called function definition is effectively varying since the
                                      function definition itself is varying.
                                - -9: The material definition is invalid due to a module reload, see
                                      #is_valid() for diagnostics.
        :rtype: :py:class:`IMaterial_instance`
        :return: The created material instance, or ``NULL`` in case of errors.
        """
        return _pymdlsdk.IMaterial_definition_create_material_instance(self, arguments)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IMaterial_definition_compare_iid(self, iid)

    def get_element_type(self):
        r""" Indicates the actual scene element represented by interfaces derived from this interface."""
        return _pymdlsdk.IMaterial_definition_get_element_type(self)

    def create_attribute(self, name, type):
        r"""
        Creates a new attribute ``name`` of the type ``type``.

        :type name: string
        :param name:         The name of the attribute. The name must not contain ``"["``, ``"]"``, or
                                ``"``."
        :type type: string
        :param type:         The type of the attribute. See 'mi_neuray_types' for a list of
                                supported attribute types.
        :rtype: :py:class:`IData`
        :return: A pointer to the created attribute, or ``NULL`` in case of failure.
                                Reasons for failure are:
                                - ``name`` or ``type`` is invalid,
                                - there is already an attribute with the name ``name``, or
                                - ``name`` is the name of a reserved attribute and ``type`` does not match
                                  the required type(s) of such an attribute.
        """
        return _pymdlsdk.IMaterial_definition_create_attribute(self, name, type)

    def destroy_attribute(self, name):
        r"""
        Destroys the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute to destroy.
        :rtype: boolean
        :return: Returns ``true`` if the attribute has been successfully destroyed, and
                                ``false`` otherwise (there is no attribute with the name ``name)``.
        """
        return _pymdlsdk.IMaterial_definition_destroy_attribute(self, name)

    def access_attribute(self, name):
        r"""
        Returns a const pointer to the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also access parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: :py:class:`IData`
        :return: A pointer to the attribute, or ``NULL`` if there is no attribute with
                                the name ``name``.
        """
        return _pymdlsdk.IMaterial_definition_access_attribute(self, name)

    def edit_attribute(self, name):
        r"""
        Returns a mutable pointer to the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also access parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: :py:class:`IData`
        :return: A pointer to the attribute, or ``NULL`` if there is no attribute with
                                the name ``name``.
        """
        return _pymdlsdk.IMaterial_definition_edit_attribute(self, name)

    def is_attribute(self, name):
        r"""
        Indicates existence of an attribute.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also checks for parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: boolean
        :return: ``true`` if the attribute set contains this attribute (and the attribute
                                contains the requested array element or struct member),
                                ``false`` otherwise
        """
        return _pymdlsdk.IMaterial_definition_is_attribute(self, name)

    def get_attribute_type_name(self, name):
        r"""
        Returns the type of an attribute.

        See 'mi_neuray_types' for a list of supported attribute types.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also query parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: string
        :return: The type name of the attribute (or part thereof), or ``NULL`` if there
                                is no attribute with the name ``name``.

        Notes: The return value of this method is only valid until the next call of this method
              or any non-const methods on this instance.
        """
        return _pymdlsdk.IMaterial_definition_get_attribute_type_name(self, name)

    def set_attribute_propagation(self, name, value):
        r"""
        Sets the propagation type of the attribute ``name``.

        :rtype: int
        :return: 
                                -  0: Success.
                                - -1: Invalid parameters (``NULL`` pointer or invalid enum value).
                                - -2: There is no attribute with name ``name``.
        """
        return _pymdlsdk.IMaterial_definition_set_attribute_propagation(self, name, value)

    def get_attribute_propagation(self, name):
        r"""
        Returns the propagation type of the attribute ``name``.

        Notes: This method always returns #PROPAGATION_STANDARD in case of errors.
        """
        return _pymdlsdk.IMaterial_definition_get_attribute_propagation(self, name)

    def enumerate_attributes(self, index):
        r"""
        Returns the name of the attribute indicated by ``index``.

        :type index: int
        :param index:        The index of the attribute.
        :rtype: string
        :return: The name of the attribute indicated by ``index``, or ``NULL`` if ``index``
                                is out of bounds.
        """
        return _pymdlsdk.IMaterial_definition_enumerate_attributes(self, index)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IMaterial_definition__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IMaterial_definition__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IMaterial_definition_get_iid(self)

# Register IMaterial_definition in _pymdlsdk:
_pymdlsdk.IMaterial_definition_swigregister(IMaterial_definition)

def IMaterial_definition_IID():
    return _pymdlsdk.IMaterial_definition_IID()

def IMaterial_definition__get_interface(iface):
    return _pymdlsdk.IMaterial_definition__get_interface(iface)

class IMaterial_instance(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IMaterial_instance_swiginit(self, _pymdlsdk.new_IMaterial_instance(*args))
    __swig_destroy__ = _pymdlsdk.delete_IMaterial_instance

    def __deref__(self):
        return _pymdlsdk.IMaterial_instance___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IMaterial_instance___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IMaterial_instance_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IMaterial_instance___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IMaterial_instance___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IMaterial_instance_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IMaterial_instance_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IMaterial_instance__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_material_definition(self):
        r"""
        Returns the DB name of the corresponding material definition.

        The type of the material definition is #mi::neuraylib::IMaterial_definition.

        Notes: The DB name of the material definition is different from its MDL name (see
              #get_mdl_material_definition()).
        """
        return _pymdlsdk.IMaterial_instance_get_material_definition(self)

    def get_mdl_material_definition(self):
        r"""
        Returns the MDL name of the corresponding material definition.

        Notes: The MDL name of the material definition is different from the name of the DB element
              (see #get_material_definition()).
        """
        return _pymdlsdk.IMaterial_instance_get_mdl_material_definition(self)

    def get_return_type(self):
        r""" Returns the return type of the corresponding material definition (the fixed material type)."""
        return _pymdlsdk.IMaterial_instance_get_return_type(self)

    def get_parameter_count(self):
        r""" Returns the number of parameters."""
        return _pymdlsdk.IMaterial_instance_get_parameter_count(self)

    def get_parameter_name(self, index):
        r"""
        Returns the name of the parameter at ``index``.

        :type index: int
        :param index:        The index of the parameter.
        :rtype: string
        :return: The name of the parameter, or ``NULL`` if ``index`` is out of range.
        """
        return _pymdlsdk.IMaterial_instance_get_parameter_name(self, index)

    def get_parameter_index(self, name):
        r"""
        Returns the index position of a parameter.

        :type name: string
        :param name:         The name of the parameter.
        :rtype: int
        :return: The index of the parameter, or -1 if ``name`` is invalid.
        """
        return _pymdlsdk.IMaterial_instance_get_parameter_index(self, name)

    def get_parameter_types(self):
        r""" Returns the types of all parameters."""
        return _pymdlsdk.IMaterial_instance_get_parameter_types(self)

    def get_arguments(self):
        r""" Returns all arguments."""
        return _pymdlsdk.IMaterial_instance_get_arguments(self)

    def set_arguments(self, arguments):
        r"""
        Sets multiple arguments.

        :type arguments: :py:class:`IExpression_list`
        :param arguments:    The arguments. Note that the expressions are copied. This copy operation
                                is a shallow copy, e.g., DB elements referenced in call expressions are
                                *not* copied.
        :rtype: int
        :return: 
                                -  0: Success.
                                - -1: Invalid parameters (``NULL`` pointer).
                                - -2: One of the parameters in ``arguments`` does not exist.
                                - -3: One of the argument types does not match the corresponding
                                      parameter type.
                                - -4: The material instance is immutable (because it appears in a
                                      default of a material definition).
                                - -5: One of the parameter types is uniform, but the corresponding
                                      argument type is varying.
                                - -6: One of the arguments is not a constant nor a call.
                                - -7: One of the arguments contains references to DB elements in a scope
                                      that is more private scope than the scope of this material
                                      instance.
                                - -8: One of the parameter types is uniform, but the corresponding
                                      argument is a call expression and the return type of the
                                      called function definition is effectively varying since the
                                      function definition itself is varying.
        """
        return _pymdlsdk.IMaterial_instance_set_arguments(self, arguments)

    def set_argument(self, *args):
        r"""
        *Overload 1:*
        Sets the argument at ``index``.

        :type index: int
        :param index:        The index of the argument.
        :type argument: :py:class:`IExpression`
        :param argument:     The argument. Note that the expression is copied. This copy operation
                                is a shallow copy, e.g., DB elements referenced in call expressions are
                                *not* copied.
        :rtype: int
        :return: 
                                -  0: Success.
                                - -1: Invalid parameters (``NULL`` pointer).
                                - -2: Parameter ``index`` does not exist.
                                - -3: The argument type does not match the parameter type.
                                - -4: The material instance is immutable (because it appears in a
                                      default of a material definition).
                                - -5: The parameter type is uniform, but the argument type is varying.
                                - -6: The argument expression is not a constant nor a call.
                                - -7: The argument contains references to DB elements in a scope that is
                                      more private scope than the scope of this material instance.
                                - -8: The parameter types is uniform, but the argument is a call
                                      expression and the return type of the called function definition
                                      is effectively varying since the function definition itself is
                                      varying.

        |

        *Overload 2:*
        Sets an argument identified by name.

        :type name: string
        :param name:         The name of the parameter.
        :type argument: :py:class:`IExpression`
        :param argument:     The argument. Note that the expression is copied. This copy operation
                                is a shallow copy, e.g., DB elements referenced in call expressions are
                                *not* copied.
        :rtype: int
        :return: 
                                -  0: Success.
                                - -1: Invalid parameters (``NULL`` pointer).
                                - -2: Parameter ``name`` does not exist.
                                - -3: The argument type does not match the parameter type.
                                - -4: The material instance is immutable (because it appears in a
                                      default of a material definition).
                                - -5: The parameter type is uniform, but the argument type is varying.
                                - -6: The argument expression is not a constant nor a call.
                                - -7: The argument contains references to DB elements in a scope that is
                                      more private scope than the scope of this material instance.
                                - -8: The parameter types is uniform, but the argument is a call
                                      expression and the return type of the called function definition
                                      is effectively varying since the function definition itself is
                                      varying.
        """
        return _pymdlsdk.IMaterial_instance_set_argument(self, *args)

    def is_default(self):
        r"""
        Indicates, if this material instance acts as a default argument of a material or
        function definition.

        Defaults are immutable, their arguments cannot be changed and they cannot be used
        in call expressions.

        :rtype: boolean
        :return: true, if this material instance is a default, false otherwise.
        """
        return _pymdlsdk.IMaterial_instance_is_default(self)

    def is_valid(self, context):
        r"""
        Returns ``true`` if this material instance and all its arguments point to valid
        material and function definitions, ``false`` otherwise.

        Material and function definitions can become invalid due to a module reload.

        See also: #mi::neuraylib::IModule::reload(), #mi::neuraylib::IMaterial_instance::repair()

        :type context: :py:class:`IMdl_execution_context`
        :param context:  Execution context that can be queried for error messages
                            after the operation has finished. Can be ``NULL``.
        :rtype: boolean
        :return: 
                 - ``true``:  The instance is valid.
                 - ``false``: The instance is invalid.
        """
        return _pymdlsdk.IMaterial_instance_is_valid(self, context)

    def repair(self, flags, context):
        r"""
        Attempts to repair an invalid material instance.

        :type flags: int
        :param flags:    Repair options, see #mi::neuraylib::Mdl_repair_options.
        :type context: :py:class:`IMdl_execution_context`
        :param context:  Execution context that can be queried for error messages
                            after the operation has finished. Can be ``NULL``.
        :rtype: int
        :return: 
                -   0:   Success.
                -  -1:   Repair failed. Check the ``context`` for details.
        """
        return _pymdlsdk.IMaterial_instance_repair(self, flags, context)

    def create_compiled_material(self, flags, context=None):
        r"""
        Creates a compiled material.

        :type flags: int
        :param flags:          A bitmask of flags of type #Compilation_options.
        :type context: :py:class:`IMdl_execution_context`, inout, optional
        :param context: An optional pointer to an execution context which can be used to pass
                                  compilation options to the MDL compiler. The following options are
                                  supported for this operation:
                                  - #mi::Float32 "meters_per_scene_unit": The conversion ratio between
                                    meters and scene units for this material. Default: 1.0f.
                                  - #mi::Float32 "wavelength_min": The smallest supported wavelength.
                                    Default: 380.0f.
                                  - #mi::Float32 "wavelength_max": The largest supported wavelength.
                                    Default: 780.0f.
                                  .
                                  The following options are supported in class compilation mode:
                                  - ``bool`` "fold_ternary_on_df": Fold all ternary operators of *df
                                    types. Default: ``false``.
                                  - ``bool`` "fold_all_bool_parameters": Fold all bool parameters.
                                    Default: ``false``.
                                  - ``bool`` "fold_all_enum_parameters": Fold all enum parameters.
                                    Default: ``false``.
                                  - #mi::base::IInterface *"fold_parameters": A static or dynamic array
                                    of strings of the parameters to fold. The names of the parameters
                                    are those that would otherwise be reported in
                                    #mi::neuraylib::ICompiled_material::get_parameter_name().
                                    Default: ``NULL``
                                  - ``bool`` "fold_trivial_cutout_opacity": Fold the expression for
                                    geometry.cutout_opacity if it evaluates to a constant with value
                                    0.0f or 1.0f. Default: ``false``.
                                  - ``bool`` "fold_transparent_layers": Calls to the functions
                                    ``df::weighted_layer()``, ``df::fresnel_layer()``,
                                    ``df::custom_curve_layer()``, ``df::measured_curve_layer()``, and
                                    their equivalents with color weights, are replaced by their
                                    ``base`` argument, if the ``weight`` argument evaluates to a constant
                                    with value 0.0f, and the ``layer`` argument is one of
                                    ``df::diffuse_transmission_bsdf()``, ``df::specular_bsdf()``,
                                    ``df::simple_glossy_bsdf()``, or ``df::microfacet_*_bsdf()``, and
                                    the ``scatter_mode`` argument (if present) is either
                                    ``df::scatter_transmit`` or ``df::scatter_reflect_transmit``.
                                    In addition, the ``layer`` argument might be a combination of such
                                    BSDFs using the ternary operator.
                                  .
                                  During material compilation, messages like errors and warnings will
                                  be passed to the context for later evaluation by the caller. Possible
                                  error conditions:
                                  - Type mismatch, call of an unsuitable DB element, or call cycle in
                                    the graph of this material instance.
                                  - The thin-walled material instance has different transmission for
                                    surface and backface.
                                  - An argument type of the graph of this material instance is varying
                                    but the corresponding parameter type is uniform.
                                  - An element in the array for the context option
                                    "fold_parameters" does not have the type #mi::IString.
        :rtype: mi::neuraylib::ICompiled_material
        :return: The corresponding compiled material, or ``NULL`` in case of failure.
        """
        return _pymdlsdk.IMaterial_instance_create_compiled_material(self, flags, context)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IMaterial_instance_compare_iid(self, iid)

    def get_element_type(self):
        r""" Indicates the actual scene element represented by interfaces derived from this interface."""
        return _pymdlsdk.IMaterial_instance_get_element_type(self)

    def create_attribute(self, name, type):
        r"""
        Creates a new attribute ``name`` of the type ``type``.

        :type name: string
        :param name:         The name of the attribute. The name must not contain ``"["``, ``"]"``, or
                                ``"``."
        :type type: string
        :param type:         The type of the attribute. See 'mi_neuray_types' for a list of
                                supported attribute types.
        :rtype: :py:class:`IData`
        :return: A pointer to the created attribute, or ``NULL`` in case of failure.
                                Reasons for failure are:
                                - ``name`` or ``type`` is invalid,
                                - there is already an attribute with the name ``name``, or
                                - ``name`` is the name of a reserved attribute and ``type`` does not match
                                  the required type(s) of such an attribute.
        """
        return _pymdlsdk.IMaterial_instance_create_attribute(self, name, type)

    def destroy_attribute(self, name):
        r"""
        Destroys the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute to destroy.
        :rtype: boolean
        :return: Returns ``true`` if the attribute has been successfully destroyed, and
                                ``false`` otherwise (there is no attribute with the name ``name)``.
        """
        return _pymdlsdk.IMaterial_instance_destroy_attribute(self, name)

    def access_attribute(self, name):
        r"""
        Returns a const pointer to the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also access parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: :py:class:`IData`
        :return: A pointer to the attribute, or ``NULL`` if there is no attribute with
                                the name ``name``.
        """
        return _pymdlsdk.IMaterial_instance_access_attribute(self, name)

    def edit_attribute(self, name):
        r"""
        Returns a mutable pointer to the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also access parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: :py:class:`IData`
        :return: A pointer to the attribute, or ``NULL`` if there is no attribute with
                                the name ``name``.
        """
        return _pymdlsdk.IMaterial_instance_edit_attribute(self, name)

    def is_attribute(self, name):
        r"""
        Indicates existence of an attribute.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also checks for parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: boolean
        :return: ``true`` if the attribute set contains this attribute (and the attribute
                                contains the requested array element or struct member),
                                ``false`` otherwise
        """
        return _pymdlsdk.IMaterial_instance_is_attribute(self, name)

    def get_attribute_type_name(self, name):
        r"""
        Returns the type of an attribute.

        See 'mi_neuray_types' for a list of supported attribute types.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also query parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: string
        :return: The type name of the attribute (or part thereof), or ``NULL`` if there
                                is no attribute with the name ``name``.

        Notes: The return value of this method is only valid until the next call of this method
              or any non-const methods on this instance.
        """
        return _pymdlsdk.IMaterial_instance_get_attribute_type_name(self, name)

    def set_attribute_propagation(self, name, value):
        r"""
        Sets the propagation type of the attribute ``name``.

        :rtype: int
        :return: 
                                -  0: Success.
                                - -1: Invalid parameters (``NULL`` pointer or invalid enum value).
                                - -2: There is no attribute with name ``name``.
        """
        return _pymdlsdk.IMaterial_instance_set_attribute_propagation(self, name, value)

    def get_attribute_propagation(self, name):
        r"""
        Returns the propagation type of the attribute ``name``.

        Notes: This method always returns #PROPAGATION_STANDARD in case of errors.
        """
        return _pymdlsdk.IMaterial_instance_get_attribute_propagation(self, name)

    def enumerate_attributes(self, index):
        r"""
        Returns the name of the attribute indicated by ``index``.

        :type index: int
        :param index:        The index of the attribute.
        :rtype: string
        :return: The name of the attribute indicated by ``index``, or ``NULL`` if ``index``
                                is out of bounds.
        """
        return _pymdlsdk.IMaterial_instance_enumerate_attributes(self, index)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IMaterial_instance__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IMaterial_instance__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IMaterial_instance_get_iid(self)

# Register IMaterial_instance in _pymdlsdk:
_pymdlsdk.IMaterial_instance_swigregister(IMaterial_instance)

def IMaterial_instance_IID():
    return _pymdlsdk.IMaterial_instance_IID()

def IMaterial_instance__get_interface(iface):
    return _pymdlsdk.IMaterial_instance__get_interface(iface)

class ITexture(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.ITexture_swiginit(self, _pymdlsdk.new_ITexture(*args))
    __swig_destroy__ = _pymdlsdk.delete_ITexture

    def __deref__(self):
        return _pymdlsdk.ITexture___deref__(self)

    def __ref__(self):
        return _pymdlsdk.ITexture___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.ITexture_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.ITexture___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.ITexture___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.ITexture_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.ITexture_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.ITexture__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def set_image(self, name):
        r"""
        Sets the referenced image.

        :rtype: int
        :return: 
                      -  0: Success.
                      - -1: Invalid parameters (``NULL`` pointer).
                      - -2: There is no element with that name.
                      - -3: The element can not be referenced because it is in a more private scope
                            than the texture.
                      - -4: The element is not an image.
        """
        return _pymdlsdk.ITexture_set_image(self, name)

    def get_image(self):
        r"""
        Returns the referenced image.

        :rtype: string
        :return: The referenced image, or ``NULL`` if no image is referenced.
        """
        return _pymdlsdk.ITexture_get_image(self)

    def set_gamma(self, gamma):
        r"""
        Sets the gamma value of this texture.

        The gamma value of the texture is an override for the gamma value of the underlying
        image. The special value 0.0 means that the override is not set.

        This override value is also used when MDL source code is to be generated:
        - a value of 1.0 is converted to ``"::tex::gamma_linear"``,
        - a value of 2.2 is converted to ``"::tex::gamma_srgb"``, and
        - all other values are converted to ``"::tex::gamma_default"``.
        Therefore, if you want to avoid ``"::tex::gamma_default"`` in generated MDL source code, it
        makes sense to replicate the gamma value of the underlying image here (instead of not using
        the override).

        See also: #get_gamma(), #get_effective_gamma()
        """
        return _pymdlsdk.ITexture_set_gamma(self, gamma)

    def get_gamma(self):
        r"""
        Returns the gamma value of this texture.

        See also: #set_gamma(), #get_effective_gamma()
        """
        return _pymdlsdk.ITexture_get_gamma(self)

    def get_effective_gamma(self, uvtile_id=0):
        r"""
        Returns the effective gamma value.

        :type uvtile_id: int, optional
        :param uvtile_id:   The uv-tile id of the texture the gamma value is requested for when no
                               override is set.

        Returns the gamma value of this texture, unless no override is set. In this case the
        gamma value of the underlying image at the given uvtile index is returned. If no such image
        exists, 0.0 is returned.

        See also: #set_gamma(), #get_gamma()
        """
        return _pymdlsdk.ITexture_get_effective_gamma(self, uvtile_id)

    def set_compression(self, compression):
        r"""
        Sets the texture compression method.

        Notes: This setting does not affect the referenced image itself, it only affects image data
              that has been processed by the render modes. For example, in order to save GPU memory
              processed image data can be compressed before being uploaded to the GPU.

        See also: #mi::neuraylib::Texture_compression
        """
        return _pymdlsdk.ITexture_set_compression(self, compression)

    def get_compression(self):
        r"""
        Returns the texture compression method.

        Notes: This setting does not affect the referenced image itself, it only affects image data
              that has been processed by the render modes. For example, in order to save GPU memory
              processed image data can be compressed before being uploaded to the GPU.

        See also: #mi::neuraylib::Texture_compression
        """
        return _pymdlsdk.ITexture_get_compression(self)

    def set_volume(self, name):
        r"""
        Sets the referenced volume.

        :rtype: int
        :return: 
                      -  0: Success.
                      - -1: Invalid parameters (``NULL`` pointer).
                      - -2: There is no element with that name.
                      - -3: The element can not be referenced because it is in a more private scope
                            than the texture.
                      - -4: The element is not a volume.
        """
        return _pymdlsdk.ITexture_set_volume(self, name)

    def get_volume(self):
        r"""
        Returns the referenced volume data.

        :rtype: string
        :return: The referenced volume, or ``NULL`` if no volume is referenced.
        """
        return _pymdlsdk.ITexture_get_volume(self)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.ITexture_compare_iid(self, iid)

    def get_element_type(self):
        r""" Indicates the actual scene element represented by interfaces derived from this interface."""
        return _pymdlsdk.ITexture_get_element_type(self)

    def create_attribute(self, name, type):
        r"""
        Creates a new attribute ``name`` of the type ``type``.

        :type name: string
        :param name:         The name of the attribute. The name must not contain ``"["``, ``"]"``, or
                                ``"``."
        :type type: string
        :param type:         The type of the attribute. See 'mi_neuray_types' for a list of
                                supported attribute types.
        :rtype: :py:class:`IData`
        :return: A pointer to the created attribute, or ``NULL`` in case of failure.
                                Reasons for failure are:
                                - ``name`` or ``type`` is invalid,
                                - there is already an attribute with the name ``name``, or
                                - ``name`` is the name of a reserved attribute and ``type`` does not match
                                  the required type(s) of such an attribute.
        """
        return _pymdlsdk.ITexture_create_attribute(self, name, type)

    def destroy_attribute(self, name):
        r"""
        Destroys the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute to destroy.
        :rtype: boolean
        :return: Returns ``true`` if the attribute has been successfully destroyed, and
                                ``false`` otherwise (there is no attribute with the name ``name)``.
        """
        return _pymdlsdk.ITexture_destroy_attribute(self, name)

    def access_attribute(self, name):
        r"""
        Returns a const pointer to the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also access parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: :py:class:`IData`
        :return: A pointer to the attribute, or ``NULL`` if there is no attribute with
                                the name ``name``.
        """
        return _pymdlsdk.ITexture_access_attribute(self, name)

    def edit_attribute(self, name):
        r"""
        Returns a mutable pointer to the attribute ``name``.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also access parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: :py:class:`IData`
        :return: A pointer to the attribute, or ``NULL`` if there is no attribute with
                                the name ``name``.
        """
        return _pymdlsdk.ITexture_edit_attribute(self, name)

    def is_attribute(self, name):
        r"""
        Indicates existence of an attribute.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also checks for parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: boolean
        :return: ``true`` if the attribute set contains this attribute (and the attribute
                                contains the requested array element or struct member),
                                ``false`` otherwise
        """
        return _pymdlsdk.ITexture_is_attribute(self, name)

    def get_attribute_type_name(self, name):
        r"""
        Returns the type of an attribute.

        See 'mi_neuray_types' for a list of supported attribute types.

        :type name: string
        :param name:         The name of the attribute. In addition, you can also query parts of
                                array or structure attributes directly. For an array element add
                                the index in square brackets to the attribute name. For a structure
                                member add a dot and the name of the structure member to the attribute
                                name.
        :rtype: string
        :return: The type name of the attribute (or part thereof), or ``NULL`` if there
                                is no attribute with the name ``name``.

        Notes: The return value of this method is only valid until the next call of this method
              or any non-const methods on this instance.
        """
        return _pymdlsdk.ITexture_get_attribute_type_name(self, name)

    def set_attribute_propagation(self, name, value):
        r"""
        Sets the propagation type of the attribute ``name``.

        :rtype: int
        :return: 
                                -  0: Success.
                                - -1: Invalid parameters (``NULL`` pointer or invalid enum value).
                                - -2: There is no attribute with name ``name``.
        """
        return _pymdlsdk.ITexture_set_attribute_propagation(self, name, value)

    def get_attribute_propagation(self, name):
        r"""
        Returns the propagation type of the attribute ``name``.

        Notes: This method always returns #PROPAGATION_STANDARD in case of errors.
        """
        return _pymdlsdk.ITexture_get_attribute_propagation(self, name)

    def enumerate_attributes(self, index):
        r"""
        Returns the name of the attribute indicated by ``index``.

        :type index: int
        :param index:        The index of the attribute.
        :rtype: string
        :return: The name of the attribute indicated by ``index``, or ``NULL`` if ``index``
                                is out of bounds.
        """
        return _pymdlsdk.ITexture_enumerate_attributes(self, index)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.ITexture__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.ITexture__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.ITexture_get_iid(self)

# Register ITexture in _pymdlsdk:
_pymdlsdk.ITexture_swigregister(ITexture)

def ITexture_IID():
    return _pymdlsdk.ITexture_IID()

def ITexture__get_interface(iface):
    return _pymdlsdk.ITexture__get_interface(iface)

class IType(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IType_swiginit(self, _pymdlsdk.new_IType(*args))
    __swig_destroy__ = _pymdlsdk.delete_IType

    def __deref__(self):
        return _pymdlsdk.IType___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IType___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IType_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IType___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IType___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IType_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IType_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IType__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    class Kind(Enum) :
        TK_ALIAS = _pymdlsdk._IType_TK_ALIAS
        TK_BOOL = _pymdlsdk._IType_TK_BOOL
        TK_INT = _pymdlsdk._IType_TK_INT
        TK_ENUM = _pymdlsdk._IType_TK_ENUM
        TK_FLOAT = _pymdlsdk._IType_TK_FLOAT
        TK_DOUBLE = _pymdlsdk._IType_TK_DOUBLE
        TK_STRING = _pymdlsdk._IType_TK_STRING
        TK_VECTOR = _pymdlsdk._IType_TK_VECTOR
        TK_MATRIX = _pymdlsdk._IType_TK_MATRIX
        TK_COLOR = _pymdlsdk._IType_TK_COLOR
        TK_ARRAY = _pymdlsdk._IType_TK_ARRAY
        TK_STRUCT = _pymdlsdk._IType_TK_STRUCT
        TK_TEXTURE = _pymdlsdk._IType_TK_TEXTURE
        TK_LIGHT_PROFILE = _pymdlsdk._IType_TK_LIGHT_PROFILE
        TK_BSDF_MEASUREMENT = _pymdlsdk._IType_TK_BSDF_MEASUREMENT
        TK_BSDF = _pymdlsdk._IType_TK_BSDF
        TK_HAIR_BSDF = _pymdlsdk._IType_TK_HAIR_BSDF
        TK_EDF = _pymdlsdk._IType_TK_EDF
        TK_VDF = _pymdlsdk._IType_TK_VDF


    def get_kind(self, *args):
        return IType.Kind(self._get_kind(*args))


    def _get_kind(self):
        r""" Returns the kind of type."""
        return _pymdlsdk.IType__get_kind(self)

    def get_all_type_modifiers(self):
        r"""
        Returns all type modifiers of a type.

        Returns 0 if ``this`` is not an alias. Otherwise, the method follows the chain of aliases by
        calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind() returns
        #TK_ALIAS. The method returns the union of
        #mi::neuraylib::IType_alias::get_type_modifiers() calls on ``this`` and all intermediate
        aliases.
        """
        return _pymdlsdk.IType_get_all_type_modifiers(self)

    def skip_all_type_aliases(self):
        r"""
        Returns the base type.

        Returns ``this`` if ``this`` is not an alias. Otherwise, the method follows the chain of
        aliases by calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind()
        returns #TK_ALIAS. The method returns the first non-alias type.
        """
        return _pymdlsdk.IType_skip_all_type_aliases(self)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IType_compare_iid(self, iid)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IType__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IType__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IType_get_iid(self)

# Register IType in _pymdlsdk:
_pymdlsdk.IType_swigregister(IType)

def IType_IID():
    return _pymdlsdk.IType_IID()

def IType__get_interface(iface):
    return _pymdlsdk.IType__get_interface(iface)

class IType_alias(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IType_alias_swiginit(self, _pymdlsdk.new_IType_alias(*args))
    __swig_destroy__ = _pymdlsdk.delete_IType_alias

    def __deref__(self):
        return _pymdlsdk.IType_alias___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IType_alias___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IType_alias_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IType_alias___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IType_alias___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IType_alias_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IType_alias_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IType_alias__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IType.Kind(self._get_kind(*args))


    def get_aliased_type(self):
        r""" Returns the type aliased by this type."""
        return _pymdlsdk.IType_alias_get_aliased_type(self)

    def get_type_modifiers(self):
        r""" Returns the modifiers of this type."""
        return _pymdlsdk.IType_alias_get_type_modifiers(self)

    def get_symbol(self):
        r""" Returns the qualified name of the type, or ``NULL`` if no such name exists."""
        return _pymdlsdk.IType_alias_get_symbol(self)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IType_alias_compare_iid(self, iid)

    def _get_kind(self):
        r""" Returns the kind of type."""
        return _pymdlsdk.IType_alias__get_kind(self)

    def get_all_type_modifiers(self):
        r"""
        Returns all type modifiers of a type.

        Returns 0 if ``this`` is not an alias. Otherwise, the method follows the chain of aliases by
        calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind() returns
        #TK_ALIAS. The method returns the union of
        #mi::neuraylib::IType_alias::get_type_modifiers() calls on ``this`` and all intermediate
        aliases.
        """
        return _pymdlsdk.IType_alias_get_all_type_modifiers(self)

    def skip_all_type_aliases(self):
        r"""
        Returns the base type.

        Returns ``this`` if ``this`` is not an alias. Otherwise, the method follows the chain of
        aliases by calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind()
        returns #TK_ALIAS. The method returns the first non-alias type.
        """
        return _pymdlsdk.IType_alias_skip_all_type_aliases(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IType_alias__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IType_alias__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IType_alias_get_iid(self)

# Register IType_alias in _pymdlsdk:
_pymdlsdk.IType_alias_swigregister(IType_alias)

def IType_alias_IID():
    return _pymdlsdk.IType_alias_IID()

def IType_alias__get_interface(iface):
    return _pymdlsdk.IType_alias__get_interface(iface)

class IType_array(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IType_array_swiginit(self, _pymdlsdk.new_IType_array(*args))
    __swig_destroy__ = _pymdlsdk.delete_IType_array

    def __deref__(self):
        return _pymdlsdk.IType_array___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IType_array___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IType_array_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IType_array___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IType_array___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IType_array_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IType_array_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IType_array__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IType.Kind(self._get_kind(*args))


    def get_element_type(self):
        r""" Returns the type of the array elements."""
        return _pymdlsdk.IType_array_get_element_type(self)

    def is_immediate_sized(self):
        r""" Indicates whether the array is immediate-sized or deferred-sized."""
        return _pymdlsdk.IType_array_is_immediate_sized(self)

    def get_size(self):
        r""" Returns the size of the array in case of immediate-sized arrays, and -1 otherwise."""
        return _pymdlsdk.IType_array_get_size(self)

    def get_deferred_size(self):
        r"""
        Returns the abstract size of the array in case of deferred-sized arrays, and ``NULL``
        otherwise.

        Note that the empty string is a valid return value for deferred-sized arrays.
        """
        return _pymdlsdk.IType_array_get_deferred_size(self)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IType_array_compare_iid(self, iid)

    def get_component_type(self, index):
        r""" Returns the component type at ``index``."""
        return _pymdlsdk.IType_array_get_component_type(self, index)

    def _get_kind(self):
        r""" Returns the kind of type."""
        return _pymdlsdk.IType_array__get_kind(self)

    def get_all_type_modifiers(self):
        r"""
        Returns all type modifiers of a type.

        Returns 0 if ``this`` is not an alias. Otherwise, the method follows the chain of aliases by
        calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind() returns
        #TK_ALIAS. The method returns the union of
        #mi::neuraylib::IType_alias::get_type_modifiers() calls on ``this`` and all intermediate
        aliases.
        """
        return _pymdlsdk.IType_array_get_all_type_modifiers(self)

    def skip_all_type_aliases(self):
        r"""
        Returns the base type.

        Returns ``this`` if ``this`` is not an alias. Otherwise, the method follows the chain of
        aliases by calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind()
        returns #TK_ALIAS. The method returns the first non-alias type.
        """
        return _pymdlsdk.IType_array_skip_all_type_aliases(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IType_array__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IType_array__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IType_array_get_iid(self)

# Register IType_array in _pymdlsdk:
_pymdlsdk.IType_array_swigregister(IType_array)

def IType_array_IID():
    return _pymdlsdk.IType_array_IID()

def IType_array__get_interface(iface):
    return _pymdlsdk.IType_array__get_interface(iface)

class IType_atomic(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IType_atomic_swiginit(self, _pymdlsdk.new_IType_atomic(*args))
    __swig_destroy__ = _pymdlsdk.delete_IType_atomic

    def __deref__(self):
        return _pymdlsdk.IType_atomic___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IType_atomic___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IType_atomic_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IType_atomic___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IType_atomic___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IType_atomic_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IType_atomic_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IType_atomic__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IType.Kind(self._get_kind(*args))


    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IType_atomic_compare_iid(self, iid)

    def _get_kind(self):
        r""" Returns the kind of type."""
        return _pymdlsdk.IType_atomic__get_kind(self)

    def get_all_type_modifiers(self):
        r"""
        Returns all type modifiers of a type.

        Returns 0 if ``this`` is not an alias. Otherwise, the method follows the chain of aliases by
        calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind() returns
        #TK_ALIAS. The method returns the union of
        #mi::neuraylib::IType_alias::get_type_modifiers() calls on ``this`` and all intermediate
        aliases.
        """
        return _pymdlsdk.IType_atomic_get_all_type_modifiers(self)

    def skip_all_type_aliases(self):
        r"""
        Returns the base type.

        Returns ``this`` if ``this`` is not an alias. Otherwise, the method follows the chain of
        aliases by calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind()
        returns #TK_ALIAS. The method returns the first non-alias type.
        """
        return _pymdlsdk.IType_atomic_skip_all_type_aliases(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IType_atomic__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IType_atomic__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IType_atomic_get_iid(self)

# Register IType_atomic in _pymdlsdk:
_pymdlsdk.IType_atomic_swigregister(IType_atomic)

def IType_atomic_IID():
    return _pymdlsdk.IType_atomic_IID()

def IType_atomic__get_interface(iface):
    return _pymdlsdk.IType_atomic__get_interface(iface)

class IType_bool(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IType_bool_swiginit(self, _pymdlsdk.new_IType_bool(*args))
    __swig_destroy__ = _pymdlsdk.delete_IType_bool

    def __deref__(self):
        return _pymdlsdk.IType_bool___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IType_bool___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IType_bool_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IType_bool___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IType_bool___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IType_bool_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IType_bool_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IType_bool__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IType.Kind(self._get_kind(*args))


    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IType_bool_compare_iid(self, iid)

    def _get_kind(self):
        r""" Returns the kind of type."""
        return _pymdlsdk.IType_bool__get_kind(self)

    def get_all_type_modifiers(self):
        r"""
        Returns all type modifiers of a type.

        Returns 0 if ``this`` is not an alias. Otherwise, the method follows the chain of aliases by
        calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind() returns
        #TK_ALIAS. The method returns the union of
        #mi::neuraylib::IType_alias::get_type_modifiers() calls on ``this`` and all intermediate
        aliases.
        """
        return _pymdlsdk.IType_bool_get_all_type_modifiers(self)

    def skip_all_type_aliases(self):
        r"""
        Returns the base type.

        Returns ``this`` if ``this`` is not an alias. Otherwise, the method follows the chain of
        aliases by calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind()
        returns #TK_ALIAS. The method returns the first non-alias type.
        """
        return _pymdlsdk.IType_bool_skip_all_type_aliases(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IType_bool__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IType_bool__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IType_bool_get_iid(self)

# Register IType_bool in _pymdlsdk:
_pymdlsdk.IType_bool_swigregister(IType_bool)

def IType_bool_IID():
    return _pymdlsdk.IType_bool_IID()

def IType_bool__get_interface(iface):
    return _pymdlsdk.IType_bool__get_interface(iface)

class IType_bsdf(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IType_bsdf_swiginit(self, _pymdlsdk.new_IType_bsdf(*args))
    __swig_destroy__ = _pymdlsdk.delete_IType_bsdf

    def __deref__(self):
        return _pymdlsdk.IType_bsdf___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IType_bsdf___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IType_bsdf_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IType_bsdf___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IType_bsdf___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IType_bsdf_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IType_bsdf_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IType_bsdf__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IType.Kind(self._get_kind(*args))


    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IType_bsdf_compare_iid(self, iid)

    def _get_kind(self):
        r""" Returns the kind of type."""
        return _pymdlsdk.IType_bsdf__get_kind(self)

    def get_all_type_modifiers(self):
        r"""
        Returns all type modifiers of a type.

        Returns 0 if ``this`` is not an alias. Otherwise, the method follows the chain of aliases by
        calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind() returns
        #TK_ALIAS. The method returns the union of
        #mi::neuraylib::IType_alias::get_type_modifiers() calls on ``this`` and all intermediate
        aliases.
        """
        return _pymdlsdk.IType_bsdf_get_all_type_modifiers(self)

    def skip_all_type_aliases(self):
        r"""
        Returns the base type.

        Returns ``this`` if ``this`` is not an alias. Otherwise, the method follows the chain of
        aliases by calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind()
        returns #TK_ALIAS. The method returns the first non-alias type.
        """
        return _pymdlsdk.IType_bsdf_skip_all_type_aliases(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IType_bsdf__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IType_bsdf__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IType_bsdf_get_iid(self)

# Register IType_bsdf in _pymdlsdk:
_pymdlsdk.IType_bsdf_swigregister(IType_bsdf)

def IType_bsdf_IID():
    return _pymdlsdk.IType_bsdf_IID()

def IType_bsdf__get_interface(iface):
    return _pymdlsdk.IType_bsdf__get_interface(iface)

class IType_bsdf_measurement(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IType_bsdf_measurement_swiginit(self, _pymdlsdk.new_IType_bsdf_measurement(*args))
    __swig_destroy__ = _pymdlsdk.delete_IType_bsdf_measurement

    def __deref__(self):
        return _pymdlsdk.IType_bsdf_measurement___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IType_bsdf_measurement___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IType_bsdf_measurement_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IType_bsdf_measurement___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IType_bsdf_measurement___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IType_bsdf_measurement_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IType_bsdf_measurement_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IType_bsdf_measurement__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IType.Kind(self._get_kind(*args))


    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IType_bsdf_measurement_compare_iid(self, iid)

    def _get_kind(self):
        r""" Returns the kind of type."""
        return _pymdlsdk.IType_bsdf_measurement__get_kind(self)

    def get_all_type_modifiers(self):
        r"""
        Returns all type modifiers of a type.

        Returns 0 if ``this`` is not an alias. Otherwise, the method follows the chain of aliases by
        calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind() returns
        #TK_ALIAS. The method returns the union of
        #mi::neuraylib::IType_alias::get_type_modifiers() calls on ``this`` and all intermediate
        aliases.
        """
        return _pymdlsdk.IType_bsdf_measurement_get_all_type_modifiers(self)

    def skip_all_type_aliases(self):
        r"""
        Returns the base type.

        Returns ``this`` if ``this`` is not an alias. Otherwise, the method follows the chain of
        aliases by calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind()
        returns #TK_ALIAS. The method returns the first non-alias type.
        """
        return _pymdlsdk.IType_bsdf_measurement_skip_all_type_aliases(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IType_bsdf_measurement__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IType_bsdf_measurement__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IType_bsdf_measurement_get_iid(self)

# Register IType_bsdf_measurement in _pymdlsdk:
_pymdlsdk.IType_bsdf_measurement_swigregister(IType_bsdf_measurement)

def IType_bsdf_measurement_IID():
    return _pymdlsdk.IType_bsdf_measurement_IID()

def IType_bsdf_measurement__get_interface(iface):
    return _pymdlsdk.IType_bsdf_measurement__get_interface(iface)

class IType_color(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IType_color_swiginit(self, _pymdlsdk.new_IType_color(*args))
    __swig_destroy__ = _pymdlsdk.delete_IType_color

    def __deref__(self):
        return _pymdlsdk.IType_color___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IType_color___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IType_color_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IType_color___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IType_color___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IType_color_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IType_color_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IType_color__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IType.Kind(self._get_kind(*args))


    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IType_color_compare_iid(self, iid)

    def get_component_type(self, index):
        r""" Returns the component type at ``index``."""
        return _pymdlsdk.IType_color_get_component_type(self, index)

    def get_size(self):
        r""" Returns the number of components."""
        return _pymdlsdk.IType_color_get_size(self)

    def _get_kind(self):
        r""" Returns the kind of type."""
        return _pymdlsdk.IType_color__get_kind(self)

    def get_all_type_modifiers(self):
        r"""
        Returns all type modifiers of a type.

        Returns 0 if ``this`` is not an alias. Otherwise, the method follows the chain of aliases by
        calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind() returns
        #TK_ALIAS. The method returns the union of
        #mi::neuraylib::IType_alias::get_type_modifiers() calls on ``this`` and all intermediate
        aliases.
        """
        return _pymdlsdk.IType_color_get_all_type_modifiers(self)

    def skip_all_type_aliases(self):
        r"""
        Returns the base type.

        Returns ``this`` if ``this`` is not an alias. Otherwise, the method follows the chain of
        aliases by calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind()
        returns #TK_ALIAS. The method returns the first non-alias type.
        """
        return _pymdlsdk.IType_color_skip_all_type_aliases(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IType_color__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IType_color__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IType_color_get_iid(self)

# Register IType_color in _pymdlsdk:
_pymdlsdk.IType_color_swigregister(IType_color)

def IType_color_IID():
    return _pymdlsdk.IType_color_IID()

def IType_color__get_interface(iface):
    return _pymdlsdk.IType_color__get_interface(iface)

class IType_compound(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IType_compound_swiginit(self, _pymdlsdk.new_IType_compound(*args))
    __swig_destroy__ = _pymdlsdk.delete_IType_compound

    def __deref__(self):
        return _pymdlsdk.IType_compound___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IType_compound___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IType_compound_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IType_compound___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IType_compound___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IType_compound_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IType_compound_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IType_compound__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IType.Kind(self._get_kind(*args))


    def get_component_type(self, index):
        r""" Returns the component type at ``index``."""
        return _pymdlsdk.IType_compound_get_component_type(self, index)

    def get_size(self):
        r""" Returns the number of components."""
        return _pymdlsdk.IType_compound_get_size(self)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IType_compound_compare_iid(self, iid)

    def _get_kind(self):
        r""" Returns the kind of type."""
        return _pymdlsdk.IType_compound__get_kind(self)

    def get_all_type_modifiers(self):
        r"""
        Returns all type modifiers of a type.

        Returns 0 if ``this`` is not an alias. Otherwise, the method follows the chain of aliases by
        calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind() returns
        #TK_ALIAS. The method returns the union of
        #mi::neuraylib::IType_alias::get_type_modifiers() calls on ``this`` and all intermediate
        aliases.
        """
        return _pymdlsdk.IType_compound_get_all_type_modifiers(self)

    def skip_all_type_aliases(self):
        r"""
        Returns the base type.

        Returns ``this`` if ``this`` is not an alias. Otherwise, the method follows the chain of
        aliases by calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind()
        returns #TK_ALIAS. The method returns the first non-alias type.
        """
        return _pymdlsdk.IType_compound_skip_all_type_aliases(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IType_compound__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IType_compound__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IType_compound_get_iid(self)

# Register IType_compound in _pymdlsdk:
_pymdlsdk.IType_compound_swigregister(IType_compound)

def IType_compound_IID():
    return _pymdlsdk.IType_compound_IID()

def IType_compound__get_interface(iface):
    return _pymdlsdk.IType_compound__get_interface(iface)

class IType_df(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IType_df_swiginit(self, _pymdlsdk.new_IType_df(*args))
    __swig_destroy__ = _pymdlsdk.delete_IType_df

    def __deref__(self):
        return _pymdlsdk.IType_df___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IType_df___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IType_df_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IType_df___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IType_df___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IType_df_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IType_df_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IType_df__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IType.Kind(self._get_kind(*args))


    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IType_df_compare_iid(self, iid)

    def _get_kind(self):
        r""" Returns the kind of type."""
        return _pymdlsdk.IType_df__get_kind(self)

    def get_all_type_modifiers(self):
        r"""
        Returns all type modifiers of a type.

        Returns 0 if ``this`` is not an alias. Otherwise, the method follows the chain of aliases by
        calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind() returns
        #TK_ALIAS. The method returns the union of
        #mi::neuraylib::IType_alias::get_type_modifiers() calls on ``this`` and all intermediate
        aliases.
        """
        return _pymdlsdk.IType_df_get_all_type_modifiers(self)

    def skip_all_type_aliases(self):
        r"""
        Returns the base type.

        Returns ``this`` if ``this`` is not an alias. Otherwise, the method follows the chain of
        aliases by calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind()
        returns #TK_ALIAS. The method returns the first non-alias type.
        """
        return _pymdlsdk.IType_df_skip_all_type_aliases(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IType_df__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IType_df__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IType_df_get_iid(self)

# Register IType_df in _pymdlsdk:
_pymdlsdk.IType_df_swigregister(IType_df)

def IType_df_IID():
    return _pymdlsdk.IType_df_IID()

def IType_df__get_interface(iface):
    return _pymdlsdk.IType_df__get_interface(iface)

class IType_double(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IType_double_swiginit(self, _pymdlsdk.new_IType_double(*args))
    __swig_destroy__ = _pymdlsdk.delete_IType_double

    def __deref__(self):
        return _pymdlsdk.IType_double___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IType_double___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IType_double_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IType_double___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IType_double___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IType_double_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IType_double_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IType_double__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IType.Kind(self._get_kind(*args))


    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IType_double_compare_iid(self, iid)

    def _get_kind(self):
        r""" Returns the kind of type."""
        return _pymdlsdk.IType_double__get_kind(self)

    def get_all_type_modifiers(self):
        r"""
        Returns all type modifiers of a type.

        Returns 0 if ``this`` is not an alias. Otherwise, the method follows the chain of aliases by
        calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind() returns
        #TK_ALIAS. The method returns the union of
        #mi::neuraylib::IType_alias::get_type_modifiers() calls on ``this`` and all intermediate
        aliases.
        """
        return _pymdlsdk.IType_double_get_all_type_modifiers(self)

    def skip_all_type_aliases(self):
        r"""
        Returns the base type.

        Returns ``this`` if ``this`` is not an alias. Otherwise, the method follows the chain of
        aliases by calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind()
        returns #TK_ALIAS. The method returns the first non-alias type.
        """
        return _pymdlsdk.IType_double_skip_all_type_aliases(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IType_double__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IType_double__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IType_double_get_iid(self)

# Register IType_double in _pymdlsdk:
_pymdlsdk.IType_double_swigregister(IType_double)

def IType_double_IID():
    return _pymdlsdk.IType_double_IID()

def IType_double__get_interface(iface):
    return _pymdlsdk.IType_double__get_interface(iface)

class IType_edf(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IType_edf_swiginit(self, _pymdlsdk.new_IType_edf(*args))
    __swig_destroy__ = _pymdlsdk.delete_IType_edf

    def __deref__(self):
        return _pymdlsdk.IType_edf___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IType_edf___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IType_edf_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IType_edf___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IType_edf___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IType_edf_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IType_edf_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IType_edf__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IType.Kind(self._get_kind(*args))


    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IType_edf_compare_iid(self, iid)

    def _get_kind(self):
        r""" Returns the kind of type."""
        return _pymdlsdk.IType_edf__get_kind(self)

    def get_all_type_modifiers(self):
        r"""
        Returns all type modifiers of a type.

        Returns 0 if ``this`` is not an alias. Otherwise, the method follows the chain of aliases by
        calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind() returns
        #TK_ALIAS. The method returns the union of
        #mi::neuraylib::IType_alias::get_type_modifiers() calls on ``this`` and all intermediate
        aliases.
        """
        return _pymdlsdk.IType_edf_get_all_type_modifiers(self)

    def skip_all_type_aliases(self):
        r"""
        Returns the base type.

        Returns ``this`` if ``this`` is not an alias. Otherwise, the method follows the chain of
        aliases by calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind()
        returns #TK_ALIAS. The method returns the first non-alias type.
        """
        return _pymdlsdk.IType_edf_skip_all_type_aliases(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IType_edf__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IType_edf__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IType_edf_get_iid(self)

# Register IType_edf in _pymdlsdk:
_pymdlsdk.IType_edf_swigregister(IType_edf)

def IType_edf_IID():
    return _pymdlsdk.IType_edf_IID()

def IType_edf__get_interface(iface):
    return _pymdlsdk.IType_edf__get_interface(iface)

class IType_enumeration(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IType_enumeration_swiginit(self, _pymdlsdk.new_IType_enumeration(*args))
    __swig_destroy__ = _pymdlsdk.delete_IType_enumeration

    def __deref__(self):
        return _pymdlsdk.IType_enumeration___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IType_enumeration___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IType_enumeration_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IType_enumeration___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IType_enumeration___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IType_enumeration_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IType_enumeration_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IType_enumeration__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IType.Kind(self._get_kind(*args))


    def get_symbol(self):
        r""" Returns the qualified name of this enum type."""
        return _pymdlsdk.IType_enumeration_get_symbol(self)

    def get_size(self):
        r""" Returns the number of values."""
        return _pymdlsdk.IType_enumeration_get_size(self)

    def get_value_name(self, index):
        r"""
        Returns the name of a value.

        :type index: int
        :param index:         The index of the value.
        :rtype: string
        :return: The unqualified name of the value, or ``NULL`` if ``index`` is invalid.
        """
        return _pymdlsdk.IType_enumeration_get_value_name(self, index)

    def get_value_code_with_ret(self, index):
        r"""
        Returns the code of a value.

        :type index: int
        :param index:         The index of the value.
        :type errors: int, out, optional
        :param errors:
                                 -  0: Success.
                                 - -1: ``index`` is invalid.
        :rtype: int
        :return: The code of the value, or 0 in case of errors.
        """
        return _pymdlsdk.IType_enumeration_get_value_code_with_ret(self, index)

    def get_value_code(self, index):
        r"""
        Returns the code of a value.

        :type index: int
        :param index:         The index of the value.
        :param errors:
                                 -  0: Success.
                                 - -1: ``index`` is invalid.
        :rtype: int
        :return: The code of the value, or 0 in case of errors.
        """
        return _pymdlsdk.IType_enumeration_get_value_code(self, index)

    def find_value(self, *args):
        r"""
        *Overload 1:*
        Returns the index of a value in linear time.

        :type name: string
        :param name:          The unqualified name of the value.
        :rtype: int
        :return: The index of the value, or -1 if there is no such value.

        |

        *Overload 2:*
        Returns the index of a value in linear time.

        :type code: int
        :param code:          The code of the value.
        :rtype: int
        :return: The index of the value, or -1 if there is no such value.
        """
        return _pymdlsdk.IType_enumeration_find_value(self, *args)

    def get_predefined_id(self):
        r""" If this enum is a predefined one, return its ID, else EID_USER."""
        return _pymdlsdk.IType_enumeration_get_predefined_id(self)

    def get_annotations(self):
        r"""
        Returns the annotations of the enum type.

        :rtype: :py:class:`IAnnotation_block`
        :return: The annotations of the enum type, or ``NULL`` if there are no
                                 annotations for the enum type.
        """
        return _pymdlsdk.IType_enumeration_get_annotations(self)

    def get_value_annotations(self, index):
        r"""
        Returns the annotations of a value.

        :type index: int
        :param index:         The index of the value.
        :rtype: :py:class:`IAnnotation_block`
        :return: The annotation of that value, or ``NULL`` if ``index`` is out of bounds,
                                 or there are no annotations for that value.
        """
        return _pymdlsdk.IType_enumeration_get_value_annotations(self, index)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IType_enumeration_compare_iid(self, iid)

    def _get_kind(self):
        r""" Returns the kind of type."""
        return _pymdlsdk.IType_enumeration__get_kind(self)

    def get_all_type_modifiers(self):
        r"""
        Returns all type modifiers of a type.

        Returns 0 if ``this`` is not an alias. Otherwise, the method follows the chain of aliases by
        calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind() returns
        #TK_ALIAS. The method returns the union of
        #mi::neuraylib::IType_alias::get_type_modifiers() calls on ``this`` and all intermediate
        aliases.
        """
        return _pymdlsdk.IType_enumeration_get_all_type_modifiers(self)

    def skip_all_type_aliases(self):
        r"""
        Returns the base type.

        Returns ``this`` if ``this`` is not an alias. Otherwise, the method follows the chain of
        aliases by calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind()
        returns #TK_ALIAS. The method returns the first non-alias type.
        """
        return _pymdlsdk.IType_enumeration_skip_all_type_aliases(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IType_enumeration__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IType_enumeration__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IType_enumeration_get_iid(self)

# Register IType_enumeration in _pymdlsdk:
_pymdlsdk.IType_enumeration_swigregister(IType_enumeration)

def IType_enumeration_IID():
    return _pymdlsdk.IType_enumeration_IID()

def IType_enumeration__get_interface(iface):
    return _pymdlsdk.IType_enumeration__get_interface(iface)

class IType_factory(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IType_factory_swiginit(self, _pymdlsdk.new_IType_factory(*args))
    __swig_destroy__ = _pymdlsdk.delete_IType_factory

    def __deref__(self):
        return _pymdlsdk.IType_factory___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IType_factory___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IType_factory_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IType_factory___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IType_factory___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IType_factory_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IType_factory_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IType_factory__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def create_alias(self, type, modifiers, symbol):
        r""" Creates a new instance of the type alias."""
        return _pymdlsdk.IType_factory_create_alias(self, type, modifiers, symbol)

    def create_bool(self):
        r""" Creates a new instance of the type boolean."""
        return _pymdlsdk.IType_factory_create_bool(self)

    def create_int(self):
        r""" Creates a new instance of the type int."""
        return _pymdlsdk.IType_factory_create_int(self)

    def create_enum(self, symbol):
        r""" Returns a registered enum type, or ``NULL`` if ``symbol`` is invalid or unknown."""
        return _pymdlsdk.IType_factory_create_enum(self, symbol)

    def create_float(self):
        r""" Creates a new instance of the float type."""
        return _pymdlsdk.IType_factory_create_float(self)

    def create_double(self):
        r""" Creates a new instance of the double type."""
        return _pymdlsdk.IType_factory_create_double(self)

    def create_string(self):
        r""" Creates a new instance of the string type."""
        return _pymdlsdk.IType_factory_create_string(self)

    def create_vector(self, element_type, size):
        r"""
        Creates a new instance of a vector type.

        :type element_type: :py:class:`IType_atomic`
        :param element_type:   The element type needs to be either #mi::neuraylib::IType_bool,
                                  #mi::neuraylib::IType_int, #mi::neuraylib::IType_float, or
                                  #mi::neuraylib::IType_double.
        :type size: int
        :param size:           The number of elements, either 2, 3, or 4.
        :rtype: :py:class:`IType_vector`
        :return: The corresponding vector type, or ``NULL`` in case of errors.
        """
        return _pymdlsdk.IType_factory_create_vector(self, element_type, size)

    def create_matrix(self, column_type, columns):
        r"""
        Creates a new instance of a matrix type.

        :type column_type: :py:class:`IType_vector`
        :param column_type:    The column type needs to be a vector of either
                                  #mi::neuraylib::IType_float or #mi::neuraylib::IType_double.
        :type columns: int
        :param columns:        The number of columns, either 2, 3, or 4.
        :rtype: :py:class:`IType_matrix`
        :return: The corresponding matrix type, or ``NULL`` in case of errors.
        """
        return _pymdlsdk.IType_factory_create_matrix(self, column_type, columns)

    def create_color(self):
        r""" Creates a new instance of the type color."""
        return _pymdlsdk.IType_factory_create_color(self)

    def create_immediate_sized_array(self, element_type, size):
        r""" Creates a new instance of an immediate-sized array type."""
        return _pymdlsdk.IType_factory_create_immediate_sized_array(self, element_type, size)

    def create_deferred_sized_array(self, element_type, size):
        r""" Creates a new instance of a deferred-sized array type."""
        return _pymdlsdk.IType_factory_create_deferred_sized_array(self, element_type, size)

    def create_struct(self, symbol):
        r""" Returns a registered struct type, or ``NULL`` if ``symbol`` is invalid or unknown."""
        return _pymdlsdk.IType_factory_create_struct(self, symbol)

    def create_texture(self, shape):
        r""" Creates a new instance of the type texture."""
        return _pymdlsdk.IType_factory_create_texture(self, shape)

    def create_light_profile(self):
        r""" Creates a new instance of the type light_profile."""
        return _pymdlsdk.IType_factory_create_light_profile(self)

    def create_bsdf_measurement(self):
        r""" Creates a new instance of the type bsdf_measurement."""
        return _pymdlsdk.IType_factory_create_bsdf_measurement(self)

    def create_bsdf(self):
        r""" Creates a new instance of the type bsdf."""
        return _pymdlsdk.IType_factory_create_bsdf(self)

    def create_hair_bsdf(self):
        r""" Creates a new instance of the type hair_bsdf."""
        return _pymdlsdk.IType_factory_create_hair_bsdf(self)

    def create_edf(self):
        r""" Creates a new instance of the type edf."""
        return _pymdlsdk.IType_factory_create_edf(self)

    def create_vdf(self):
        r""" Creates a new instance of the type vdf."""
        return _pymdlsdk.IType_factory_create_vdf(self)

    def create_type_list(self):
        r""" Creates a new type map."""
        return _pymdlsdk.IType_factory_create_type_list(self)

    def get_predefined_enum(self, id):
        r""" Returns a registered enum type, or ``NULL`` if ``id`` is unknown."""
        return _pymdlsdk.IType_factory_get_predefined_enum(self, id)

    def get_predefined_struct(self, id):
        r""" Returns a registered struct type, or ``NULL`` if ``id`` is unknown."""
        return _pymdlsdk.IType_factory_get_predefined_struct(self, id)

    def clone(self, type_list):
        r""" Clones the given type list."""
        return _pymdlsdk.IType_factory_clone(self, type_list)

    def compare(self, *args):
        r"""
        *Overload 1:*
        Compares two instances of #mi::neuraylib::IType.

        The comparison operator for instances of #mi::neuraylib::IType is defined as follows:
        - If ``lhs`` or ``rhs`` is ``NULL``, the result is the lexicographic comparison of
          the pointer addresses themselves.
        - Otherwise, the kind of the types are compared. If they are different, the result is
          determined by ``operator``< on the #mi::neuraylib::IType::Kind values.
        - Finally, specific types are compared as follows:
          - #mi::neuraylib::IType_enum and #mi::neuraylib::IType_struct: The result is determined by
            ``strcmp()`` on the corresponding symbol names.
          - #mi::neuraylib::IType_vector, #mi::neuraylib::IType_matrix, #mi::neuraylib::IType_array:
            If the element types are different, they determine the result of the comparison. If the
            element types are identical the number of compound elements determines the result.
          - #mi::neuraylib::IType_alias: If the modifiers are different, they determine the result
            of the comparison. If the modifiers are identical, the aliased types determine the
            result.
          - #mi::neuraylib::IType_texture: The result is determined by a comparison of the
            corresponding shapes.
          - All other pairs of (the same kind of) types are considered equal.

        :type lhs: :py:class:`IType`
        :param lhs:   The left-hand side operand for the comparison.
        :type rhs: :py:class:`IType`
        :param rhs:   The right-hand side operand for the comparison.
        :rtype: int
        :return: -1 if ``lhs`` < ``rhs``, 0 if ``lhs`` == ``rhs``, and +1 if ``lhs`` > ``rhs``.

        |

        *Overload 2:*
        Compares two instances of #mi::neuraylib::IType_list.

        The comparison operator for instances of #mi::neuraylib::IType_list is defined as follows:
        - If ``lhs`` or ``rhs`` is ``NULL``, the result is the lexicographic comparison of
          the pointer addresses themselves.
        - Next, the list sizes are compared using ``operator``<().
        - Next, the lists are traversed by increasing index and the names are compared using
          ``strcmp()``.
        - Finally, the list elements are enumerated by increasing index and the types are compared.

        :type lhs: :py:class:`IType_list`
        :param lhs:   The left-hand side operand for the comparison.
        :type rhs: :py:class:`IType_list`
        :param rhs:   The right-hand side operand for the comparison.
        :rtype: int
        :return: -1 if ``lhs`` < ``rhs``, 0 if ``lhs`` == ``rhs``, and +1 if ``lhs`` > ``rhs``.
        """
        return _pymdlsdk.IType_factory_compare(self, *args)

    def is_compatible(self, src, dst):
        r"""
        Checks, if two instances of #mi::neuraylib::IType are compatible, meaning that ``src``
        can be casted to ``dst``.

        ``src`` is compatible with and therefore can be casted to ``dst``, if
        - ``src`` and ``dst`` are of identical type (see #mi::neuraylib::IType_factory::compare()).
        - ``src`` and ``dst`` are of type #mi::neuraylib::IType_struct, have the same number of
          fields and all fields are compatible.
        - ``src`` and ``dst`` are of type #mi::neuraylib::IType_enum and both enumeration types have
          the same set of numerical enumeration values. The name of the enumeration values, their
          order, or whether multiple enumeration value names share the same numerical value
          do not matter.
        - ``src`` and ``dst`` are of type #mi::neuraylib::IType_array, both arrays have the same size
          and their element types are compatible.

        :type src: :py:class:`IType`
        :param src: The source type.
        :type dst: :py:class:`IType`
        :param dst: the target type to which src is intended to be compatible.
        :rtype: int
        :return: 
                      -  0 if ``src`` can be casted to ``dst``, but ``src`` and ``dst`` are not of identical
                           type.
                      -  1 if ``src`` and ``dst`` are of identical type.
                      - -1 if ``src`` cannot be casted to ``dst``.
        """
        return _pymdlsdk.IType_factory_is_compatible(self, src, dst)

    def dump(self, *args):
        r"""
        *Overload 1:*
         Returns a textual representation of a type.

         The representation of the type might contain line breaks, for example for structures and
         enums. Subsequent lines have a suitable indentation. The assumed indentation level of the
         first line is specified by ``depth``.

         Notes: The exact format of the textual representation is unspecified and might change in
               future releases. The textual representation is primarily meant as a debugging aid. Do
               *not* base application logic on it.

        |

        *Overload 2:*
         Returns a textual representation of a type list.

         The representation of the type list will contain line breaks. Subsequent lines have a
         suitable indentation. The assumed indentation level of the first line is specified by
        ``depth``.

         Notes: The exact format of the textual representation is unspecified and might change in
               future releases. The textual representation is primarily meant as a debugging aid. Do
               *not* base application logic on it.

        |

        *Overload 3:*
         Returns a textual representation of a type list.

         The representation of the type list will contain line breaks. Subsequent lines have a
         suitable indentation. The assumed indentation level of the first line is specified by
        ``depth``.

         Notes: The exact format of the textual representation is unspecified and might change in
               future releases. The textual representation is primarily meant as a debugging aid. Do
               *not* base application logic on it.
        """
        return _pymdlsdk.IType_factory_dump(self, *args)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IType_factory_compare_iid(self, iid)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IType_factory__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IType_factory__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IType_factory_get_iid(self)

# Register IType_factory in _pymdlsdk:
_pymdlsdk.IType_factory_swigregister(IType_factory)

def IType_factory_IID():
    return _pymdlsdk.IType_factory_IID()

def IType_factory__get_interface(iface):
    return _pymdlsdk.IType_factory__get_interface(iface)

class IType_float(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IType_float_swiginit(self, _pymdlsdk.new_IType_float(*args))
    __swig_destroy__ = _pymdlsdk.delete_IType_float

    def __deref__(self):
        return _pymdlsdk.IType_float___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IType_float___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IType_float_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IType_float___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IType_float___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IType_float_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IType_float_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IType_float__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IType.Kind(self._get_kind(*args))


    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IType_float_compare_iid(self, iid)

    def _get_kind(self):
        r""" Returns the kind of type."""
        return _pymdlsdk.IType_float__get_kind(self)

    def get_all_type_modifiers(self):
        r"""
        Returns all type modifiers of a type.

        Returns 0 if ``this`` is not an alias. Otherwise, the method follows the chain of aliases by
        calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind() returns
        #TK_ALIAS. The method returns the union of
        #mi::neuraylib::IType_alias::get_type_modifiers() calls on ``this`` and all intermediate
        aliases.
        """
        return _pymdlsdk.IType_float_get_all_type_modifiers(self)

    def skip_all_type_aliases(self):
        r"""
        Returns the base type.

        Returns ``this`` if ``this`` is not an alias. Otherwise, the method follows the chain of
        aliases by calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind()
        returns #TK_ALIAS. The method returns the first non-alias type.
        """
        return _pymdlsdk.IType_float_skip_all_type_aliases(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IType_float__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IType_float__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IType_float_get_iid(self)

# Register IType_float in _pymdlsdk:
_pymdlsdk.IType_float_swigregister(IType_float)

def IType_float_IID():
    return _pymdlsdk.IType_float_IID()

def IType_float__get_interface(iface):
    return _pymdlsdk.IType_float__get_interface(iface)

class IType_hair_bsdf(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IType_hair_bsdf_swiginit(self, _pymdlsdk.new_IType_hair_bsdf(*args))
    __swig_destroy__ = _pymdlsdk.delete_IType_hair_bsdf

    def __deref__(self):
        return _pymdlsdk.IType_hair_bsdf___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IType_hair_bsdf___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IType_hair_bsdf_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IType_hair_bsdf___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IType_hair_bsdf___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IType_hair_bsdf_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IType_hair_bsdf_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IType_hair_bsdf__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IType.Kind(self._get_kind(*args))


    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IType_hair_bsdf_compare_iid(self, iid)

    def _get_kind(self):
        r""" Returns the kind of type."""
        return _pymdlsdk.IType_hair_bsdf__get_kind(self)

    def get_all_type_modifiers(self):
        r"""
        Returns all type modifiers of a type.

        Returns 0 if ``this`` is not an alias. Otherwise, the method follows the chain of aliases by
        calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind() returns
        #TK_ALIAS. The method returns the union of
        #mi::neuraylib::IType_alias::get_type_modifiers() calls on ``this`` and all intermediate
        aliases.
        """
        return _pymdlsdk.IType_hair_bsdf_get_all_type_modifiers(self)

    def skip_all_type_aliases(self):
        r"""
        Returns the base type.

        Returns ``this`` if ``this`` is not an alias. Otherwise, the method follows the chain of
        aliases by calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind()
        returns #TK_ALIAS. The method returns the first non-alias type.
        """
        return _pymdlsdk.IType_hair_bsdf_skip_all_type_aliases(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IType_hair_bsdf__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IType_hair_bsdf__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IType_hair_bsdf_get_iid(self)

# Register IType_hair_bsdf in _pymdlsdk:
_pymdlsdk.IType_hair_bsdf_swigregister(IType_hair_bsdf)

def IType_hair_bsdf_IID():
    return _pymdlsdk.IType_hair_bsdf_IID()

def IType_hair_bsdf__get_interface(iface):
    return _pymdlsdk.IType_hair_bsdf__get_interface(iface)

class IType_int(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IType_int_swiginit(self, _pymdlsdk.new_IType_int(*args))
    __swig_destroy__ = _pymdlsdk.delete_IType_int

    def __deref__(self):
        return _pymdlsdk.IType_int___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IType_int___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IType_int_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IType_int___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IType_int___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IType_int_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IType_int_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IType_int__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IType.Kind(self._get_kind(*args))


    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IType_int_compare_iid(self, iid)

    def _get_kind(self):
        r""" Returns the kind of type."""
        return _pymdlsdk.IType_int__get_kind(self)

    def get_all_type_modifiers(self):
        r"""
        Returns all type modifiers of a type.

        Returns 0 if ``this`` is not an alias. Otherwise, the method follows the chain of aliases by
        calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind() returns
        #TK_ALIAS. The method returns the union of
        #mi::neuraylib::IType_alias::get_type_modifiers() calls on ``this`` and all intermediate
        aliases.
        """
        return _pymdlsdk.IType_int_get_all_type_modifiers(self)

    def skip_all_type_aliases(self):
        r"""
        Returns the base type.

        Returns ``this`` if ``this`` is not an alias. Otherwise, the method follows the chain of
        aliases by calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind()
        returns #TK_ALIAS. The method returns the first non-alias type.
        """
        return _pymdlsdk.IType_int_skip_all_type_aliases(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IType_int__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IType_int__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IType_int_get_iid(self)

# Register IType_int in _pymdlsdk:
_pymdlsdk.IType_int_swigregister(IType_int)

def IType_int_IID():
    return _pymdlsdk.IType_int_IID()

def IType_int__get_interface(iface):
    return _pymdlsdk.IType_int__get_interface(iface)

class IType_light_profile(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IType_light_profile_swiginit(self, _pymdlsdk.new_IType_light_profile(*args))
    __swig_destroy__ = _pymdlsdk.delete_IType_light_profile

    def __deref__(self):
        return _pymdlsdk.IType_light_profile___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IType_light_profile___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IType_light_profile_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IType_light_profile___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IType_light_profile___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IType_light_profile_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IType_light_profile_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IType_light_profile__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IType.Kind(self._get_kind(*args))


    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IType_light_profile_compare_iid(self, iid)

    def _get_kind(self):
        r""" Returns the kind of type."""
        return _pymdlsdk.IType_light_profile__get_kind(self)

    def get_all_type_modifiers(self):
        r"""
        Returns all type modifiers of a type.

        Returns 0 if ``this`` is not an alias. Otherwise, the method follows the chain of aliases by
        calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind() returns
        #TK_ALIAS. The method returns the union of
        #mi::neuraylib::IType_alias::get_type_modifiers() calls on ``this`` and all intermediate
        aliases.
        """
        return _pymdlsdk.IType_light_profile_get_all_type_modifiers(self)

    def skip_all_type_aliases(self):
        r"""
        Returns the base type.

        Returns ``this`` if ``this`` is not an alias. Otherwise, the method follows the chain of
        aliases by calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind()
        returns #TK_ALIAS. The method returns the first non-alias type.
        """
        return _pymdlsdk.IType_light_profile_skip_all_type_aliases(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IType_light_profile__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IType_light_profile__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IType_light_profile_get_iid(self)

# Register IType_light_profile in _pymdlsdk:
_pymdlsdk.IType_light_profile_swigregister(IType_light_profile)

def IType_light_profile_IID():
    return _pymdlsdk.IType_light_profile_IID()

def IType_light_profile__get_interface(iface):
    return _pymdlsdk.IType_light_profile__get_interface(iface)

class IType_list(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IType_list_swiginit(self, _pymdlsdk.new_IType_list(*args))
    __swig_destroy__ = _pymdlsdk.delete_IType_list

    def __deref__(self):
        return _pymdlsdk.IType_list___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IType_list___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IType_list_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IType_list___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IType_list___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IType_list_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IType_list_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IType_list__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_size(self):
        r""" Returns the number of elements."""
        return _pymdlsdk.IType_list_get_size(self)

    def get_index(self, name):
        r""" Returns the index for the given name, or -1 if there is no such type."""
        return _pymdlsdk.IType_list_get_index(self, name)

    def get_name(self, index):
        r""" Returns the name for the given index, or ``NULL`` if there is no such type."""
        return _pymdlsdk.IType_list_get_name(self, index)

    def get_type(self, *args):
        r"""
        *Overload 1:*
        Returns the type for ``index``, or ``NULL`` if there is no such type.

        |

        *Overload 2:*
        Returns the type for ``name``, or ``NULL`` if there is no such type.
        """
        return _pymdlsdk.IType_list_get_type(self, *args)

    def set_type(self, *args):
        r"""
        *Overload 1:*
        Sets a type at a given index.

        :rtype: int
        :return: -  0: Success.
                      - -1: Invalid parameters (``NULL`` pointer).
                      - -2: ``index`` is out of bounds.

        |

        *Overload 2:*
        Sets a type identified by name.

        :rtype: int
        :return: -  0: Success.
                      - -1: Invalid parameters (``NULL`` pointer).
                      - -2: There is no type mapped to ``name`` in the list.
        """
        return _pymdlsdk.IType_list_set_type(self, *args)

    def add_type(self, name, type):
        r"""
        Adds a type at the end of the list.

        :rtype: int
        :return: -  0: Success.
                      - -1: Invalid parameters (``NULL`` pointer).
                      - -2: There is already a type mapped to ``name`` in the list.
        """
        return _pymdlsdk.IType_list_add_type(self, name, type)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IType_list_compare_iid(self, iid)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IType_list__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IType_list__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IType_list_get_iid(self)

# Register IType_list in _pymdlsdk:
_pymdlsdk.IType_list_swigregister(IType_list)

def IType_list_IID():
    return _pymdlsdk.IType_list_IID()

def IType_list__get_interface(iface):
    return _pymdlsdk.IType_list__get_interface(iface)

class IType_matrix(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IType_matrix_swiginit(self, _pymdlsdk.new_IType_matrix(*args))
    __swig_destroy__ = _pymdlsdk.delete_IType_matrix

    def __deref__(self):
        return _pymdlsdk.IType_matrix___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IType_matrix___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IType_matrix_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IType_matrix___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IType_matrix___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IType_matrix_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IType_matrix_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IType_matrix__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IType.Kind(self._get_kind(*args))


    def get_element_type(self):
        r""" Returns the type of the matrix elements, i.e., the type of a column vector."""
        return _pymdlsdk.IType_matrix_get_element_type(self)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IType_matrix_compare_iid(self, iid)

    def get_component_type(self, index):
        r""" Returns the component type at ``index``."""
        return _pymdlsdk.IType_matrix_get_component_type(self, index)

    def get_size(self):
        r""" Returns the number of components."""
        return _pymdlsdk.IType_matrix_get_size(self)

    def _get_kind(self):
        r""" Returns the kind of type."""
        return _pymdlsdk.IType_matrix__get_kind(self)

    def get_all_type_modifiers(self):
        r"""
        Returns all type modifiers of a type.

        Returns 0 if ``this`` is not an alias. Otherwise, the method follows the chain of aliases by
        calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind() returns
        #TK_ALIAS. The method returns the union of
        #mi::neuraylib::IType_alias::get_type_modifiers() calls on ``this`` and all intermediate
        aliases.
        """
        return _pymdlsdk.IType_matrix_get_all_type_modifiers(self)

    def skip_all_type_aliases(self):
        r"""
        Returns the base type.

        Returns ``this`` if ``this`` is not an alias. Otherwise, the method follows the chain of
        aliases by calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind()
        returns #TK_ALIAS. The method returns the first non-alias type.
        """
        return _pymdlsdk.IType_matrix_skip_all_type_aliases(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IType_matrix__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IType_matrix__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IType_matrix_get_iid(self)

# Register IType_matrix in _pymdlsdk:
_pymdlsdk.IType_matrix_swigregister(IType_matrix)

def IType_matrix_IID():
    return _pymdlsdk.IType_matrix_IID()

def IType_matrix__get_interface(iface):
    return _pymdlsdk.IType_matrix__get_interface(iface)

class IType_reference(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IType_reference_swiginit(self, _pymdlsdk.new_IType_reference(*args))
    __swig_destroy__ = _pymdlsdk.delete_IType_reference

    def __deref__(self):
        return _pymdlsdk.IType_reference___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IType_reference___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IType_reference_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IType_reference___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IType_reference___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IType_reference_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IType_reference_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IType_reference__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IType.Kind(self._get_kind(*args))


    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IType_reference_compare_iid(self, iid)

    def _get_kind(self):
        r""" Returns the kind of type."""
        return _pymdlsdk.IType_reference__get_kind(self)

    def get_all_type_modifiers(self):
        r"""
        Returns all type modifiers of a type.

        Returns 0 if ``this`` is not an alias. Otherwise, the method follows the chain of aliases by
        calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind() returns
        #TK_ALIAS. The method returns the union of
        #mi::neuraylib::IType_alias::get_type_modifiers() calls on ``this`` and all intermediate
        aliases.
        """
        return _pymdlsdk.IType_reference_get_all_type_modifiers(self)

    def skip_all_type_aliases(self):
        r"""
        Returns the base type.

        Returns ``this`` if ``this`` is not an alias. Otherwise, the method follows the chain of
        aliases by calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind()
        returns #TK_ALIAS. The method returns the first non-alias type.
        """
        return _pymdlsdk.IType_reference_skip_all_type_aliases(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IType_reference__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IType_reference__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IType_reference_get_iid(self)

# Register IType_reference in _pymdlsdk:
_pymdlsdk.IType_reference_swigregister(IType_reference)

def IType_reference_IID():
    return _pymdlsdk.IType_reference_IID()

def IType_reference__get_interface(iface):
    return _pymdlsdk.IType_reference__get_interface(iface)

class IType_resource(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IType_resource_swiginit(self, _pymdlsdk.new_IType_resource(*args))
    __swig_destroy__ = _pymdlsdk.delete_IType_resource

    def __deref__(self):
        return _pymdlsdk.IType_resource___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IType_resource___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IType_resource_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IType_resource___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IType_resource___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IType_resource_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IType_resource_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IType_resource__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IType.Kind(self._get_kind(*args))


    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IType_resource_compare_iid(self, iid)

    def _get_kind(self):
        r""" Returns the kind of type."""
        return _pymdlsdk.IType_resource__get_kind(self)

    def get_all_type_modifiers(self):
        r"""
        Returns all type modifiers of a type.

        Returns 0 if ``this`` is not an alias. Otherwise, the method follows the chain of aliases by
        calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind() returns
        #TK_ALIAS. The method returns the union of
        #mi::neuraylib::IType_alias::get_type_modifiers() calls on ``this`` and all intermediate
        aliases.
        """
        return _pymdlsdk.IType_resource_get_all_type_modifiers(self)

    def skip_all_type_aliases(self):
        r"""
        Returns the base type.

        Returns ``this`` if ``this`` is not an alias. Otherwise, the method follows the chain of
        aliases by calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind()
        returns #TK_ALIAS. The method returns the first non-alias type.
        """
        return _pymdlsdk.IType_resource_skip_all_type_aliases(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IType_resource__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IType_resource__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IType_resource_get_iid(self)

# Register IType_resource in _pymdlsdk:
_pymdlsdk.IType_resource_swigregister(IType_resource)

def IType_resource_IID():
    return _pymdlsdk.IType_resource_IID()

def IType_resource__get_interface(iface):
    return _pymdlsdk.IType_resource__get_interface(iface)

class IType_string(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IType_string_swiginit(self, _pymdlsdk.new_IType_string(*args))
    __swig_destroy__ = _pymdlsdk.delete_IType_string

    def __deref__(self):
        return _pymdlsdk.IType_string___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IType_string___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IType_string_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IType_string___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IType_string___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IType_string_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IType_string_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IType_string__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IType.Kind(self._get_kind(*args))


    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IType_string_compare_iid(self, iid)

    def _get_kind(self):
        r""" Returns the kind of type."""
        return _pymdlsdk.IType_string__get_kind(self)

    def get_all_type_modifiers(self):
        r"""
        Returns all type modifiers of a type.

        Returns 0 if ``this`` is not an alias. Otherwise, the method follows the chain of aliases by
        calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind() returns
        #TK_ALIAS. The method returns the union of
        #mi::neuraylib::IType_alias::get_type_modifiers() calls on ``this`` and all intermediate
        aliases.
        """
        return _pymdlsdk.IType_string_get_all_type_modifiers(self)

    def skip_all_type_aliases(self):
        r"""
        Returns the base type.

        Returns ``this`` if ``this`` is not an alias. Otherwise, the method follows the chain of
        aliases by calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind()
        returns #TK_ALIAS. The method returns the first non-alias type.
        """
        return _pymdlsdk.IType_string_skip_all_type_aliases(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IType_string__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IType_string__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IType_string_get_iid(self)

# Register IType_string in _pymdlsdk:
_pymdlsdk.IType_string_swigregister(IType_string)

def IType_string_IID():
    return _pymdlsdk.IType_string_IID()

def IType_string__get_interface(iface):
    return _pymdlsdk.IType_string__get_interface(iface)

class IType_structure(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IType_structure_swiginit(self, _pymdlsdk.new_IType_structure(*args))
    __swig_destroy__ = _pymdlsdk.delete_IType_structure

    def __deref__(self):
        return _pymdlsdk.IType_structure___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IType_structure___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IType_structure_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IType_structure___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IType_structure___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IType_structure_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IType_structure_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IType_structure__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IType.Kind(self._get_kind(*args))


    def get_symbol(self):
        r""" Returns the qualified name of the struct type."""
        return _pymdlsdk.IType_structure_get_symbol(self)

    def get_field_type(self, index):
        r"""
        Returns a field type.

        :type index: int
        :param index:    The index of the field.
        :rtype: :py:class:`IType`
        :return: The type of the field.
        """
        return _pymdlsdk.IType_structure_get_field_type(self, index)

    def get_field_name(self, index):
        r"""
        Returns a field name.

        :type index: int
        :param index:    The index of the field.
        :rtype: string
        :return: The unqualified name of the field.
        """
        return _pymdlsdk.IType_structure_get_field_name(self, index)

    def find_field(self, name):
        r"""
        Returns the index of a field in linear time.

        :type name: string
        :param name:     The unqualified name of the field.
        :rtype: int
        :return: The index of the field, or -1 if there is no such field.
        """
        return _pymdlsdk.IType_structure_find_field(self, name)

    def get_predefined_id(self):
        r""" If this struct is a predefined one, return its ID, else SID_USER."""
        return _pymdlsdk.IType_structure_get_predefined_id(self)

    def get_annotations(self):
        r"""
        Returns the annotations of the struct type.

        :rtype: :py:class:`IAnnotation_block`
        :return: The annotations of the struct type, or ``NULL`` if there are no
                                 annotations for the struct type.
        """
        return _pymdlsdk.IType_structure_get_annotations(self)

    def get_field_annotations(self, index):
        r"""
        Returns the annotations of a field.

        :type index: int
        :param index:         The index of the field.
        :rtype: :py:class:`IAnnotation_block`
        :return: The annotation of that field, or ``NULL`` if ``index`` is out of bounds,
                                 or there are no annotations for that field.
        """
        return _pymdlsdk.IType_structure_get_field_annotations(self, index)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IType_structure_compare_iid(self, iid)

    def get_component_type(self, index):
        r""" Returns the component type at ``index``."""
        return _pymdlsdk.IType_structure_get_component_type(self, index)

    def get_size(self):
        r""" Returns the number of components."""
        return _pymdlsdk.IType_structure_get_size(self)

    def _get_kind(self):
        r""" Returns the kind of type."""
        return _pymdlsdk.IType_structure__get_kind(self)

    def get_all_type_modifiers(self):
        r"""
        Returns all type modifiers of a type.

        Returns 0 if ``this`` is not an alias. Otherwise, the method follows the chain of aliases by
        calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind() returns
        #TK_ALIAS. The method returns the union of
        #mi::neuraylib::IType_alias::get_type_modifiers() calls on ``this`` and all intermediate
        aliases.
        """
        return _pymdlsdk.IType_structure_get_all_type_modifiers(self)

    def skip_all_type_aliases(self):
        r"""
        Returns the base type.

        Returns ``this`` if ``this`` is not an alias. Otherwise, the method follows the chain of
        aliases by calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind()
        returns #TK_ALIAS. The method returns the first non-alias type.
        """
        return _pymdlsdk.IType_structure_skip_all_type_aliases(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IType_structure__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IType_structure__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IType_structure_get_iid(self)

# Register IType_structure in _pymdlsdk:
_pymdlsdk.IType_structure_swigregister(IType_structure)

def IType_structure_IID():
    return _pymdlsdk.IType_structure_IID()

def IType_structure__get_interface(iface):
    return _pymdlsdk.IType_structure__get_interface(iface)

class IType_texture(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IType_texture_swiginit(self, _pymdlsdk.new_IType_texture(*args))
    __swig_destroy__ = _pymdlsdk.delete_IType_texture

    def __deref__(self):
        return _pymdlsdk.IType_texture___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IType_texture___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IType_texture_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IType_texture___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IType_texture___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IType_texture_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IType_texture_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IType_texture__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IType.Kind(self._get_kind(*args))


    def get_shape(self):
        r""" Returns the texture type."""
        return _pymdlsdk.IType_texture_get_shape(self)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IType_texture_compare_iid(self, iid)

    def _get_kind(self):
        r""" Returns the kind of type."""
        return _pymdlsdk.IType_texture__get_kind(self)

    def get_all_type_modifiers(self):
        r"""
        Returns all type modifiers of a type.

        Returns 0 if ``this`` is not an alias. Otherwise, the method follows the chain of aliases by
        calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind() returns
        #TK_ALIAS. The method returns the union of
        #mi::neuraylib::IType_alias::get_type_modifiers() calls on ``this`` and all intermediate
        aliases.
        """
        return _pymdlsdk.IType_texture_get_all_type_modifiers(self)

    def skip_all_type_aliases(self):
        r"""
        Returns the base type.

        Returns ``this`` if ``this`` is not an alias. Otherwise, the method follows the chain of
        aliases by calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind()
        returns #TK_ALIAS. The method returns the first non-alias type.
        """
        return _pymdlsdk.IType_texture_skip_all_type_aliases(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IType_texture__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IType_texture__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IType_texture_get_iid(self)

# Register IType_texture in _pymdlsdk:
_pymdlsdk.IType_texture_swigregister(IType_texture)

def IType_texture_IID():
    return _pymdlsdk.IType_texture_IID()

def IType_texture__get_interface(iface):
    return _pymdlsdk.IType_texture__get_interface(iface)

class IType_vdf(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IType_vdf_swiginit(self, _pymdlsdk.new_IType_vdf(*args))
    __swig_destroy__ = _pymdlsdk.delete_IType_vdf

    def __deref__(self):
        return _pymdlsdk.IType_vdf___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IType_vdf___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IType_vdf_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IType_vdf___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IType_vdf___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IType_vdf_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IType_vdf_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IType_vdf__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IType.Kind(self._get_kind(*args))


    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IType_vdf_compare_iid(self, iid)

    def _get_kind(self):
        r""" Returns the kind of type."""
        return _pymdlsdk.IType_vdf__get_kind(self)

    def get_all_type_modifiers(self):
        r"""
        Returns all type modifiers of a type.

        Returns 0 if ``this`` is not an alias. Otherwise, the method follows the chain of aliases by
        calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind() returns
        #TK_ALIAS. The method returns the union of
        #mi::neuraylib::IType_alias::get_type_modifiers() calls on ``this`` and all intermediate
        aliases.
        """
        return _pymdlsdk.IType_vdf_get_all_type_modifiers(self)

    def skip_all_type_aliases(self):
        r"""
        Returns the base type.

        Returns ``this`` if ``this`` is not an alias. Otherwise, the method follows the chain of
        aliases by calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind()
        returns #TK_ALIAS. The method returns the first non-alias type.
        """
        return _pymdlsdk.IType_vdf_skip_all_type_aliases(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IType_vdf__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IType_vdf__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IType_vdf_get_iid(self)

# Register IType_vdf in _pymdlsdk:
_pymdlsdk.IType_vdf_swigregister(IType_vdf)

def IType_vdf_IID():
    return _pymdlsdk.IType_vdf_IID()

def IType_vdf__get_interface(iface):
    return _pymdlsdk.IType_vdf__get_interface(iface)

class IType_vector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IType_vector_swiginit(self, _pymdlsdk.new_IType_vector(*args))
    __swig_destroy__ = _pymdlsdk.delete_IType_vector

    def __deref__(self):
        return _pymdlsdk.IType_vector___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IType_vector___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IType_vector_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IType_vector___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IType_vector___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IType_vector_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IType_vector_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IType_vector__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IType.Kind(self._get_kind(*args))


    def get_element_type(self):
        r"""
        Returns the type of the vector elements.

        The element type of vectors is either #mi::neuraylib::IType_bool, #mi::neuraylib::IType_int,
        #mi::neuraylib::IType_float, or #mi::neuraylib::IType_double. If the vector is a column
        vector of a matrix, then the element type is either #mi::neuraylib::IType_float or
        #mi::neuraylib::IType_double.
        """
        return _pymdlsdk.IType_vector_get_element_type(self)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IType_vector_compare_iid(self, iid)

    def get_component_type(self, index):
        r""" Returns the component type at ``index``."""
        return _pymdlsdk.IType_vector_get_component_type(self, index)

    def get_size(self):
        r""" Returns the number of components."""
        return _pymdlsdk.IType_vector_get_size(self)

    def _get_kind(self):
        r""" Returns the kind of type."""
        return _pymdlsdk.IType_vector__get_kind(self)

    def get_all_type_modifiers(self):
        r"""
        Returns all type modifiers of a type.

        Returns 0 if ``this`` is not an alias. Otherwise, the method follows the chain of aliases by
        calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind() returns
        #TK_ALIAS. The method returns the union of
        #mi::neuraylib::IType_alias::get_type_modifiers() calls on ``this`` and all intermediate
        aliases.
        """
        return _pymdlsdk.IType_vector_get_all_type_modifiers(self)

    def skip_all_type_aliases(self):
        r"""
        Returns the base type.

        Returns ``this`` if ``this`` is not an alias. Otherwise, the method follows the chain of
        aliases by calling #mi::neuraylib::IType_alias::get_aliased_type() as long as #get_kind()
        returns #TK_ALIAS. The method returns the first non-alias type.
        """
        return _pymdlsdk.IType_vector_skip_all_type_aliases(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IType_vector__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IType_vector__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IType_vector_get_iid(self)

# Register IType_vector in _pymdlsdk:
_pymdlsdk.IType_vector_swigregister(IType_vector)

def IType_vector_IID():
    return _pymdlsdk.IType_vector_IID()

def IType_vector__get_interface(iface):
    return _pymdlsdk.IType_vector__get_interface(iface)

class IValue(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IValue_swiginit(self, _pymdlsdk.new_IValue(*args))
    __swig_destroy__ = _pymdlsdk.delete_IValue

    def __deref__(self):
        return _pymdlsdk.IValue___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IValue___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IValue_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IValue___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IValue___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IValue_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IValue_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IValue__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    class Kind(Enum) :
        VK_BOOL = _pymdlsdk._IValue_VK_BOOL
        VK_INT = _pymdlsdk._IValue_VK_INT
        VK_ENUM = _pymdlsdk._IValue_VK_ENUM
        VK_FLOAT = _pymdlsdk._IValue_VK_FLOAT
        VK_DOUBLE = _pymdlsdk._IValue_VK_DOUBLE
        VK_STRING = _pymdlsdk._IValue_VK_STRING
        VK_VECTOR = _pymdlsdk._IValue_VK_VECTOR
        VK_MATRIX = _pymdlsdk._IValue_VK_MATRIX
        VK_COLOR = _pymdlsdk._IValue_VK_COLOR
        VK_ARRAY = _pymdlsdk._IValue_VK_ARRAY
        VK_STRUCT = _pymdlsdk._IValue_VK_STRUCT
        VK_INVALID_DF = _pymdlsdk._IValue_VK_INVALID_DF
        VK_TEXTURE = _pymdlsdk._IValue_VK_TEXTURE
        VK_LIGHT_PROFILE = _pymdlsdk._IValue_VK_LIGHT_PROFILE
        VK_BSDF_MEASUREMENT = _pymdlsdk._IValue_VK_BSDF_MEASUREMENT


    def get_kind(self, *args):
        return IValue.Kind(self._get_kind(*args))


    def _get_kind(self):
        r""" Returns the kind of the value."""
        return _pymdlsdk.IValue__get_kind(self)

    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk.IValue_get_type(self)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IValue_compare_iid(self, iid)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IValue__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IValue__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IValue_get_iid(self)

# Register IValue in _pymdlsdk:
_pymdlsdk.IValue_swigregister(IValue)

def IValue_IID():
    return _pymdlsdk.IValue_IID()

def IValue__get_interface(iface):
    return _pymdlsdk.IValue__get_interface(iface)

class IValue_array(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IValue_array_swiginit(self, _pymdlsdk.new_IValue_array(*args))
    __swig_destroy__ = _pymdlsdk.delete_IValue_array

    def __deref__(self):
        return _pymdlsdk.IValue_array___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IValue_array___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IValue_array_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IValue_array___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IValue_array___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IValue_array_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IValue_array_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IValue_array__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IValue.Kind(self._get_kind(*args))


    def get_value(self, *args):
        return  self._get_value(*args)

    def get_value_as(self, type, *args):
        iinterface = self._get_value(*args)
        if iinterface.is_valid_interface():
            typed_interface = iinterface.get_interface(type)
            iinterface = None
            return typed_interface
        else:
            return iinterface


    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk.IValue_array_get_type(self)

    def set_size(self, size):
        r"""
        Sets the size for dynamic arrays.

        :type size: int
        :param size:   The desired array size.
        :rtype: int
        :return: 
                          -  0: Success.
                          - -1: The array is a static array.
        """
        return _pymdlsdk.IValue_array_set_size(self, size)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IValue_array_compare_iid(self, iid)

    def get_size(self):
        r""" Returns the number of components in this compound value."""
        return _pymdlsdk.IValue_array_get_size(self)

    def _get_value(self, *args):
        r"""
        *Overload 1:*
        Returns the value at ``index``, or ``NULL`` if ``index`` is out of bounds.

        |

        *Overload 2:*
        Returns the value at ``index``, or ``NULL`` if ``index`` is out of bounds.
        """
        return _pymdlsdk.IValue_array__get_value(self, *args)

    def set_value(self, index, value):
        r"""
        Sets the value at ``index``.

        :type index: int
        :param index:   The index of the field.
        :type value: :py:class:`IValue`
        :param value:   The new value of the field.
        :rtype: int
        :return: 
                           -  0: Success.
                           - -1: Invalid parameter (``NULL`` pointer).
                           - -2: ``index`` is out of bounds.
                           - -3: Incorrect type of ``value``.
        """
        return _pymdlsdk.IValue_array_set_value(self, index, value)

    def _get_kind(self):
        r""" Returns the kind of the value."""
        return _pymdlsdk.IValue_array__get_kind(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IValue_array__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IValue_array__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IValue_array_get_iid(self)

# Register IValue_array in _pymdlsdk:
_pymdlsdk.IValue_array_swigregister(IValue_array)

def IValue_array_IID():
    return _pymdlsdk.IValue_array_IID()

def IValue_array__get_interface(iface):
    return _pymdlsdk.IValue_array__get_interface(iface)

class IValue_atomic(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IValue_atomic_swiginit(self, _pymdlsdk.new_IValue_atomic(*args))
    __swig_destroy__ = _pymdlsdk.delete_IValue_atomic

    def __deref__(self):
        return _pymdlsdk.IValue_atomic___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IValue_atomic___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IValue_atomic_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IValue_atomic___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IValue_atomic___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IValue_atomic_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IValue_atomic_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IValue_atomic__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IValue.Kind(self._get_kind(*args))


    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk.IValue_atomic_get_type(self)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IValue_atomic_compare_iid(self, iid)

    def _get_kind(self):
        r""" Returns the kind of the value."""
        return _pymdlsdk.IValue_atomic__get_kind(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IValue_atomic__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IValue_atomic__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IValue_atomic_get_iid(self)

# Register IValue_atomic in _pymdlsdk:
_pymdlsdk.IValue_atomic_swigregister(IValue_atomic)

def IValue_atomic_IID():
    return _pymdlsdk.IValue_atomic_IID()

def IValue_atomic__get_interface(iface):
    return _pymdlsdk.IValue_atomic__get_interface(iface)

class IValue_bool(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IValue_bool_swiginit(self, _pymdlsdk.new_IValue_bool(*args))
    __swig_destroy__ = _pymdlsdk.delete_IValue_bool

    def __deref__(self):
        return _pymdlsdk.IValue_bool___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IValue_bool___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IValue_bool_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IValue_bool___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IValue_bool___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IValue_bool_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IValue_bool_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IValue_bool__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IValue.Kind(self._get_kind(*args))


    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk.IValue_bool_get_type(self)

    def get_value(self):
        r""" Returns the value."""
        return _pymdlsdk.IValue_bool_get_value(self)

    def set_value(self, value):
        r""" Sets the value."""
        return _pymdlsdk.IValue_bool_set_value(self, value)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IValue_bool_compare_iid(self, iid)

    def _get_kind(self):
        r""" Returns the kind of the value."""
        return _pymdlsdk.IValue_bool__get_kind(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IValue_bool__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IValue_bool__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IValue_bool_get_iid(self)

# Register IValue_bool in _pymdlsdk:
_pymdlsdk.IValue_bool_swigregister(IValue_bool)

def IValue_bool_IID():
    return _pymdlsdk.IValue_bool_IID()

def IValue_bool__get_interface(iface):
    return _pymdlsdk.IValue_bool__get_interface(iface)

class IValue_bsdf_measurement(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IValue_bsdf_measurement_swiginit(self, _pymdlsdk.new_IValue_bsdf_measurement(*args))
    __swig_destroy__ = _pymdlsdk.delete_IValue_bsdf_measurement

    def __deref__(self):
        return _pymdlsdk.IValue_bsdf_measurement___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IValue_bsdf_measurement___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IValue_bsdf_measurement_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IValue_bsdf_measurement___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IValue_bsdf_measurement___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IValue_bsdf_measurement_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IValue_bsdf_measurement_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IValue_bsdf_measurement__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IValue.Kind(self._get_kind(*args))


    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk.IValue_bsdf_measurement_get_type(self)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IValue_bsdf_measurement_compare_iid(self, iid)

    def get_value(self):
        r"""
        Returns the name of the DB element representing this resource.

        :rtype: string
        :return: The name of the DB element, or ``NULL`` if no valid resource is set.
        """
        return _pymdlsdk.IValue_bsdf_measurement_get_value(self)

    def set_value(self, value):
        r"""
        Sets the name of the DB element representing this resource.

        Pointing this instance to a different DB element resets the MDL file path returned by
        #get_file_path().

        :type value: string
        :param value:   The name of the resource, or ``NULL`` to release the current resource.
        :rtype: int
        :return: 
                           -  0: Success.
                           - -1: There is no DB element with that name.
                           - -2: The DB element has not the correct type for this resource.
        """
        return _pymdlsdk.IValue_bsdf_measurement_set_value(self, value)

    def get_file_path(self):
        r"""
        Returns the absolute MDL file path of the resource, or ``NULL`` if not known.

        Notes: The value returned here is not a property of this object, but a property of the
              referenced resource.
        """
        return _pymdlsdk.IValue_bsdf_measurement_get_file_path(self)

    def _get_kind(self):
        r""" Returns the kind of the value."""
        return _pymdlsdk.IValue_bsdf_measurement__get_kind(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IValue_bsdf_measurement__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IValue_bsdf_measurement__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IValue_bsdf_measurement_get_iid(self)

# Register IValue_bsdf_measurement in _pymdlsdk:
_pymdlsdk.IValue_bsdf_measurement_swigregister(IValue_bsdf_measurement)

def IValue_bsdf_measurement_IID():
    return _pymdlsdk.IValue_bsdf_measurement_IID()

def IValue_bsdf_measurement__get_interface(iface):
    return _pymdlsdk.IValue_bsdf_measurement__get_interface(iface)

class IValue_color(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IValue_color_swiginit(self, _pymdlsdk.new_IValue_color(*args))
    __swig_destroy__ = _pymdlsdk.delete_IValue_color

    def __deref__(self):
        return _pymdlsdk.IValue_color___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IValue_color___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IValue_color_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IValue_color___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IValue_color___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IValue_color_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IValue_color_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IValue_color__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IValue.Kind(self._get_kind(*args))


    def get_value(self, *args):
        return  self._get_value(*args)

    def get_value_as(self, type, *args):
        iinterface = self._get_value(*args)
        if iinterface.is_valid_interface():
            typed_interface = iinterface.get_interface(type)
            iinterface = None
            return typed_interface
        else:
            return iinterface


    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk.IValue_color_get_type(self)

    def _get_value(self, *args):
        r"""
        *Overload 1:*
        Returns the value at ``index``, or ``NULL`` if ``index`` is out of bounds.

        |

        *Overload 2:*
        Returns the value at ``index``, or ``NULL`` if ``index`` is out of bounds.
        """
        return _pymdlsdk.IValue_color__get_value(self, *args)

    def set_value(self, *args):
        r"""
        *Overload 1:*
        Sets the value at ``index``.

        :rtype: int
        :return: 
                           -  0: Success.
                           - -1: Invalid parameter (``NULL`` pointer).
                           - -2: ``index`` is out of bounds.

        |

        *Overload 2:*
        Sets the value at ``index``.

        :type index: int
        :param index:   The index of the field.
        :type value: :py:class:`IValue`
        :param value:   The new value of the field.
        :rtype: int
        :return: 
                           -  0: Success.
                           - -1: Invalid parameter (``NULL`` pointer).
                           - -2: ``index`` is out of bounds.
                           - -3: Incorrect type of ``value``.
        """
        return _pymdlsdk.IValue_color_set_value(self, *args)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IValue_color_compare_iid(self, iid)

    def get_size(self):
        r""" Returns the number of components in this compound value."""
        return _pymdlsdk.IValue_color_get_size(self)

    def _get_kind(self):
        r""" Returns the kind of the value."""
        return _pymdlsdk.IValue_color__get_kind(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IValue_color__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IValue_color__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IValue_color_get_iid(self)

# Register IValue_color in _pymdlsdk:
_pymdlsdk.IValue_color_swigregister(IValue_color)

def IValue_color_IID():
    return _pymdlsdk.IValue_color_IID()

def IValue_color__get_interface(iface):
    return _pymdlsdk.IValue_color__get_interface(iface)

class IValue_compound(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IValue_compound_swiginit(self, _pymdlsdk.new_IValue_compound(*args))
    __swig_destroy__ = _pymdlsdk.delete_IValue_compound

    def __deref__(self):
        return _pymdlsdk.IValue_compound___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IValue_compound___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IValue_compound_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IValue_compound___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IValue_compound___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IValue_compound_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IValue_compound_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IValue_compound__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IValue.Kind(self._get_kind(*args))


    def get_value(self, *args):
        return  self._get_value(*args)

    def get_value_as(self, type, *args):
        iinterface = self._get_value(*args)
        if iinterface.is_valid_interface():
            typed_interface = iinterface.get_interface(type)
            iinterface = None
            return typed_interface
        else:
            return iinterface


    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk.IValue_compound_get_type(self)

    def get_size(self):
        r""" Returns the number of components in this compound value."""
        return _pymdlsdk.IValue_compound_get_size(self)

    def _get_value(self, *args):
        r"""
        *Overload 1:*
        Returns the value at ``index``, or ``NULL`` if ``index`` is out of bounds.

        |

        *Overload 2:*
        Returns the value at ``index``, or ``NULL`` if ``index`` is out of bounds.
        """
        return _pymdlsdk.IValue_compound__get_value(self, *args)

    def set_value(self, index, value):
        r"""
        Sets the value at ``index``.

        :type index: int
        :param index:   The index of the field.
        :type value: :py:class:`IValue`
        :param value:   The new value of the field.
        :rtype: int
        :return: 
                           -  0: Success.
                           - -1: Invalid parameter (``NULL`` pointer).
                           - -2: ``index`` is out of bounds.
                           - -3: Incorrect type of ``value``.
        """
        return _pymdlsdk.IValue_compound_set_value(self, index, value)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IValue_compound_compare_iid(self, iid)

    def _get_kind(self):
        r""" Returns the kind of the value."""
        return _pymdlsdk.IValue_compound__get_kind(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IValue_compound__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IValue_compound__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IValue_compound_get_iid(self)

# Register IValue_compound in _pymdlsdk:
_pymdlsdk.IValue_compound_swigregister(IValue_compound)

def IValue_compound_IID():
    return _pymdlsdk.IValue_compound_IID()

def IValue_compound__get_interface(iface):
    return _pymdlsdk.IValue_compound__get_interface(iface)

class IValue_double(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IValue_double_swiginit(self, _pymdlsdk.new_IValue_double(*args))
    __swig_destroy__ = _pymdlsdk.delete_IValue_double

    def __deref__(self):
        return _pymdlsdk.IValue_double___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IValue_double___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IValue_double_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IValue_double___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IValue_double___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IValue_double_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IValue_double_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IValue_double__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IValue.Kind(self._get_kind(*args))


    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk.IValue_double_get_type(self)

    def get_value(self):
        r""" Returns the value."""
        return _pymdlsdk.IValue_double_get_value(self)

    def set_value(self, value):
        r""" Sets the value."""
        return _pymdlsdk.IValue_double_set_value(self, value)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IValue_double_compare_iid(self, iid)

    def _get_kind(self):
        r""" Returns the kind of the value."""
        return _pymdlsdk.IValue_double__get_kind(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IValue_double__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IValue_double__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IValue_double_get_iid(self)

# Register IValue_double in _pymdlsdk:
_pymdlsdk.IValue_double_swigregister(IValue_double)

def IValue_double_IID():
    return _pymdlsdk.IValue_double_IID()

def IValue_double__get_interface(iface):
    return _pymdlsdk.IValue_double__get_interface(iface)

class IValue_enumeration(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IValue_enumeration_swiginit(self, _pymdlsdk.new_IValue_enumeration(*args))
    __swig_destroy__ = _pymdlsdk.delete_IValue_enumeration

    def __deref__(self):
        return _pymdlsdk.IValue_enumeration___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IValue_enumeration___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IValue_enumeration_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IValue_enumeration___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IValue_enumeration___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IValue_enumeration_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IValue_enumeration_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IValue_enumeration__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IValue.Kind(self._get_kind(*args))


    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk.IValue_enumeration_get_type(self)

    def get_value(self):
        r""" Returns the (integer) value of this enum value."""
        return _pymdlsdk.IValue_enumeration_get_value(self)

    def get_index(self):
        r""" Returns the index of this enum value."""
        return _pymdlsdk.IValue_enumeration_get_index(self)

    def set_value(self, value):
        r"""
        Sets the enum value by integer in linear time.

        If there are multiple indices with the same value the one with the smallest index is chosen.

        :rtype: int
        :return: 0 in case of success, -1 if ``value`` is not valid for this enum type
        """
        return _pymdlsdk.IValue_enumeration_set_value(self, value)

    def set_index(self, index):
        r"""
        Sets the enum value by index.

        :rtype: int
        :return: 0 in case of success, -1 if ``index`` is not valid for this enum type
        """
        return _pymdlsdk.IValue_enumeration_set_index(self, index)

    def get_name(self):
        r""" Returns the string representation of this enum value."""
        return _pymdlsdk.IValue_enumeration_get_name(self)

    def set_name(self, name):
        r"""
        Sets the enum value by string representation in linear time.

        :rtype: int
        :return: 0 in case of success, -1 if ``name`` is not valid for this enum type
        """
        return _pymdlsdk.IValue_enumeration_set_name(self, name)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IValue_enumeration_compare_iid(self, iid)

    def _get_kind(self):
        r""" Returns the kind of the value."""
        return _pymdlsdk.IValue_enumeration__get_kind(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IValue_enumeration__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IValue_enumeration__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IValue_enumeration_get_iid(self)

# Register IValue_enumeration in _pymdlsdk:
_pymdlsdk.IValue_enumeration_swigregister(IValue_enumeration)

def IValue_enumeration_IID():
    return _pymdlsdk.IValue_enumeration_IID()

def IValue_enumeration__get_interface(iface):
    return _pymdlsdk.IValue_enumeration__get_interface(iface)

class IValue_factory(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IValue_factory_swiginit(self, _pymdlsdk.new_IValue_factory(*args))
    __swig_destroy__ = _pymdlsdk.delete_IValue_factory

    def __deref__(self):
        return _pymdlsdk.IValue_factory___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IValue_factory___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IValue_factory_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IValue_factory___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IValue_factory___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IValue_factory_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IValue_factory_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IValue_factory__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_type_factory(self):
        r""" Returns the type factory associated with this value factory."""
        return _pymdlsdk.IValue_factory_get_type_factory(self)

    def create_bool(self, value=False):
        r""" Creates a new value of type boolean."""
        return _pymdlsdk.IValue_factory_create_bool(self, value)

    def create_int(self, value=0):
        r""" Creates a new value of type integer."""
        return _pymdlsdk.IValue_factory_create_int(self, value)

    def create_enum(self, type, index=0):
        r""" Creates a new value of type enum, or returns ``NULL`` in case of errors."""
        return _pymdlsdk.IValue_factory_create_enum(self, type, index)

    def create_float(self, value=0.0):
        r""" Creates a new value of type float."""
        return _pymdlsdk.IValue_factory_create_float(self, value)

    def create_double(self, value=0.0):
        r""" Creates a new value of type double."""
        return _pymdlsdk.IValue_factory_create_double(self, value)

    def create_string(self, *args):
        r"""
        Creates a new value of type string.

        :type value: string, optional
        :param value:   The value ``NULL`` is handled like the empty string.
        """
        return _pymdlsdk.IValue_factory_create_string(self, *args)

    def create_vector(self, type):
        r""" Creates a new value of type vector, or returns ``NULL`` in case of errors."""
        return _pymdlsdk.IValue_factory_create_vector(self, type)

    def create_matrix(self, type):
        r""" Creates a new value of type matrix, or returns ``NULL`` in case of errors."""
        return _pymdlsdk.IValue_factory_create_matrix(self, type)

    def create_color(self, red=0.0, green=0.0, blue=0.0):
        r""" Creates a new value of type color."""
        return _pymdlsdk.IValue_factory_create_color(self, red, green, blue)

    def create_array(self, type):
        r""" Creates a new value of type array, or returns ``NULL`` in case of errors."""
        return _pymdlsdk.IValue_factory_create_array(self, type)

    def create_struct(self, type):
        r""" Creates a new value of type struct, or returns ``NULL`` in case of errors."""
        return _pymdlsdk.IValue_factory_create_struct(self, type)

    def create_texture(self, type, value):
        r""" Creates a new texture value, or returns ``NULL`` in case of errors."""
        return _pymdlsdk.IValue_factory_create_texture(self, type, value)

    def create_light_profile(self, value):
        r""" Creates a new light profile value, or returns ``NULL`` in case of errors."""
        return _pymdlsdk.IValue_factory_create_light_profile(self, value)

    def create_bsdf_measurement(self, value):
        r""" Creates a new BSDF measurement value, or returns ``NULL`` in case of errors."""
        return _pymdlsdk.IValue_factory_create_bsdf_measurement(self, value)

    def create_invalid_df(self, type):
        r""" Creates a new invalid distribution function value."""
        return _pymdlsdk.IValue_factory_create_invalid_df(self, type)

    def create(self, type):
        r""" Creates a default-constructed value of the given type."""
        return _pymdlsdk.IValue_factory_create(self, type)

    def create_value_list(self):
        r""" Creates a new value list."""
        return _pymdlsdk.IValue_factory_create_value_list(self)

    def clone(self, *args):
        r"""
        *Overload 1:*
        Clones the given value.

        Note that referenced DB elements, e.g., resources, are not copied, but shared.

        |

        *Overload 2:*
        Clones the given value list.

        Note that referenced DB elements, e.g., resources, are not copied, but shared.
        """
        return _pymdlsdk.IValue_factory_clone(self, *args)

    def compare(self, *args):
        r"""
        *Overload 1:*
        Compares two instances of #mi::neuraylib::IValue.

        The comparison operator for instances of #mi::neuraylib::IValue is defined as follows:
        - If ``lhs`` or ``rhs`` is ``NULL``, the result is the lexicographic comparison of
          the pointer addresses themselves.
        - Otherwise, the types of ``lhs`` and ``rhs`` are compared. If they are different, the result
          is determined by that comparison.
        - Next, the kind of the values are compared. If they are different, the result is determined
          by ``operator``< on the #mi::neuraylib::IValue::Kind values.
        - Finally, the values are compared as follows:
          - For atomic types, their values are compared using ``operator``< or ``strcmp()``, with the
            exception of enums, for which the indices rather than the values are compared.
          - For compounds, the compound size is compared using ``operator``< (the compound size might
            be different for dynamic arrays). If both compounds are of equal size, the compounds
            elements are compared in lexicographic order.
          - For resources, the values are compared using ``strcmp()``.

        :type lhs: :py:class:`IValue`
        :param lhs:          The left-hand side operand for the comparison.
        :type rhs: :py:class:`IValue`
        :param rhs:          The right-hand side operand for the comparison.
        :rtype: int
        :return: -1 if ``lhs`` < ``rhs``, 0 if ``lhs`` == ``rhs``, and +1 if ``lhs`` > ``rhs``.

        |

        *Overload 2:*
        Compares two instances of #mi::neuraylib::IValue_list.

        The comparison operator for instances of #mi::neuraylib::IValue_list is defined as follows:
        - If ``lhs`` or ``rhs`` is ``NULL``, the result is the lexicographic comparison of
          the pointer addresses themselves.
        - Next, the list sizes are compared using ``operator``<().
        - Next, the lists are traversed by increasing index and the names are compared
          using ``strcmp()``.
        - Finally, the list elements are enumerated by increasing index and the values are compared.

        :type lhs: :py:class:`IValue_list`
        :param lhs:          The left-hand side operand for the comparison.
        :type rhs: :py:class:`IValue_list`
        :param rhs:          The right-hand side operand for the comparison.
        :rtype: int
        :return: -1 if ``lhs`` < ``rhs``, 0 if ``lhs`` == ``rhs``, and +1 if ``lhs`` > ``rhs``.
        """
        return _pymdlsdk.IValue_factory_compare(self, *args)

    def dump(self, *args):
        r"""
        *Overload 1:*
         Returns a textual representation of a value.

         The textual representation is of the form "type name = value" if ``name`` is not ``NULL``, and
         of the form "value" if ``name`` is ``NULL``. The representation of the value might contain
         line breaks, for example for structures, enums, and arrays. Subsequent lines have a suitable
         indentation. The assumed indentation level of the first line is specified by ``depth``.

         Notes: The exact format of the textual representation is unspecified and might change in
               future releases. The textual representation is primarily meant as a debugging aid. Do
               *not* base application logic on it.

        |

        *Overload 2:*
         Returns a textual representation of a value list.

         The representation of the value list will contain line breaks. Subsequent lines have a
         suitable indentation. The assumed indentation level of the first line is specified by
        ``depth``.

         Notes: The exact format of the textual representation is unspecified and might change in
               future releases. The textual representation is primarily meant as a debugging aid. Do
               *not* base application logic on it.

        |

        *Overload 3:*
         Returns a textual representation of a value list.

         The representation of the value list will contain line breaks. Subsequent lines have a
         suitable indentation. The assumed indentation level of the first line is specified by
        ``depth``.

         Notes: The exact format of the textual representation is unspecified and might change in
               future releases. The textual representation is primarily meant as a debugging aid. Do
               *not* base application logic on it.
        """
        return _pymdlsdk.IValue_factory_dump(self, *args)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IValue_factory_compare_iid(self, iid)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IValue_factory__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IValue_factory__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IValue_factory_get_iid(self)

# Register IValue_factory in _pymdlsdk:
_pymdlsdk.IValue_factory_swigregister(IValue_factory)

def IValue_factory_IID():
    return _pymdlsdk.IValue_factory_IID()

def IValue_factory__get_interface(iface):
    return _pymdlsdk.IValue_factory__get_interface(iface)

class IValue_float(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IValue_float_swiginit(self, _pymdlsdk.new_IValue_float(*args))
    __swig_destroy__ = _pymdlsdk.delete_IValue_float

    def __deref__(self):
        return _pymdlsdk.IValue_float___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IValue_float___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IValue_float_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IValue_float___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IValue_float___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IValue_float_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IValue_float_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IValue_float__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IValue.Kind(self._get_kind(*args))


    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk.IValue_float_get_type(self)

    def get_value(self):
        r""" Returns the value."""
        return _pymdlsdk.IValue_float_get_value(self)

    def set_value(self, value):
        r""" Sets the value."""
        return _pymdlsdk.IValue_float_set_value(self, value)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IValue_float_compare_iid(self, iid)

    def _get_kind(self):
        r""" Returns the kind of the value."""
        return _pymdlsdk.IValue_float__get_kind(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IValue_float__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IValue_float__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IValue_float_get_iid(self)

# Register IValue_float in _pymdlsdk:
_pymdlsdk.IValue_float_swigregister(IValue_float)

def IValue_float_IID():
    return _pymdlsdk.IValue_float_IID()

def IValue_float__get_interface(iface):
    return _pymdlsdk.IValue_float__get_interface(iface)

class IValue_int(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IValue_int_swiginit(self, _pymdlsdk.new_IValue_int(*args))
    __swig_destroy__ = _pymdlsdk.delete_IValue_int

    def __deref__(self):
        return _pymdlsdk.IValue_int___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IValue_int___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IValue_int_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IValue_int___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IValue_int___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IValue_int_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IValue_int_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IValue_int__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IValue.Kind(self._get_kind(*args))


    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk.IValue_int_get_type(self)

    def get_value(self):
        r""" Returns the value."""
        return _pymdlsdk.IValue_int_get_value(self)

    def set_value(self, value):
        r""" Sets the value."""
        return _pymdlsdk.IValue_int_set_value(self, value)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IValue_int_compare_iid(self, iid)

    def _get_kind(self):
        r""" Returns the kind of the value."""
        return _pymdlsdk.IValue_int__get_kind(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IValue_int__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IValue_int__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IValue_int_get_iid(self)

# Register IValue_int in _pymdlsdk:
_pymdlsdk.IValue_int_swigregister(IValue_int)

def IValue_int_IID():
    return _pymdlsdk.IValue_int_IID()

def IValue_int__get_interface(iface):
    return _pymdlsdk.IValue_int__get_interface(iface)

class IValue_invalid_df(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IValue_invalid_df_swiginit(self, _pymdlsdk.new_IValue_invalid_df(*args))
    __swig_destroy__ = _pymdlsdk.delete_IValue_invalid_df

    def __deref__(self):
        return _pymdlsdk.IValue_invalid_df___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IValue_invalid_df___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IValue_invalid_df_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IValue_invalid_df___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IValue_invalid_df___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IValue_invalid_df_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IValue_invalid_df_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IValue_invalid_df__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IValue.Kind(self._get_kind(*args))


    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk.IValue_invalid_df_get_type(self)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IValue_invalid_df_compare_iid(self, iid)

    def _get_kind(self):
        r""" Returns the kind of the value."""
        return _pymdlsdk.IValue_invalid_df__get_kind(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IValue_invalid_df__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IValue_invalid_df__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IValue_invalid_df_get_iid(self)

# Register IValue_invalid_df in _pymdlsdk:
_pymdlsdk.IValue_invalid_df_swigregister(IValue_invalid_df)

def IValue_invalid_df_IID():
    return _pymdlsdk.IValue_invalid_df_IID()

def IValue_invalid_df__get_interface(iface):
    return _pymdlsdk.IValue_invalid_df__get_interface(iface)

class IValue_light_profile(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IValue_light_profile_swiginit(self, _pymdlsdk.new_IValue_light_profile(*args))
    __swig_destroy__ = _pymdlsdk.delete_IValue_light_profile

    def __deref__(self):
        return _pymdlsdk.IValue_light_profile___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IValue_light_profile___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IValue_light_profile_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IValue_light_profile___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IValue_light_profile___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IValue_light_profile_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IValue_light_profile_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IValue_light_profile__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IValue.Kind(self._get_kind(*args))


    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk.IValue_light_profile_get_type(self)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IValue_light_profile_compare_iid(self, iid)

    def get_value(self):
        r"""
        Returns the name of the DB element representing this resource.

        :rtype: string
        :return: The name of the DB element, or ``NULL`` if no valid resource is set.
        """
        return _pymdlsdk.IValue_light_profile_get_value(self)

    def set_value(self, value):
        r"""
        Sets the name of the DB element representing this resource.

        Pointing this instance to a different DB element resets the MDL file path returned by
        #get_file_path().

        :type value: string
        :param value:   The name of the resource, or ``NULL`` to release the current resource.
        :rtype: int
        :return: 
                           -  0: Success.
                           - -1: There is no DB element with that name.
                           - -2: The DB element has not the correct type for this resource.
        """
        return _pymdlsdk.IValue_light_profile_set_value(self, value)

    def get_file_path(self):
        r"""
        Returns the absolute MDL file path of the resource, or ``NULL`` if not known.

        Notes: The value returned here is not a property of this object, but a property of the
              referenced resource.
        """
        return _pymdlsdk.IValue_light_profile_get_file_path(self)

    def _get_kind(self):
        r""" Returns the kind of the value."""
        return _pymdlsdk.IValue_light_profile__get_kind(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IValue_light_profile__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IValue_light_profile__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IValue_light_profile_get_iid(self)

# Register IValue_light_profile in _pymdlsdk:
_pymdlsdk.IValue_light_profile_swigregister(IValue_light_profile)

def IValue_light_profile_IID():
    return _pymdlsdk.IValue_light_profile_IID()

def IValue_light_profile__get_interface(iface):
    return _pymdlsdk.IValue_light_profile__get_interface(iface)

class IValue_list(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IValue_list_swiginit(self, _pymdlsdk.new_IValue_list(*args))
    __swig_destroy__ = _pymdlsdk.delete_IValue_list

    def __deref__(self):
        return _pymdlsdk.IValue_list___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IValue_list___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IValue_list_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IValue_list___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IValue_list___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IValue_list_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IValue_list_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IValue_list__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_size(self):
        r""" Returns the number of elements."""
        return _pymdlsdk.IValue_list_get_size(self)

    def get_index(self, name):
        r""" Returns the index for the given name, or -1 if there is no such value."""
        return _pymdlsdk.IValue_list_get_index(self, name)

    def get_name(self, index):
        r""" Returns the name for the given index, or ``NULL`` if there is no such value."""
        return _pymdlsdk.IValue_list_get_name(self, index)

    def get_value(self, *args):
        r"""
        *Overload 1:*
        Returns the value for ``index``, or ``NULL`` if there is no such value.

        |

        *Overload 2:*
        Returns the value for ``name``, or ``NULL`` if there is no such value.
        """
        return _pymdlsdk.IValue_list_get_value(self, *args)

    def set_value(self, *args):
        r"""
        *Overload 1:*
        Sets a value at a given index.

        :rtype: int
        :return: 
                      -  0: Success.
                      - -1: Invalid parameter (``NULL`` pointer).
                      - -2: ``index`` is out of bounds.

        |

        *Overload 2:*
        Sets a value identified by name.

        :rtype: int
        :return: 
                      -  0: Success.
                      - -1: Invalid parameter (``NULL`` pointer).
                      - -2: There is no value mapped to ``name`` in the list.
        """
        return _pymdlsdk.IValue_list_set_value(self, *args)

    def add_value(self, name, value):
        r"""
        Adds a value at the end of the list.

        :rtype: int
        :return: 
                      -  0: Success.
                      - -1: Invalid parameter (``NULL`` pointer).
                      - -2: There is already a value mapped to ``name`` in the list.
        """
        return _pymdlsdk.IValue_list_add_value(self, name, value)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IValue_list_compare_iid(self, iid)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IValue_list__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IValue_list__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IValue_list_get_iid(self)

# Register IValue_list in _pymdlsdk:
_pymdlsdk.IValue_list_swigregister(IValue_list)

def IValue_list_IID():
    return _pymdlsdk.IValue_list_IID()

def IValue_list__get_interface(iface):
    return _pymdlsdk.IValue_list__get_interface(iface)

class IValue_matrix(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IValue_matrix_swiginit(self, _pymdlsdk.new_IValue_matrix(*args))
    __swig_destroy__ = _pymdlsdk.delete_IValue_matrix

    def __deref__(self):
        return _pymdlsdk.IValue_matrix___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IValue_matrix___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IValue_matrix_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IValue_matrix___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IValue_matrix___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IValue_matrix_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IValue_matrix_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IValue_matrix__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IValue.Kind(self._get_kind(*args))


    def get_value(self, *args):
        return  self._get_value(*args)

    def get_value_as(self, type, *args):
        iinterface = self._get_value(*args)
        if iinterface.is_valid_interface():
            typed_interface = iinterface.get_interface(type)
            iinterface = None
            return typed_interface
        else:
            return iinterface


    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk.IValue_matrix_get_type(self)

    def _get_value(self, *args):
        r"""
        *Overload 1:*
        Returns the value at ``index``, or ``NULL`` if ``index`` is out of bounds.

        |

        *Overload 2:*
        Returns the value at ``index``, or ``NULL`` if ``index`` is out of bounds.
        """
        return _pymdlsdk.IValue_matrix__get_value(self, *args)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IValue_matrix_compare_iid(self, iid)

    def get_size(self):
        r""" Returns the number of components in this compound value."""
        return _pymdlsdk.IValue_matrix_get_size(self)

    def set_value(self, index, value):
        r"""
        Sets the value at ``index``.

        :type index: int
        :param index:   The index of the field.
        :type value: :py:class:`IValue`
        :param value:   The new value of the field.
        :rtype: int
        :return: 
                           -  0: Success.
                           - -1: Invalid parameter (``NULL`` pointer).
                           - -2: ``index`` is out of bounds.
                           - -3: Incorrect type of ``value``.
        """
        return _pymdlsdk.IValue_matrix_set_value(self, index, value)

    def _get_kind(self):
        r""" Returns the kind of the value."""
        return _pymdlsdk.IValue_matrix__get_kind(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IValue_matrix__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IValue_matrix__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IValue_matrix_get_iid(self)

# Register IValue_matrix in _pymdlsdk:
_pymdlsdk.IValue_matrix_swigregister(IValue_matrix)

def IValue_matrix_IID():
    return _pymdlsdk.IValue_matrix_IID()

def IValue_matrix__get_interface(iface):
    return _pymdlsdk.IValue_matrix__get_interface(iface)

class IValue_resource(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IValue_resource_swiginit(self, _pymdlsdk.new_IValue_resource(*args))
    __swig_destroy__ = _pymdlsdk.delete_IValue_resource

    def __deref__(self):
        return _pymdlsdk.IValue_resource___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IValue_resource___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IValue_resource_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IValue_resource___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IValue_resource___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IValue_resource_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IValue_resource_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IValue_resource__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IValue.Kind(self._get_kind(*args))


    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk.IValue_resource_get_type(self)

    def get_value(self):
        r"""
        Returns the name of the DB element representing this resource.

        :rtype: string
        :return: The name of the DB element, or ``NULL`` if no valid resource is set.
        """
        return _pymdlsdk.IValue_resource_get_value(self)

    def set_value(self, value):
        r"""
        Sets the name of the DB element representing this resource.

        Pointing this instance to a different DB element resets the MDL file path returned by
        #get_file_path().

        :type value: string
        :param value:   The name of the resource, or ``NULL`` to release the current resource.
        :rtype: int
        :return: 
                           -  0: Success.
                           - -1: There is no DB element with that name.
                           - -2: The DB element has not the correct type for this resource.
        """
        return _pymdlsdk.IValue_resource_set_value(self, value)

    def get_file_path(self):
        r"""
        Returns the absolute MDL file path of the resource, or ``NULL`` if not known.

        Notes: The value returned here is not a property of this object, but a property of the
              referenced resource.
        """
        return _pymdlsdk.IValue_resource_get_file_path(self)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IValue_resource_compare_iid(self, iid)

    def _get_kind(self):
        r""" Returns the kind of the value."""
        return _pymdlsdk.IValue_resource__get_kind(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IValue_resource__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IValue_resource__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IValue_resource_get_iid(self)

# Register IValue_resource in _pymdlsdk:
_pymdlsdk.IValue_resource_swigregister(IValue_resource)

def IValue_resource_IID():
    return _pymdlsdk.IValue_resource_IID()

def IValue_resource__get_interface(iface):
    return _pymdlsdk.IValue_resource__get_interface(iface)

class IValue_string(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IValue_string_swiginit(self, _pymdlsdk.new_IValue_string(*args))
    __swig_destroy__ = _pymdlsdk.delete_IValue_string

    def __deref__(self):
        return _pymdlsdk.IValue_string___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IValue_string___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IValue_string_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IValue_string___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IValue_string___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IValue_string_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IValue_string_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IValue_string__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IValue.Kind(self._get_kind(*args))


    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk.IValue_string_get_type(self)

    def get_value(self):
        r""" Returns the value."""
        return _pymdlsdk.IValue_string_get_value(self)

    def set_value(self, value):
        r""" Sets the value."""
        return _pymdlsdk.IValue_string_set_value(self, value)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IValue_string_compare_iid(self, iid)

    def _get_kind(self):
        r""" Returns the kind of the value."""
        return _pymdlsdk.IValue_string__get_kind(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IValue_string__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IValue_string__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IValue_string_get_iid(self)

# Register IValue_string in _pymdlsdk:
_pymdlsdk.IValue_string_swigregister(IValue_string)

def IValue_string_IID():
    return _pymdlsdk.IValue_string_IID()

def IValue_string__get_interface(iface):
    return _pymdlsdk.IValue_string__get_interface(iface)

class IValue_string_localized(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IValue_string_localized_swiginit(self, _pymdlsdk.new_IValue_string_localized(*args))
    __swig_destroy__ = _pymdlsdk.delete_IValue_string_localized

    def __deref__(self):
        return _pymdlsdk.IValue_string_localized___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IValue_string_localized___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IValue_string_localized_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IValue_string_localized___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IValue_string_localized___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IValue_string_localized_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IValue_string_localized_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IValue_string_localized__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IValue.Kind(self._get_kind(*args))


    def get_original_value(self):
        r"""
        Returns the original value of a localized string.
        While IValue_string::value() returns the translated string.
        """
        return _pymdlsdk.IValue_string_localized_get_original_value(self)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IValue_string_localized_compare_iid(self, iid)

    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk.IValue_string_localized_get_type(self)

    def get_value(self):
        r""" Returns the value."""
        return _pymdlsdk.IValue_string_localized_get_value(self)

    def set_value(self, value):
        r""" Sets the value."""
        return _pymdlsdk.IValue_string_localized_set_value(self, value)

    def _get_kind(self):
        r""" Returns the kind of the value."""
        return _pymdlsdk.IValue_string_localized__get_kind(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IValue_string_localized__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IValue_string_localized__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IValue_string_localized_get_iid(self)

# Register IValue_string_localized in _pymdlsdk:
_pymdlsdk.IValue_string_localized_swigregister(IValue_string_localized)

def IValue_string_localized_IID():
    return _pymdlsdk.IValue_string_localized_IID()

def IValue_string_localized__get_interface(iface):
    return _pymdlsdk.IValue_string_localized__get_interface(iface)

class IValue_structure(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IValue_structure_swiginit(self, _pymdlsdk.new_IValue_structure(*args))
    __swig_destroy__ = _pymdlsdk.delete_IValue_structure

    def __deref__(self):
        return _pymdlsdk.IValue_structure___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IValue_structure___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IValue_structure_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IValue_structure___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IValue_structure___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IValue_structure_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IValue_structure_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IValue_structure__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IValue.Kind(self._get_kind(*args))


    def get_value(self, *args):
        return  self._get_value(*args)

    def get_value_as(self, type, *args):
        iinterface = self._get_value(*args)
        if iinterface.is_valid_interface():
            typed_interface = iinterface.get_interface(type)
            iinterface = None
            return typed_interface
        else:
            return iinterface


    def get_field(self, *args):
        return  self._get_field(*args)

    def get_field_as(self, type, *args):
        iinterface = self._get_field(*args)
        if iinterface.is_valid_interface():
            typed_interface = iinterface.get_interface(type)
            iinterface = None
            return typed_interface
        else:
            return iinterface


    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk.IValue_structure_get_type(self)

    def _get_field(self, *args):
        r"""
        *Overload 1:*
        Returns a field by name in linear time.

        :type name: string
        :param name:    The name of the field.
        :rtype: :py:class:`IValue`
        :return: The value of the field, or ``NULL`` if there is no such field.

        |

        *Overload 2:*
        Returns a field by name in linear time.

        :type name: string
        :param name:    The name of the field.
        :rtype: :py:class:`IValue`
        :return: The value of the field, or ``NULL`` if there is no such field.
        """
        return _pymdlsdk.IValue_structure__get_field(self, *args)

    def set_field(self, name, value):
        r"""
        Sets a field by name in linear time.

        :type name: string
        :param name:    The name of the field.
        :type value: :py:class:`IValue`
        :param value:   The new value of the field.
        :rtype: int
        :return: 
                           -  0: Success.
                           - -1: Invalid parameter (``NULL`` pointer).
                           - -2: There is no such field of the given name.
                           - -3: Incorrect type of ``value``.
        """
        return _pymdlsdk.IValue_structure_set_field(self, name, value)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IValue_structure_compare_iid(self, iid)

    def get_size(self):
        r""" Returns the number of components in this compound value."""
        return _pymdlsdk.IValue_structure_get_size(self)

    def _get_value(self, *args):
        r"""
        *Overload 1:*
        Returns the value at ``index``, or ``NULL`` if ``index`` is out of bounds.

        |

        *Overload 2:*
        Returns the value at ``index``, or ``NULL`` if ``index`` is out of bounds.
        """
        return _pymdlsdk.IValue_structure__get_value(self, *args)

    def set_value(self, index, value):
        r"""
        Sets the value at ``index``.

        :type index: int
        :param index:   The index of the field.
        :type value: :py:class:`IValue`
        :param value:   The new value of the field.
        :rtype: int
        :return: 
                           -  0: Success.
                           - -1: Invalid parameter (``NULL`` pointer).
                           - -2: ``index`` is out of bounds.
                           - -3: Incorrect type of ``value``.
        """
        return _pymdlsdk.IValue_structure_set_value(self, index, value)

    def _get_kind(self):
        r""" Returns the kind of the value."""
        return _pymdlsdk.IValue_structure__get_kind(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IValue_structure__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IValue_structure__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IValue_structure_get_iid(self)

# Register IValue_structure in _pymdlsdk:
_pymdlsdk.IValue_structure_swigregister(IValue_structure)

def IValue_structure_IID():
    return _pymdlsdk.IValue_structure_IID()

def IValue_structure__get_interface(iface):
    return _pymdlsdk.IValue_structure__get_interface(iface)

class IValue_texture(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IValue_texture_swiginit(self, _pymdlsdk.new_IValue_texture(*args))
    __swig_destroy__ = _pymdlsdk.delete_IValue_texture

    def __deref__(self):
        return _pymdlsdk.IValue_texture___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IValue_texture___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IValue_texture_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IValue_texture___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IValue_texture___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IValue_texture_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IValue_texture_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IValue_texture__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IValue.Kind(self._get_kind(*args))


    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk.IValue_texture_get_type(self)

    def get_gamma(self):
        r"""
        Returns the gamma value of this texture.

        Notes: : A gamma value of 0 corresponds to the default gamma value for the given texture
               kind.
        """
        return _pymdlsdk.IValue_texture_get_gamma(self)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IValue_texture_compare_iid(self, iid)

    def get_value(self):
        r"""
        Returns the name of the DB element representing this resource.

        :rtype: string
        :return: The name of the DB element, or ``NULL`` if no valid resource is set.
        """
        return _pymdlsdk.IValue_texture_get_value(self)

    def set_value(self, value):
        r"""
        Sets the name of the DB element representing this resource.

        Pointing this instance to a different DB element resets the MDL file path returned by
        #get_file_path().

        :type value: string
        :param value:   The name of the resource, or ``NULL`` to release the current resource.
        :rtype: int
        :return: 
                           -  0: Success.
                           - -1: There is no DB element with that name.
                           - -2: The DB element has not the correct type for this resource.
        """
        return _pymdlsdk.IValue_texture_set_value(self, value)

    def get_file_path(self):
        r"""
        Returns the absolute MDL file path of the resource, or ``NULL`` if not known.

        Notes: The value returned here is not a property of this object, but a property of the
              referenced resource.
        """
        return _pymdlsdk.IValue_texture_get_file_path(self)

    def _get_kind(self):
        r""" Returns the kind of the value."""
        return _pymdlsdk.IValue_texture__get_kind(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IValue_texture__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IValue_texture__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IValue_texture_get_iid(self)

# Register IValue_texture in _pymdlsdk:
_pymdlsdk.IValue_texture_swigregister(IValue_texture)

def IValue_texture_IID():
    return _pymdlsdk.IValue_texture_IID()

def IValue_texture__get_interface(iface):
    return _pymdlsdk.IValue_texture__get_interface(iface)

class IValue_vector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _pymdlsdk.IValue_vector_swiginit(self, _pymdlsdk.new_IValue_vector(*args))
    __swig_destroy__ = _pymdlsdk.delete_IValue_vector

    def __deref__(self):
        return _pymdlsdk.IValue_vector___deref__(self)

    def __ref__(self):
        return _pymdlsdk.IValue_vector___ref__(self)

    def is_valid_interface(self):
        return _pymdlsdk.IValue_vector_is_valid_interface(self)

    def __enter__(self):
        return _pymdlsdk.IValue_vector___enter__(self)

    def __exit__(self, exc_type, exc_value, exc_traceback):
        return _pymdlsdk.IValue_vector___exit__(self, exc_type, exc_value, exc_traceback)

    def release(self):
        return _pymdlsdk.IValue_vector_release(self)

    @staticmethod
    def IID():
        return _pymdlsdk.IValue_vector_IID()

    @staticmethod
    def _get_interface(iface):
        return _pymdlsdk.IValue_vector__get_interface(iface)

    def get_interface(self, type):
        typed_interface = type._get_interface(self)
        typed_interface.thisown = True
        return typed_interface


    def get_kind(self, *args):
        return IValue.Kind(self._get_kind(*args))


    def get_value(self, *args):
        return  self._get_value(*args)

    def get_value_as(self, type, *args):
        iinterface = self._get_value(*args)
        if iinterface.is_valid_interface():
            typed_interface = iinterface.get_interface(type)
            iinterface = None
            return typed_interface
        else:
            return iinterface


    def get_type(self):
        r""" Returns the type of this value."""
        return _pymdlsdk.IValue_vector_get_type(self)

    def _get_value(self, *args):
        r"""
        *Overload 1:*
        Returns the value at ``index``, or ``NULL`` if ``index`` is out of bounds.

        |

        *Overload 2:*
        Returns the value at ``index``, or ``NULL`` if ``index`` is out of bounds.
        """
        return _pymdlsdk.IValue_vector__get_value(self, *args)

    def compare_iid(self, iid):
        r"""
        Compares the interface ID ``iid`` against the interface ID of this interface and of its
        ancestors.

        :rtype: boolean
        :return: ``true`` if ``iid`` == ``IID()`` or is equal to one of the interface IDs of
            its ancestors, and ``false`` otherwise.
        """
        return _pymdlsdk.IValue_vector_compare_iid(self, iid)

    def get_size(self):
        r""" Returns the number of components in this compound value."""
        return _pymdlsdk.IValue_vector_get_size(self)

    def set_value(self, index, value):
        r"""
        Sets the value at ``index``.

        :type index: int
        :param index:   The index of the field.
        :type value: :py:class:`IValue`
        :param value:   The new value of the field.
        :rtype: int
        :return: 
                           -  0: Success.
                           - -1: Invalid parameter (``NULL`` pointer).
                           - -2: ``index`` is out of bounds.
                           - -3: Incorrect type of ``value``.
        """
        return _pymdlsdk.IValue_vector_set_value(self, index, value)

    def _get_kind(self):
        r""" Returns the kind of the value."""
        return _pymdlsdk.IValue_vector__get_kind(self)

    def _retain(self):
        r"""
        Increments the reference count.

        Increments the reference count of the object referenced through this interface and returns
        the new reference count. The operation is thread-safe.

        :rtype: int
        :return: The new, incremented reference count.
        """
        return _pymdlsdk.IValue_vector__retain(self)

    def _release(self):
        r"""
        Decrements the reference count.

        Decrements the reference count of the object referenced through this interface and returns
        the new reference count. If the reference count dropped to zero, the object will be deleted.
        The operation is thread-safe.

        :rtype: int
        :return: The new, decremented reference count.
        """
        return _pymdlsdk.IValue_vector__release(self)

    def get_iid(self):
        r""" Returns the interface ID of the most derived interface."""
        return _pymdlsdk.IValue_vector_get_iid(self)

# Register IValue_vector in _pymdlsdk:
_pymdlsdk.IValue_vector_swigregister(IValue_vector)

def IValue_vector_IID():
    return _pymdlsdk.IValue_vector_IID()

def IValue_vector__get_interface(iface):
    return _pymdlsdk.IValue_vector__get_interface(iface)


def _print_open_handle_statistic():
    return _pymdlsdk._print_open_handle_statistic()

def _enable_print_ref_counts(arg1):
    return _pymdlsdk._enable_print_ref_counts(arg1)

def attach_ineuray(ptr_as_uint64):
    return _pymdlsdk.attach_ineuray(ptr_as_uint64)

def attach_itransaction(ptr_as_uint64):
    return _pymdlsdk.attach_itransaction(ptr_as_uint64)

def load_and_get_ineuray(arg1):
    return _pymdlsdk.load_and_get_ineuray(arg1)

def load_plugin(arg1, arg2):
    return _pymdlsdk.load_plugin(arg1, arg2)

def unload():
    return _pymdlsdk.unload()


